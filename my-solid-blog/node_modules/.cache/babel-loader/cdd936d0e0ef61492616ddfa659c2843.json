{"ast":null,"code":"import { OidcClient, WebStorageStateStore } from 'oidc-client';\nexport { CordovaIFrameNavigator, CordovaPopupNavigator, InMemoryWebStorage, Log, OidcClient, SessionMonitor, User, UserManager, Version, WebStorageStateStore } from 'oidc-client';\nimport { determineSigningAlg, PREFERRED_SIGNING_ALG, getWebidFromTokenPayload, generateDpopKeyPair, createDpopHeader } from '@inrupt/solid-client-authn-core';\nimport formurlencoded from 'form-urlencoded';\n\nfunction processErrorResponse(responseBody, options) {\n  var _a, _b, _c, _d;\n\n  if (responseBody.error === \"invalid_redirect_uri\") {\n    throw new Error(`Dynamic client registration failed: the provided redirect uri [${(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()}] is invalid - ${(_b = responseBody.error_description) !== null && _b !== void 0 ? _b : \"\"}`);\n  }\n\n  if (responseBody.error === \"invalid_client_metadata\") {\n    throw new Error(`Dynamic client registration failed: the provided client metadata ${JSON.stringify(options)} is invalid - ${(_c = responseBody.error_description) !== null && _c !== void 0 ? _c : \"\"}`);\n  }\n\n  throw new Error(`Dynamic client registration failed: ${responseBody.error} - ${(_d = responseBody.error_description) !== null && _d !== void 0 ? _d : \"\"}`);\n}\n\nfunction validateRegistrationResponse(responseBody, options) {\n  if (responseBody.client_id === undefined) {\n    throw new Error(`Dynamic client registration failed: no client_id has been found on ${JSON.stringify(responseBody)}`);\n  }\n\n  if (options.redirectUrl && (responseBody.redirect_uris === undefined || responseBody.redirect_uris[0] !== options.redirectUrl.toString())) {\n    throw new Error(`Dynamic client registration failed: the returned redirect URIs ${JSON.stringify(responseBody.redirect_uris)} don't match the provided ${JSON.stringify([options.redirectUrl.toString()])}`);\n  }\n}\n\nasync function registerClient(options, issuerConfig) {\n  var _a;\n\n  if (!issuerConfig.registrationEndpoint) {\n    throw new Error(\"Dynamic Registration could not be completed because the issuer has no registration endpoint.\");\n  }\n\n  if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {\n    throw new Error(\"The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.\");\n  }\n\n  const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, PREFERRED_SIGNING_ALG);\n  const config = {\n    client_name: options.clientName,\n    application_type: \"web\",\n    redirect_uris: [(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()],\n    subject_type: \"pairwise\",\n    token_endpoint_auth_method: \"client_secret_basic\",\n    id_token_signed_response_alg: signingAlg\n  };\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n\n  if (options.registrationAccessToken) {\n    headers.Authorization = `Bearer ${options.registrationAccessToken}`;\n  }\n\n  const registerResponse = await fetch(issuerConfig.registrationEndpoint.toString(), {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(config)\n  });\n\n  if (registerResponse.ok) {\n    const responseBody = await registerResponse.json();\n    validateRegistrationResponse(responseBody, options);\n    return {\n      clientId: responseBody.client_id,\n      clientSecret: responseBody.client_secret,\n      idTokenSignedResponseAlg: responseBody.id_token_signed_response_alg\n    };\n  }\n\n  if (registerResponse.status === 400) {\n    processErrorResponse(await registerResponse.json(), options);\n  }\n\n  throw new Error(`Dynamic client registration failed: the server returned ${registerResponse.status} ${registerResponse.statusText} - ${await registerResponse.text()}`);\n}\n\nfunction hasError(value) {\n  return value.error !== undefined && typeof value.error === \"string\";\n}\n\nfunction hasErrorDescription(value) {\n  return value.error_description !== undefined && typeof value.error_description === \"string\";\n}\n\nfunction hasErrorUri(value) {\n  return value.error_uri !== undefined && typeof value.error_uri === \"string\";\n}\n\nfunction hasAccessToken(value) {\n  return value.access_token !== undefined && typeof value.access_token === \"string\";\n}\n\nfunction hasIdToken(value) {\n  return value.id_token !== undefined && typeof value.id_token === \"string\";\n}\n\nfunction hasRefreshToken(value) {\n  return value.refresh_token !== undefined && typeof value.refresh_token === \"string\";\n}\n\nfunction hasTokenType(value) {\n  return value.token_type !== undefined && typeof value.token_type === \"string\";\n}\n\nfunction hasExpiresIn(value) {\n  return value.expires_in === undefined || typeof value.expires_in === \"number\";\n}\n\nfunction validatePreconditions(issuer, data) {\n  if (data.grantType && (!issuer.grantTypesSupported || !issuer.grantTypesSupported.includes(data.grantType))) {\n    throw new Error(`The issuer [${issuer.issuer}] does not support the [${data.grantType}] grant`);\n  }\n\n  if (!issuer.tokenEndpoint) {\n    throw new Error(`This issuer [${issuer.issuer}] does not have a token endpoint`);\n  }\n}\n\nfunction validateTokenEndpointResponse(tokenResponse, dpop) {\n  if (hasError(tokenResponse)) {\n    throw new Error(`Token endpoint returned error [${tokenResponse.error}]${hasErrorDescription(tokenResponse) ? `: ${tokenResponse.error_description}` : \"\"}${hasErrorUri(tokenResponse) ? ` (see ${tokenResponse.error_uri})` : \"\"}`);\n  }\n\n  if (!hasAccessToken(tokenResponse)) {\n    throw new Error(`Invalid token endpoint response (missing the field 'access_token'): ${JSON.stringify(tokenResponse)}`);\n  }\n\n  if (!hasIdToken(tokenResponse)) {\n    throw new Error(`Invalid token endpoint response (missing the field 'id_token'): ${JSON.stringify(tokenResponse)}.`);\n  }\n\n  if (!hasTokenType(tokenResponse)) {\n    throw new Error(`Invalid token endpoint response (missing the field 'token_type'): ${JSON.stringify(tokenResponse)}`);\n  }\n\n  if (!hasExpiresIn(tokenResponse)) {\n    throw new Error(`Invalid token endpoint response (invalid field 'expires_in'): ${JSON.stringify(tokenResponse)}`);\n  }\n\n  if (!dpop && tokenResponse.token_type.toLowerCase() !== \"bearer\") {\n    throw new Error(`Invalid token endpoint response: requested a [Bearer] token, but got a 'token_type' value of [${tokenResponse.token_type}].`);\n  }\n\n  return tokenResponse;\n}\n\nasync function getTokens(issuer, client, data, dpop) {\n  validatePreconditions(issuer, data);\n  const headers = {\n    \"content-type\": \"application/x-www-form-urlencoded\"\n  };\n  let dpopKey;\n\n  if (dpop) {\n    dpopKey = await generateDpopKeyPair();\n    headers.DPoP = await createDpopHeader(issuer.tokenEndpoint, \"POST\", dpopKey);\n  }\n\n  if (client.clientSecret) {\n    headers.Authorization = `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`;\n  }\n\n  const tokenRequestInit = {\n    method: \"POST\",\n    headers,\n    body: formurlencoded({\n      grant_type: data.grantType,\n      redirect_uri: data.redirectUrl,\n      code: data.code,\n      code_verifier: data.codeVerifier,\n      client_id: client.clientId\n    })\n  };\n  const rawTokenResponse = await await fetch(issuer.tokenEndpoint, tokenRequestInit);\n  const jsonTokenResponse = await rawTokenResponse.json();\n  const tokenResponse = validateTokenEndpointResponse(jsonTokenResponse, dpop);\n  const webId = await getWebidFromTokenPayload(tokenResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);\n  return {\n    accessToken: tokenResponse.access_token,\n    idToken: tokenResponse.id_token,\n    refreshToken: hasRefreshToken(tokenResponse) ? tokenResponse.refresh_token : undefined,\n    webId,\n    dpopKey,\n    expiresIn: tokenResponse.expires_in\n  };\n}\n\nasync function getBearerToken(redirectUrl) {\n  let signinResponse;\n\n  try {\n    const client = new OidcClient({\n      response_mode: \"query\",\n      loadUserInfo: false\n    });\n    signinResponse = await client.processSigninResponse(redirectUrl);\n\n    if (client.settings.metadata === undefined) {\n      throw new Error(\"Cannot retrieve issuer metadata from client information in storage.\");\n    }\n\n    if (client.settings.metadata.jwks_uri === undefined) {\n      throw new Error(\"Missing some issuer metadata from client information in storage: 'jwks_uri' is undefined\");\n    }\n\n    if (client.settings.metadata.issuer === undefined) {\n      throw new Error(\"Missing some issuer metadata from client information in storage: 'issuer' is undefined\");\n    }\n\n    if (client.settings.client_id === undefined) {\n      throw new Error(\"Missing some client information in storage: 'client_id' is undefined\");\n    }\n\n    const webId = await getWebidFromTokenPayload(signinResponse.id_token, client.settings.metadata.jwks_uri, client.settings.metadata.issuer, client.settings.client_id);\n    return {\n      accessToken: signinResponse.access_token,\n      idToken: signinResponse.id_token,\n      webId,\n      refreshToken: signinResponse.refresh_token\n    };\n  } catch (err) {\n    throw new Error(`Problem handling Auth Code Grant (Flow) redirect - URL [${redirectUrl}]: ${err}`);\n  }\n}\n\nasync function getDpopToken(issuer, client, data) {\n  return getTokens(issuer, client, data, true);\n}\n\nfunction removeOidcQueryParam(redirectUrl) {\n  const cleanedUrl = new URL(redirectUrl);\n  cleanedUrl.searchParams.delete(\"code\");\n  cleanedUrl.searchParams.delete(\"state\");\n  cleanedUrl.hash = \"\";\n  return cleanedUrl.toString();\n}\n\nasync function clearOidcPersistentStorage() {\n  const client = new OidcClient({\n    response_mode: \"query\"\n  });\n  await client.clearStaleState(new WebStorageStateStore({}));\n  const myStorage = window.localStorage;\n  const itemsToRemove = [];\n\n  for (let i = 0; i <= myStorage.length; i += 1) {\n    const key = myStorage.key(i);\n\n    if (key && (key.match(/^oidc\\..+$/) || key.match(/^solidClientAuthenticationUser:.+$/))) {\n      itemsToRemove.push(key);\n    }\n  }\n\n  itemsToRemove.forEach(key => myStorage.removeItem(key));\n}\n\nexport { clearOidcPersistentStorage, getBearerToken, getDpopToken, registerClient, removeOidcQueryParam };","map":{"version":3,"sources":["/home/carlo/Desktop/Project/my-solid-blog-test/node_modules/@inrupt/oidc-client-ext/dist/index.es.js"],"names":["OidcClient","WebStorageStateStore","CordovaIFrameNavigator","CordovaPopupNavigator","InMemoryWebStorage","Log","SessionMonitor","User","UserManager","Version","determineSigningAlg","PREFERRED_SIGNING_ALG","getWebidFromTokenPayload","generateDpopKeyPair","createDpopHeader","formurlencoded","processErrorResponse","responseBody","options","_a","_b","_c","_d","error","Error","redirectUrl","toString","error_description","JSON","stringify","validateRegistrationResponse","client_id","undefined","redirect_uris","registerClient","issuerConfig","registrationEndpoint","Array","isArray","idTokenSigningAlgValuesSupported","signingAlg","config","client_name","clientName","application_type","subject_type","token_endpoint_auth_method","id_token_signed_response_alg","headers","registrationAccessToken","Authorization","registerResponse","fetch","method","body","ok","json","clientId","clientSecret","client_secret","idTokenSignedResponseAlg","status","statusText","text","hasError","value","hasErrorDescription","hasErrorUri","error_uri","hasAccessToken","access_token","hasIdToken","id_token","hasRefreshToken","refresh_token","hasTokenType","token_type","hasExpiresIn","expires_in","validatePreconditions","issuer","data","grantType","grantTypesSupported","includes","tokenEndpoint","validateTokenEndpointResponse","tokenResponse","dpop","toLowerCase","getTokens","client","dpopKey","DPoP","btoa","tokenRequestInit","grant_type","redirect_uri","code","code_verifier","codeVerifier","rawTokenResponse","jsonTokenResponse","webId","jwksUri","accessToken","idToken","refreshToken","expiresIn","getBearerToken","signinResponse","response_mode","loadUserInfo","processSigninResponse","settings","metadata","jwks_uri","err","getDpopToken","removeOidcQueryParam","cleanedUrl","URL","searchParams","delete","hash","clearOidcPersistentStorage","clearStaleState","myStorage","window","localStorage","itemsToRemove","i","length","key","match","push","forEach","removeItem"],"mappings":"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","sourcesContent":["import { OidcClient, WebStorageStateStore } from 'oidc-client';\nexport { CordovaIFrameNavigator, CordovaPopupNavigator, InMemoryWebStorage, Log, OidcClient, SessionMonitor, User, UserManager, Version, WebStorageStateStore } from 'oidc-client';\nimport { determineSigningAlg, PREFERRED_SIGNING_ALG, getWebidFromTokenPayload, generateDpopKeyPair, createDpopHeader } from '@inrupt/solid-client-authn-core';\nimport formurlencoded from 'form-urlencoded';\n\nfunction processErrorResponse(responseBody, options) {\r\n    var _a, _b, _c, _d;\r\n    if (responseBody.error === \"invalid_redirect_uri\") {\r\n        throw new Error(`Dynamic client registration failed: the provided redirect uri [${(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()}] is invalid - ${(_b = responseBody.error_description) !== null && _b !== void 0 ? _b : \"\"}`);\r\n    }\r\n    if (responseBody.error === \"invalid_client_metadata\") {\r\n        throw new Error(`Dynamic client registration failed: the provided client metadata ${JSON.stringify(options)} is invalid - ${(_c = responseBody.error_description) !== null && _c !== void 0 ? _c : \"\"}`);\r\n    }\r\n    throw new Error(`Dynamic client registration failed: ${responseBody.error} - ${(_d = responseBody.error_description) !== null && _d !== void 0 ? _d : \"\"}`);\r\n}\r\nfunction validateRegistrationResponse(responseBody, options) {\r\n    if (responseBody.client_id === undefined) {\r\n        throw new Error(`Dynamic client registration failed: no client_id has been found on ${JSON.stringify(responseBody)}`);\r\n    }\r\n    if (options.redirectUrl &&\r\n        (responseBody.redirect_uris === undefined ||\r\n            responseBody.redirect_uris[0] !== options.redirectUrl.toString())) {\r\n        throw new Error(`Dynamic client registration failed: the returned redirect URIs ${JSON.stringify(responseBody.redirect_uris)} don't match the provided ${JSON.stringify([\r\n            options.redirectUrl.toString(),\r\n        ])}`);\r\n    }\r\n}\r\nasync function registerClient(options, issuerConfig) {\r\n    var _a;\r\n    if (!issuerConfig.registrationEndpoint) {\r\n        throw new Error(\"Dynamic Registration could not be completed because the issuer has no registration endpoint.\");\r\n    }\r\n    if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {\r\n        throw new Error(\"The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.\");\r\n    }\r\n    const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, PREFERRED_SIGNING_ALG);\r\n    const config = {\r\n        client_name: options.clientName,\r\n        application_type: \"web\",\r\n        redirect_uris: [(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()],\r\n        subject_type: \"pairwise\",\r\n        token_endpoint_auth_method: \"client_secret_basic\",\r\n        id_token_signed_response_alg: signingAlg,\r\n    };\r\n    const headers = {\r\n        \"Content-Type\": \"application/json\",\r\n    };\r\n    if (options.registrationAccessToken) {\r\n        headers.Authorization = `Bearer ${options.registrationAccessToken}`;\r\n    }\r\n    const registerResponse = await fetch(issuerConfig.registrationEndpoint.toString(), {\r\n        method: \"POST\",\r\n        headers,\r\n        body: JSON.stringify(config),\r\n    });\r\n    if (registerResponse.ok) {\r\n        const responseBody = await registerResponse.json();\r\n        validateRegistrationResponse(responseBody, options);\r\n        return {\r\n            clientId: responseBody.client_id,\r\n            clientSecret: responseBody.client_secret,\r\n            idTokenSignedResponseAlg: responseBody.id_token_signed_response_alg,\r\n        };\r\n    }\r\n    if (registerResponse.status === 400) {\r\n        processErrorResponse(await registerResponse.json(), options);\r\n    }\r\n    throw new Error(`Dynamic client registration failed: the server returned ${registerResponse.status} ${registerResponse.statusText} - ${await registerResponse.text()}`);\r\n}\n\nfunction hasError(value) {\r\n    return value.error !== undefined && typeof value.error === \"string\";\r\n}\r\nfunction hasErrorDescription(value) {\r\n    return (value.error_description !== undefined &&\r\n        typeof value.error_description === \"string\");\r\n}\r\nfunction hasErrorUri(value) {\r\n    return value.error_uri !== undefined && typeof value.error_uri === \"string\";\r\n}\r\nfunction hasAccessToken(value) {\r\n    return (value.access_token !== undefined && typeof value.access_token === \"string\");\r\n}\r\nfunction hasIdToken(value) {\r\n    return value.id_token !== undefined && typeof value.id_token === \"string\";\r\n}\r\nfunction hasRefreshToken(value) {\r\n    return (value.refresh_token !== undefined && typeof value.refresh_token === \"string\");\r\n}\r\nfunction hasTokenType(value) {\r\n    return value.token_type !== undefined && typeof value.token_type === \"string\";\r\n}\r\nfunction hasExpiresIn(value) {\r\n    return value.expires_in === undefined || typeof value.expires_in === \"number\";\r\n}\r\nfunction validatePreconditions(issuer, data) {\r\n    if (data.grantType &&\r\n        (!issuer.grantTypesSupported ||\r\n            !issuer.grantTypesSupported.includes(data.grantType))) {\r\n        throw new Error(`The issuer [${issuer.issuer}] does not support the [${data.grantType}] grant`);\r\n    }\r\n    if (!issuer.tokenEndpoint) {\r\n        throw new Error(`This issuer [${issuer.issuer}] does not have a token endpoint`);\r\n    }\r\n}\r\nfunction validateTokenEndpointResponse(tokenResponse, dpop) {\r\n    if (hasError(tokenResponse)) {\r\n        throw new Error(`Token endpoint returned error [${tokenResponse.error}]${hasErrorDescription(tokenResponse)\r\n            ? `: ${tokenResponse.error_description}`\r\n            : \"\"}${hasErrorUri(tokenResponse) ? ` (see ${tokenResponse.error_uri})` : \"\"}`);\r\n    }\r\n    if (!hasAccessToken(tokenResponse)) {\r\n        throw new Error(`Invalid token endpoint response (missing the field 'access_token'): ${JSON.stringify(tokenResponse)}`);\r\n    }\r\n    if (!hasIdToken(tokenResponse)) {\r\n        throw new Error(`Invalid token endpoint response (missing the field 'id_token'): ${JSON.stringify(tokenResponse)}.`);\r\n    }\r\n    if (!hasTokenType(tokenResponse)) {\r\n        throw new Error(`Invalid token endpoint response (missing the field 'token_type'): ${JSON.stringify(tokenResponse)}`);\r\n    }\r\n    if (!hasExpiresIn(tokenResponse)) {\r\n        throw new Error(`Invalid token endpoint response (invalid field 'expires_in'): ${JSON.stringify(tokenResponse)}`);\r\n    }\r\n    if (!dpop && tokenResponse.token_type.toLowerCase() !== \"bearer\") {\r\n        throw new Error(`Invalid token endpoint response: requested a [Bearer] token, but got a 'token_type' value of [${tokenResponse.token_type}].`);\r\n    }\r\n    return tokenResponse;\r\n}\r\nasync function getTokens(issuer, client, data, dpop) {\r\n    validatePreconditions(issuer, data);\r\n    const headers = {\r\n        \"content-type\": \"application/x-www-form-urlencoded\",\r\n    };\r\n    let dpopKey;\r\n    if (dpop) {\r\n        dpopKey = await generateDpopKeyPair();\r\n        headers.DPoP = await createDpopHeader(issuer.tokenEndpoint, \"POST\", dpopKey);\r\n    }\r\n    if (client.clientSecret) {\r\n        headers.Authorization = `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`;\r\n    }\r\n    const tokenRequestInit = {\r\n        method: \"POST\",\r\n        headers,\r\n        body: formurlencoded({\r\n            grant_type: data.grantType,\r\n            redirect_uri: data.redirectUrl,\r\n            code: data.code,\r\n            code_verifier: data.codeVerifier,\r\n            client_id: client.clientId,\r\n        }),\r\n    };\r\n    const rawTokenResponse = await await fetch(issuer.tokenEndpoint, tokenRequestInit);\r\n    const jsonTokenResponse = (await rawTokenResponse.json());\r\n    const tokenResponse = validateTokenEndpointResponse(jsonTokenResponse, dpop);\r\n    const webId = await getWebidFromTokenPayload(tokenResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);\r\n    return {\r\n        accessToken: tokenResponse.access_token,\r\n        idToken: tokenResponse.id_token,\r\n        refreshToken: hasRefreshToken(tokenResponse)\r\n            ? tokenResponse.refresh_token\r\n            : undefined,\r\n        webId,\r\n        dpopKey,\r\n        expiresIn: tokenResponse.expires_in,\r\n    };\r\n}\r\nasync function getBearerToken(redirectUrl) {\r\n    let signinResponse;\r\n    try {\r\n        const client = new OidcClient({\r\n            response_mode: \"query\",\r\n            loadUserInfo: false,\r\n        });\r\n        signinResponse = await client.processSigninResponse(redirectUrl);\r\n        if (client.settings.metadata === undefined) {\r\n            throw new Error(\"Cannot retrieve issuer metadata from client information in storage.\");\r\n        }\r\n        if (client.settings.metadata.jwks_uri === undefined) {\r\n            throw new Error(\"Missing some issuer metadata from client information in storage: 'jwks_uri' is undefined\");\r\n        }\r\n        if (client.settings.metadata.issuer === undefined) {\r\n            throw new Error(\"Missing some issuer metadata from client information in storage: 'issuer' is undefined\");\r\n        }\r\n        if (client.settings.client_id === undefined) {\r\n            throw new Error(\"Missing some client information in storage: 'client_id' is undefined\");\r\n        }\r\n        const webId = await getWebidFromTokenPayload(signinResponse.id_token, client.settings.metadata.jwks_uri, client.settings.metadata.issuer, client.settings.client_id);\r\n        return {\r\n            accessToken: signinResponse.access_token,\r\n            idToken: signinResponse.id_token,\r\n            webId,\r\n            refreshToken: signinResponse.refresh_token,\r\n        };\r\n    }\r\n    catch (err) {\r\n        throw new Error(`Problem handling Auth Code Grant (Flow) redirect - URL [${redirectUrl}]: ${err}`);\r\n    }\r\n}\r\nasync function getDpopToken(issuer, client, data) {\r\n    return getTokens(issuer, client, data, true);\r\n}\n\nfunction removeOidcQueryParam(redirectUrl) {\r\n    const cleanedUrl = new URL(redirectUrl);\r\n    cleanedUrl.searchParams.delete(\"code\");\r\n    cleanedUrl.searchParams.delete(\"state\");\r\n    cleanedUrl.hash = \"\";\r\n    return cleanedUrl.toString();\r\n}\r\nasync function clearOidcPersistentStorage() {\r\n    const client = new OidcClient({\r\n        response_mode: \"query\",\r\n    });\r\n    await client.clearStaleState(new WebStorageStateStore({}));\r\n    const myStorage = window.localStorage;\r\n    const itemsToRemove = [];\r\n    for (let i = 0; i <= myStorage.length; i += 1) {\r\n        const key = myStorage.key(i);\r\n        if (key &&\r\n            (key.match(/^oidc\\..+$/) ||\r\n                key.match(/^solidClientAuthenticationUser:.+$/))) {\r\n            itemsToRemove.push(key);\r\n        }\r\n    }\r\n    itemsToRemove.forEach((key) => myStorage.removeItem(key));\r\n}\n\nexport { clearOidcPersistentStorage, getBearerToken, getDpopToken, registerClient, removeOidcQueryParam };\n"]},"metadata":{},"sourceType":"module"}