{"ast":null,"code":"function isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\nconst xsdString = 'http://www.w3.org/2001/XMLSchema#string';\n\nfunction termToId(term) {\n  if (typeof term === 'string') {\n    return term;\n  }\n\n  if (!term) {\n    return '';\n  }\n\n  if (typeof term.id !== 'undefined' && term.termType !== 'Quad') {\n    return term.id;\n  }\n\n  let subject, predicate, object, graph; // Term instantiated with another library\n\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n\n    case 'BlankNode':\n      return `_:${term.value}`;\n\n    case 'Variable':\n      return `?${term.value}`;\n\n    case 'DefaultGraph':\n      return '';\n\n    case 'Literal':\n      if (term.language) {\n        return `\"${term.value}\"@${term.language}`;\n      }\n\n      return `\"${term.value}\"${term.datatype && term.datatype.value !== xsdString ? `^^${term.datatype.value}` : ''}`;\n\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      subject = escapeQuotes(termToId(term.subject));\n      predicate = escapeQuotes(termToId(term.predicate));\n      object = escapeQuotes(termToId(term.object));\n      graph = term.graph.termType === 'DefaultGraph' ? '' : ` ${termToId(term.graph)}`;\n      return `<<${subject} ${predicate} ${object}${graph}>>`;\n\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n}\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\n\nfunction escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n}\n\nclass DatasetCore {\n  constructor(quads) {\n    // The number of quads is initially zero\n    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph\n\n    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n\n    this._entities = Object.create(null); // inverse of `_ids`\n\n    this._quads = new Map(); // Add quads if passed\n\n    if (quads) {\n      for (const quad of quads) {\n        this.add(quad);\n      }\n    }\n  }\n\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n\n    if (size !== null) {\n      return size;\n    } // Calculate the number of quads by counting to the deepest level\n\n\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n\n    for (const graphKey in graphs) {\n      for (const subjectKey in subjects = graphs[graphKey].subjects) {\n        for (const predicateKey in subject = subjects[subjectKey]) {\n          size += Object.keys(subject[predicateKey]).length;\n        }\n      }\n    }\n\n    this._size = size;\n    return this._size;\n  }\n\n  add(quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject);\n    let predicate = termToId(quad.predicate);\n    let object = termToId(quad.object);\n    const graph = termToId(quad.graph); // Find the graph that will contain the triple\n\n    let graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet\n\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = {\n        subjects: {},\n        predicates: {},\n        objects: {}\n      }; // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n\n      Object.freeze(graphItem);\n    } // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n\n\n    const ids = this._ids;\n    const entities = this._entities;\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n\n    this._addToIndex(graphItem.subjects, subject, predicate, object);\n\n    this._addToIndex(graphItem.predicates, predicate, object, subject);\n\n    this._addToIndex(graphItem.objects, object, subject, predicate);\n\n    this._setQuad(subject, predicate, object, graph, quad); // The cached quad count is now invalid\n\n\n    this._size = null;\n    return this;\n  }\n\n  delete(quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject);\n    let predicate = termToId(quad.predicate);\n    let object = termToId(quad.object);\n    const graph = termToId(quad.graph); // Find internal identifiers for all components\n    // and verify the quad exists.\n\n    const ids = this._ids;\n    const graphs = this._graphs;\n    let graphItem, subjects, predicates;\n\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) {\n      return this;\n    } // Remove it from all indexes\n\n\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n\n    this._removeFromIndex(graphItem.objects, object, subject, predicate);\n\n    if (this._size !== null) {\n      this._size--;\n    }\n\n    this._deleteQuad(subject, predicate, object, graph); // Remove the graph if it is empty\n\n\n    for (subject in graphItem.subjects) {\n      // eslint-disable-line no-unreachable-loop\n      return this;\n    }\n\n    delete graphs[graph];\n    return this;\n  }\n\n  has(quad) {\n    // Convert terms to internal string representation\n    const subject = termToId(quad.subject);\n    const predicate = termToId(quad.predicate);\n    const object = termToId(quad.object);\n    const graph = termToId(quad.graph);\n    const graphItem = this._graphs[graph];\n\n    if (!graphItem) {\n      return false;\n    }\n\n    const ids = this._ids;\n    let subjectId, predicateId, objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {\n      return false;\n    }\n\n    return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1;\n  }\n\n  match(subject, predicate, object, graph) {\n    return this._createDataset(this._match(subject, predicate, object, graph));\n  }\n\n  [Symbol.iterator]() {\n    return this._match()[Symbol.iterator]();\n  } // ## Private methods\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n\n\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad\n\n    const existed = (key2 in index2);\n\n    if (!existed) {\n      index2[key2] = null;\n    }\n\n    return !existed;\n  } // ### `_removeFromIndex` removes a quad from a three-layered index\n\n\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0];\n    const index2 = index1[key1];\n    delete index2[key2]; // Remove intermediary index layers if they are empty\n\n    for (const key in index2) {\n      // eslint-disable-line no-unreachable-loop\n      return;\n    }\n\n    delete index1[key1];\n\n    for (const key in index1) {\n      // eslint-disable-line no-unreachable-loop\n      return;\n    }\n\n    delete index0[key0];\n  } // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n\n\n  _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2; // If a key is specified, use only that part of index 0.\n\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0];\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0];\n\n      if (index1) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1];\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1];\n\n          if (index2) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.\n\n            for (let l = 0; l < values.length; l++) {\n              const parts = {\n                [name0]: value0,\n                [name1]: value1,\n                [name2]: values[l]\n              };\n\n              const quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph);\n\n              if (array) {\n                array.push(quad);\n              } else if (callback(quad)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return array;\n  } // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n\n\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0;\n    let tmp, index1, index2; // If a key is specified, count only that part of index 0\n\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0];\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0];\n\n      if (index1) {\n        // If a key is specified, count only that part of index 1\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1];\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1];\n\n          if (index2) {\n            if (key2) {\n              // If a key is specified, count the quad if it exists\n              key2 in index2 && count++;\n            } else {\n              // Otherwise, count all quads\n              count += Object.keys(index2).length;\n            }\n          }\n        }\n      }\n    }\n\n    return count;\n  } // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n\n\n  _getGraphs(graph) {\n    if (!isString(graph)) {\n      return this._graphs;\n    }\n\n    return {\n      [graph]: this._graphs[graph]\n    };\n  }\n\n  _match(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n    const quads = [];\n\n    const graphs = this._getGraphs(graph);\n\n    const ids = this._ids;\n    let content, subjectId, predicateId, objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {\n      return quads;\n    }\n\n    for (const graphId in graphs) {\n      content = graphs[graphId]; // Only if the specified graph contains triples, there can be results\n\n      if (content) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);\n          } else {\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);\n          }\n        } else if (predicateId) {\n          // if only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);\n        } else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);\n        } else {\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);\n        }\n      }\n    }\n\n    return quads;\n  }\n\n  _getQuad(subjectId, predicateId, objectId, graphId) {\n    return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId));\n  }\n\n  _setQuad(subjectId, predicateId, objectId, graphId, quad) {\n    this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad);\n  }\n\n  _deleteQuad(subjectId, predicateId, objectId, graphId) {\n    this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId));\n  }\n\n  _createDataset(quads) {\n    return new this.constructor(quads);\n  }\n\n  _toId(subjectId, predicateId, objectId, graphId) {\n    return `${subjectId}:${predicateId}:${objectId}:${graphId}`;\n  }\n\n}\n\nmodule.exports = DatasetCore;","map":{"version":3,"sources":["/home/carlo/Desktop/Project/DeSBlog/node_modules/@rdfjs/dataset/DatasetCore.js"],"names":["isString","s","String","xsdString","termToId","term","id","termType","subject","predicate","object","graph","value","language","datatype","escapeQuotes","Error","escapedLiteral","replace","_","quoted","DatasetCore","constructor","quads","_size","_graphs","Object","create","_id","_ids","_entities","_quads","Map","quad","add","size","graphs","subjects","graphKey","subjectKey","predicateKey","keys","length","graphItem","predicates","objects","freeze","ids","entities","_addToIndex","_setQuad","delete","_removeFromIndex","_deleteQuad","has","subjectId","predicateId","objectId","_countInIndex","match","_createDataset","_match","Symbol","iterator","index0","key0","key1","key2","index1","index2","existed","key","_findInIndex","name0","name1","name2","callback","array","tmp","value0","value1","values","l","parts","_getQuad","push","count","_getGraphs","content","graphId","get","_toId","set","module","exports"],"mappings":"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","sourcesContent":["function isString (s) {\n  return typeof s === 'string' || s instanceof String\n}\n\nconst xsdString = 'http://www.w3.org/2001/XMLSchema#string'\n\nfunction termToId (term) {\n  if (typeof term === 'string') {\n    return term\n  }\n\n  if (!term) {\n    return ''\n  }\n\n  if (typeof term.id !== 'undefined' && term.termType !== 'Quad') {\n    return term.id\n  }\n\n  let subject, predicate, object, graph\n\n  // Term instantiated with another library\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value\n\n    case 'BlankNode':\n      return `_:${term.value}`\n\n    case 'Variable':\n      return `?${term.value}`\n\n    case 'DefaultGraph':\n      return ''\n\n    case 'Literal':\n      if (term.language) {\n        return `\"${term.value}\"@${term.language}`\n      }\n\n      return `\"${term.value}\"${term.datatype && term.datatype.value !== xsdString ? `^^${term.datatype.value}` : ''}`\n\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      subject = escapeQuotes(termToId(term.subject))\n      predicate = escapeQuotes(termToId(term.predicate))\n      object = escapeQuotes(termToId(term.object))\n      graph = term.graph.termType === 'DefaultGraph' ? '' : ` ${termToId(term.graph)}`\n\n      return `<<${subject} ${predicate} ${object}${graph}>>`\n\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`)\n  }\n}\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/\n\nfunction escapeQuotes (id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`)\n}\n\nclass DatasetCore {\n  constructor (quads) {\n    // The number of quads is initially zero\n    this._size = 0\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null)\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0\n    this._ids = Object.create(null)\n    this._ids['><'] = 0 // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null) // inverse of `_ids`\n\n    this._quads = new Map()\n\n    // Add quads if passed\n    if (quads) {\n      for (const quad of quads) {\n        this.add(quad)\n      }\n    }\n  }\n\n  get size () {\n    // Return the quad count if if was cached\n    let size = this._size\n\n    if (size !== null) {\n      return size\n    }\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0\n    const graphs = this._graphs\n    let subjects, subject\n\n    for (const graphKey in graphs) {\n      for (const subjectKey in (subjects = graphs[graphKey].subjects)) {\n        for (const predicateKey in (subject = subjects[subjectKey])) {\n          size += Object.keys(subject[predicateKey]).length\n        }\n      }\n    }\n\n    this._size = size\n\n    return this._size\n  }\n\n  add (quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject)\n    let predicate = termToId(quad.predicate)\n    let object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph]\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} }\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem)\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids\n    const entities = this._entities\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id)\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id)\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id)\n\n    this._addToIndex(graphItem.subjects, subject, predicate, object)\n    this._addToIndex(graphItem.predicates, predicate, object, subject)\n    this._addToIndex(graphItem.objects, object, subject, predicate)\n\n    this._setQuad(subject, predicate, object, graph, quad)\n\n    // The cached quad count is now invalid\n    this._size = null\n\n    return this\n  }\n\n  delete (quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject)\n    let predicate = termToId(quad.predicate)\n    let object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids\n    const graphs = this._graphs\n    let graphItem, subjects, predicates\n\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) ||\n      !(object = ids[object]) || !(graphItem = graphs[graph]) ||\n      !(subjects = graphItem.subjects[subject]) ||\n      !(predicates = subjects[predicate]) ||\n      !(object in predicates)\n    ) {\n      return this\n    }\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object)\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject)\n    this._removeFromIndex(graphItem.objects, object, subject, predicate)\n\n    if (this._size !== null) {\n      this._size--\n    }\n\n    this._deleteQuad(subject, predicate, object, graph)\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) { // eslint-disable-line no-unreachable-loop\n      return this\n    }\n\n    delete graphs[graph]\n\n    return this\n  }\n\n  has (quad) {\n    // Convert terms to internal string representation\n    const subject = termToId(quad.subject)\n    const predicate = termToId(quad.predicate)\n    const object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    const graphItem = this._graphs[graph]\n\n    if (!graphItem) {\n      return false\n    }\n\n    const ids = this._ids\n    let subjectId, predicateId, objectId\n\n    // Translate IRIs to internal index keys.\n    if (\n      (isString(subject) && !(subjectId = ids[subject])) ||\n      (isString(predicate) && !(predicateId = ids[predicate])) ||\n      (isString(object) && !(objectId = ids[object]))\n    ) {\n      return false\n    }\n\n    return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1\n  }\n\n  match (subject, predicate, object, graph) {\n    return this._createDataset(this._match(subject, predicate, object, graph))\n  }\n\n  [Symbol.iterator] () {\n    return this._match()[Symbol.iterator]()\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex (index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {})\n    const index2 = index1[key1] || (index1[key1] = {})\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2\n\n    if (!existed) {\n      index2[key2] = null\n    }\n\n    return !existed\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex (index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0]\n    const index2 = index1[key1]\n    delete index2[key2]\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) { // eslint-disable-line no-unreachable-loop\n      return\n    }\n\n    delete index1[key1]\n\n    for (const key in index1) { // eslint-disable-line no-unreachable-loop\n      return\n    }\n\n    delete index0[key0]\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n  _findInIndex (index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0]\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0]\n\n      if (index1) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1]\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1]\n\n          if (index2) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2)\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              const parts = {\n                [name0]: value0,\n                [name1]: value1,\n                [name2]: values[l]\n              }\n\n              const quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph)\n\n              if (array) {\n                array.push(quad)\n              } else if (callback(quad)) {\n                return true\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return array\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex (index0, key0, key1, key2) {\n    let count = 0\n    let tmp, index1, index2\n\n    // If a key is specified, count only that part of index 0\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0]\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0]\n\n      if (index1) {\n        // If a key is specified, count only that part of index 1\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1]\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1]\n\n          if (index2) {\n            if (key2) {\n              // If a key is specified, count the quad if it exists\n              (key2 in index2) && count++\n            } else {\n              // Otherwise, count all quads\n              count += Object.keys(index2).length\n            }\n          }\n        }\n      }\n    }\n\n    return count\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs (graph) {\n    if (!isString(graph)) {\n      return this._graphs\n    }\n\n    return {\n      [graph]: this._graphs[graph]\n    }\n  }\n\n  _match (subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject)\n    predicate = predicate && termToId(predicate)\n    object = object && termToId(object)\n    graph = graph && termToId(graph)\n\n    const quads = []\n    const graphs = this._getGraphs(graph)\n    const ids = this._ids\n    let content, subjectId, predicateId, objectId\n\n    // Translate IRIs to internal index keys.\n    if (\n      (isString(subject) && !(subjectId = ids[subject])) ||\n      (isString(predicate) && !(predicateId = ids[predicate])) ||\n      (isString(object) && !(objectId = ids[object]))\n    ) {\n      return quads\n    }\n\n    for (const graphId in graphs) {\n      content = graphs[graphId]\n\n      // Only if the specified graph contains triples, there can be results\n      if (content) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads)\n          } else {\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads)\n          }\n        } else if (predicateId) {\n          // if only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads)\n        } else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads)\n        } else {\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads)\n        }\n      }\n    }\n\n    return quads\n  }\n\n  _getQuad (subjectId, predicateId, objectId, graphId) {\n    return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId))\n  }\n\n  _setQuad (subjectId, predicateId, objectId, graphId, quad) {\n    this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad)\n  }\n\n  _deleteQuad (subjectId, predicateId, objectId, graphId) {\n    this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId))\n  }\n\n  _createDataset (quads) {\n    return new this.constructor(quads)\n  }\n\n  _toId (subjectId, predicateId, objectId, graphId) {\n    return `${subjectId}:${predicateId}:${objectId}:${graphId}`\n  }\n}\n\nmodule.exports = DatasetCore\n"]},"metadata":{},"sourceType":"script"}