{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionInfoManager = exports.clear = exports.getUnauthenticatedSession = void 0;\n\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\n\nfunction getUnauthenticatedSession() {\n  return {\n    isLoggedIn: false,\n    sessionId: uuid_1.v4(),\n    fetch\n  };\n}\n\nexports.getUnauthenticatedSession = getUnauthenticatedSession;\n\nasync function clear(sessionId, storage) {\n  const storedSessionCookieReference = await storage.get(\"tmp-resource-server-session-info\");\n  const reference = JSON.parse(storedSessionCookieReference !== null && storedSessionCookieReference !== void 0 ? storedSessionCookieReference : \"{}\");\n  const {\n    webId\n  } = reference;\n\n  if (webId !== undefined) {\n    const webIdAsUrl = new URL(webId);\n    const resourceServerIri = webIdAsUrl.origin;\n    await storage.clearResourceServerSessionInfo(resourceServerIri);\n  }\n\n  await Promise.all([storage.deleteAllUserData(sessionId, {\n    secure: false\n  }), storage.deleteAllUserData(sessionId, {\n    secure: true\n  }), storage.delete(\"clientKey\", {\n    secure: false\n  })]);\n  await oidc_client_ext_1.clearOidcPersistentStorage();\n}\n\nexports.clear = clear;\n\nclass SessionInfoManager {\n  constructor(storageUtility) {\n    this.storageUtility = storageUtility;\n  }\n\n  update(_sessionId, _options) {\n    throw new Error(\"Not Implemented\");\n  }\n\n  async get(sessionId) {\n    var _a;\n\n    const isLoggedIn = await this.storageUtility.getForUser(sessionId, \"isLoggedIn\", {\n      secure: true\n    });\n    const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\n      secure: true\n    });\n    const clientId = await this.storageUtility.getForUser(sessionId, \"clientId\", {\n      secure: false\n    });\n    const clientSecret = await this.storageUtility.getForUser(sessionId, \"clientSecret\", {\n      secure: false\n    });\n    const idToken = await this.storageUtility.getForUser(sessionId, \"idToken\", {\n      secure: false\n    });\n    const redirectUrl = await this.storageUtility.getForUser(sessionId, \"redirectUrl\", {\n      secure: false\n    });\n    const refreshToken = await this.storageUtility.getForUser(sessionId, \"refreshToken\", {\n      secure: true\n    });\n    const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\n      secure: false\n    });\n    const tokenType = (_a = await this.storageUtility.getForUser(sessionId, \"tokenType\", {\n      secure: false\n    })) !== null && _a !== void 0 ? _a : \"DPoP\";\n\n    if (!solid_client_authn_core_1.isSupportedTokenType(tokenType)) {\n      throw new Error(`Tokens of type [${tokenType}] are not supported.`);\n    }\n\n    if (clientId === undefined && idToken === undefined && isLoggedIn === undefined && webId === undefined && refreshToken === undefined) {\n      return undefined;\n    }\n\n    return {\n      sessionId,\n      webId,\n      isLoggedIn: isLoggedIn === \"true\",\n      redirectUrl,\n      idToken,\n      refreshToken,\n      issuer,\n      clientAppId: clientId,\n      clientAppSecret: clientSecret,\n      tokenType\n    };\n  }\n\n  async getAll() {\n    throw new Error(\"Not implemented\");\n  }\n\n  async clear(sessionId) {\n    return clear(sessionId, this.storageUtility);\n  }\n\n  async register(_sessionId) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async getRegisteredSessionIdAll() {\n    throw new Error(\"Not implemented\");\n  }\n\n  async clearAll() {\n    throw new Error(\"Not implemented\");\n  }\n\n}\n\nexports.SessionInfoManager = SessionInfoManager;","map":{"version":3,"sources":["../../src/sessionInfo/SessionInfoManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SessionInfoManager = exports.clear = exports.getUnauthenticatedSession = void 0;\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst uuid_1 = require(\"uuid\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nfunction getUnauthenticatedSession() {\n    return {\n        isLoggedIn: false,\n        sessionId: uuid_1.v4(),\n        fetch,\n    };\n}\nexports.getUnauthenticatedSession = getUnauthenticatedSession;\nasync function clear(sessionId, storage) {\n    const storedSessionCookieReference = await storage.get(\"tmp-resource-server-session-info\");\n    const reference = JSON.parse(storedSessionCookieReference !== null && storedSessionCookieReference !== void 0 ? storedSessionCookieReference : \"{}\");\n    const { webId } = reference;\n    if (webId !== undefined) {\n        const webIdAsUrl = new URL(webId);\n        const resourceServerIri = webIdAsUrl.origin;\n        await storage.clearResourceServerSessionInfo(resourceServerIri);\n    }\n    await Promise.all([\n        storage.deleteAllUserData(sessionId, { secure: false }),\n        storage.deleteAllUserData(sessionId, { secure: true }),\n        storage.delete(\"clientKey\", { secure: false }),\n    ]);\n    await oidc_client_ext_1.clearOidcPersistentStorage();\n}\nexports.clear = clear;\nclass SessionInfoManager {\n    constructor(storageUtility) {\n        this.storageUtility = storageUtility;\n    }\n    update(_sessionId, _options) {\n        throw new Error(\"Not Implemented\");\n    }\n    async get(sessionId) {\n        var _a;\n        const isLoggedIn = await this.storageUtility.getForUser(sessionId, \"isLoggedIn\", {\n            secure: true,\n        });\n        const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\n            secure: true,\n        });\n        const clientId = await this.storageUtility.getForUser(sessionId, \"clientId\", {\n            secure: false,\n        });\n        const clientSecret = await this.storageUtility.getForUser(sessionId, \"clientSecret\", {\n            secure: false,\n        });\n        const idToken = await this.storageUtility.getForUser(sessionId, \"idToken\", {\n            secure: false,\n        });\n        const redirectUrl = await this.storageUtility.getForUser(sessionId, \"redirectUrl\", {\n            secure: false,\n        });\n        const refreshToken = await this.storageUtility.getForUser(sessionId, \"refreshToken\", {\n            secure: true,\n        });\n        const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\n            secure: false,\n        });\n        const tokenType = (_a = (await this.storageUtility.getForUser(sessionId, \"tokenType\", {\n            secure: false,\n        }))) !== null && _a !== void 0 ? _a : \"DPoP\";\n        if (!solid_client_authn_core_1.isSupportedTokenType(tokenType)) {\n            throw new Error(`Tokens of type [${tokenType}] are not supported.`);\n        }\n        if (clientId === undefined &&\n            idToken === undefined &&\n            isLoggedIn === undefined &&\n            webId === undefined &&\n            refreshToken === undefined) {\n            return undefined;\n        }\n        return {\n            sessionId,\n            webId,\n            isLoggedIn: isLoggedIn === \"true\",\n            redirectUrl,\n            idToken,\n            refreshToken,\n            issuer,\n            clientAppId: clientId,\n            clientAppSecret: clientSecret,\n            tokenType,\n        };\n    }\n    async getAll() {\n        throw new Error(\"Not implemented\");\n    }\n    async clear(sessionId) {\n        return clear(sessionId, this.storageUtility);\n    }\n    async register(_sessionId) {\n        throw new Error(\"Not implemented\");\n    }\n    async getRegisteredSessionIdAll() {\n        throw new Error(\"Not implemented\");\n    }\n    async clearAll() {\n        throw new Error(\"Not implemented\");\n    }\n}\nexports.SessionInfoManager = SessionInfoManager;\n//# sourceMappingURL=SessionInfoManager.js.map"]},"metadata":{},"sourceType":"script"}