{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.saveSessionInfoToStorage = exports.loadOidcContextFromStorage = exports.getSessionIdFromOauthState = void 0;\n\nconst InruptError_1 = __importDefault(require(\"../errors/InruptError\"));\n\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\n  return storageUtility.getForUser(oauthState, \"sessionId\");\n}\n\nexports.getSessionIdFromOauthState = getSessionIdFromOauthState;\n\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\n  try {\n    const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([storageUtility.getForUser(sessionId, \"issuer\", {\n      errorIfNull: true\n    }), storageUtility.getForUser(sessionId, \"codeVerifier\"), storageUtility.getForUser(sessionId, \"redirectUrl\"), storageUtility.getForUser(sessionId, \"dpop\", {\n      errorIfNull: true\n    })]);\n    const issuerConfig = await configFetcher.fetchConfig(issuerIri);\n    return {\n      codeVerifier,\n      redirectUrl: storedRedirectIri,\n      issuerConfig,\n      dpop: dpop === \"true\"\n    };\n  } catch (e) {\n    throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`);\n  }\n}\n\nexports.loadOidcContextFromStorage = loadOidcContextFromStorage;\n\nasync function saveSessionInfoToStorage(storageUtility, sessionId, idToken, webId, isLoggedIn, refreshToken, secure) {\n  if (refreshToken !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      refreshToken\n    }, {\n      secure\n    });\n  }\n\n  if (idToken !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      idToken\n    }, {\n      secure\n    });\n  }\n\n  if (webId !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      webId\n    }, {\n      secure\n    });\n  }\n\n  if (isLoggedIn !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      isLoggedIn\n    }, {\n      secure\n    });\n  }\n}\n\nexports.saveSessionInfoToStorage = saveSessionInfoToStorage;\n\nclass StorageUtility {\n  constructor(secureStorage, insecureStorage) {\n    this.secureStorage = secureStorage;\n    this.insecureStorage = insecureStorage;\n    this.RESOURCE_SERVER_SESSION_INFORMATION_KEY = \"tmp-resource-server-session-info\";\n  }\n\n  getKey(userId) {\n    return `solidClientAuthenticationUser:${userId}`;\n  }\n\n  async getUserData(userId, secure) {\n    const stored = await (secure ? this.secureStorage : this.insecureStorage).get(this.getKey(userId));\n\n    if (stored === undefined) {\n      return {};\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch (err) {\n      throw new InruptError_1.default(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\n    }\n  }\n\n  async setUserData(userId, data, secure) {\n    await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\n  }\n\n  async get(key, options) {\n    const value = await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).get(key);\n\n    if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n      throw new InruptError_1.default(`[${key}] is not stored`);\n    }\n\n    return value;\n  }\n\n  async set(key, value, options) {\n    return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\n  }\n\n  async delete(key, options) {\n    return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\n  }\n\n  async getForUser(userId, key, options) {\n    const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    let value;\n\n    if (!userData || !userData[key]) {\n      value = undefined;\n    }\n\n    value = userData[key];\n\n    if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n      throw new InruptError_1.default(`Field [${key}] for user [${userId}] is not stored`);\n    }\n\n    return value || undefined;\n  }\n\n  async setForUser(userId, values, options) {\n    let userData;\n\n    try {\n      userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    } catch (_a) {\n      userData = {};\n    }\n\n    await this.setUserData(userId, { ...userData,\n      ...values\n    }, options === null || options === void 0 ? void 0 : options.secure);\n  }\n\n  async deleteForUser(userId, key, options) {\n    const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    delete userData[key];\n    await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\n  }\n\n  async deleteAllUserData(userId, options) {\n    await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\n  }\n\n  async storeResourceServerSessionInfo(webId, resourceServerIri, expiration) {\n    var _a;\n\n    const sessions = JSON.parse((_a = await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY)) !== null && _a !== void 0 ? _a : \"{}\");\n\n    if (sessions.webId !== webId) {\n      sessions.sessions = {};\n    }\n\n    sessions.webId = webId;\n    sessions.sessions[resourceServerIri] = {\n      expiration\n    };\n    await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\n  }\n\n  async clearResourceServerSessionInfo(resourceServerIri) {\n    var _a;\n\n    const sessions = JSON.parse((_a = await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY)) !== null && _a !== void 0 ? _a : \"{}\");\n\n    if (sessions.sessions !== undefined) {\n      delete sessions.sessions[resourceServerIri];\n\n      if (Object.keys(sessions.sessions).length === 0) {\n        await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, \"{}\");\n      } else {\n        await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\n      }\n    }\n  }\n\n}\n\nexports.default = StorageUtility;","map":{"version":3,"sources":["../../src/storage/StorageUtility.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.saveSessionInfoToStorage = exports.loadOidcContextFromStorage = exports.getSessionIdFromOauthState = void 0;\nconst InruptError_1 = __importDefault(require(\"../errors/InruptError\"));\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\n    return storageUtility.getForUser(oauthState, \"sessionId\");\n}\nexports.getSessionIdFromOauthState = getSessionIdFromOauthState;\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\n    try {\n        const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([\n            storageUtility.getForUser(sessionId, \"issuer\", {\n                errorIfNull: true,\n            }),\n            storageUtility.getForUser(sessionId, \"codeVerifier\"),\n            storageUtility.getForUser(sessionId, \"redirectUrl\"),\n            storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\n        ]);\n        const issuerConfig = await configFetcher.fetchConfig(issuerIri);\n        return {\n            codeVerifier,\n            redirectUrl: storedRedirectIri,\n            issuerConfig,\n            dpop: dpop === \"true\",\n        };\n    }\n    catch (e) {\n        throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`);\n    }\n}\nexports.loadOidcContextFromStorage = loadOidcContextFromStorage;\nasync function saveSessionInfoToStorage(storageUtility, sessionId, idToken, webId, isLoggedIn, refreshToken, secure) {\n    if (refreshToken !== undefined) {\n        await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\n    }\n    if (idToken !== undefined) {\n        await storageUtility.setForUser(sessionId, { idToken }, { secure });\n    }\n    if (webId !== undefined) {\n        await storageUtility.setForUser(sessionId, { webId }, { secure });\n    }\n    if (isLoggedIn !== undefined) {\n        await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\n    }\n}\nexports.saveSessionInfoToStorage = saveSessionInfoToStorage;\nclass StorageUtility {\n    constructor(secureStorage, insecureStorage) {\n        this.secureStorage = secureStorage;\n        this.insecureStorage = insecureStorage;\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY = \"tmp-resource-server-session-info\";\n    }\n    getKey(userId) {\n        return `solidClientAuthenticationUser:${userId}`;\n    }\n    async getUserData(userId, secure) {\n        const stored = await (secure\n            ? this.secureStorage\n            : this.insecureStorage).get(this.getKey(userId));\n        if (stored === undefined) {\n            return {};\n        }\n        try {\n            return JSON.parse(stored);\n        }\n        catch (err) {\n            throw new InruptError_1.default(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\n        }\n    }\n    async setUserData(userId, data, secure) {\n        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\n    }\n    async get(key, options) {\n        const value = await ((options === null || options === void 0 ? void 0 : options.secure)\n            ? this.secureStorage\n            : this.insecureStorage).get(key);\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n            throw new InruptError_1.default(`[${key}] is not stored`);\n        }\n        return value;\n    }\n    async set(key, value, options) {\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\n    }\n    async delete(key, options) {\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\n    }\n    async getForUser(userId, key, options) {\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n        let value;\n        if (!userData || !userData[key]) {\n            value = undefined;\n        }\n        value = userData[key];\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n            throw new InruptError_1.default(`Field [${key}] for user [${userId}] is not stored`);\n        }\n        return value || undefined;\n    }\n    async setForUser(userId, values, options) {\n        let userData;\n        try {\n            userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n        }\n        catch (_a) {\n            userData = {};\n        }\n        await this.setUserData(userId, { ...userData, ...values }, options === null || options === void 0 ? void 0 : options.secure);\n    }\n    async deleteForUser(userId, key, options) {\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n        delete userData[key];\n        await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\n    }\n    async deleteAllUserData(userId, options) {\n        await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\n    }\n    async storeResourceServerSessionInfo(webId, resourceServerIri, expiration) {\n        var _a;\n        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : \"{}\");\n        if (sessions.webId !== webId) {\n            sessions.sessions = {};\n        }\n        sessions.webId = webId;\n        sessions.sessions[resourceServerIri] = {\n            expiration,\n        };\n        await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\n    }\n    async clearResourceServerSessionInfo(resourceServerIri) {\n        var _a;\n        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : \"{}\");\n        if (sessions.sessions !== undefined) {\n            delete sessions.sessions[resourceServerIri];\n            if (Object.keys(sessions.sessions).length === 0) {\n                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, \"{}\");\n            }\n            else {\n                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\n            }\n        }\n    }\n}\nexports.default = StorageUtility;\n//# sourceMappingURL=StorageUtility.js.map"]},"metadata":{},"sourceType":"script"}