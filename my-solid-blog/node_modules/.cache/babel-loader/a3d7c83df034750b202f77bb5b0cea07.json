{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;\n\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\n\nconst fetchFactory_1 = require(\"../../../authenticatedFetch/fetchFactory\");\n\nconst constant_1 = require(\"../../../constant\");\n\nexports.DEFAULT_LIFESPAN = 30 * 60 * 1000;\n\nasync function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {\n  const webIdAsUrl = new URL(webId);\n  const resourceServerIri = webIdAsUrl.origin;\n  await authenticatedFetch(webId);\n\n  try {\n    const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);\n\n    if (resourceServerResponse.status === 200) {\n      await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);\n      return;\n    }\n\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n  } catch (_e) {\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n  }\n}\n\nclass AuthCodeRedirectHandler {\n  constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar) {\n    this.storageUtility = storageUtility;\n    this.sessionInfoManager = sessionInfoManager;\n    this.issuerConfigFetcher = issuerConfigFetcher;\n    this.clientRegistrar = clientRegistrar;\n  }\n\n  async canHandle(redirectUrl) {\n    try {\n      const myUrl = new URL(redirectUrl);\n      return myUrl.searchParams.get(\"code\") !== null && myUrl.searchParams.get(\"state\") !== null;\n    } catch (e) {\n      throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);\n    }\n  }\n\n  async handle(redirectUrl) {\n    if (!(await this.canHandle(redirectUrl))) {\n      throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);\n    }\n\n    const url = new URL(redirectUrl);\n    const oauthState = url.searchParams.get(\"state\");\n    const storedSessionId = await this.storageUtility.getForUser(oauthState, \"sessionId\", {\n      errorIfNull: true\n    });\n    const isDpop = (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) === \"true\";\n    const issuer = await this.storageUtility.getForUser(storedSessionId, \"issuer\", {\n      errorIfNull: true\n    });\n    window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, storedSessionId);\n    const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);\n    const client = await this.clientRegistrar.getClient({\n      sessionId: storedSessionId\n    }, issuerConfig);\n    let tokens;\n    let authFetch;\n    const referenceTime = Date.now();\n\n    if (isDpop) {\n      const codeVerifier = await this.storageUtility.getForUser(storedSessionId, \"codeVerifier\", {\n        errorIfNull: true\n      });\n      const storedRedirectIri = await this.storageUtility.getForUser(storedSessionId, \"redirectUrl\", {\n        errorIfNull: true\n      });\n      tokens = await oidc_client_ext_1.getDpopToken(issuerConfig, client, {\n        grantType: \"authorization_code\",\n        code: url.searchParams.get(\"code\"),\n        codeVerifier,\n        redirectUrl: storedRedirectIri\n      });\n      authFetch = await fetchFactory_1.buildDpopFetch(tokens.accessToken, tokens.dpopKey);\n    } else {\n      tokens = await oidc_client_ext_1.getBearerToken(url.toString());\n      authFetch = fetchFactory_1.buildBearerFetch(tokens.accessToken);\n    }\n\n    await this.storageUtility.setForUser(storedSessionId, {\n      refreshToken: \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\n      webId: tokens.webId,\n      isLoggedIn: \"true\"\n    }, {\n      secure: true\n    });\n    url.searchParams.delete(\"code\");\n    await this.storageUtility.setForUser(storedSessionId, {\n      redirectUrl: url.toString(),\n      idToken: tokens.idToken\n    }, {\n      secure: false\n    });\n    const essWorkaroundDisabled = window.localStorage.getItem(\"tmp-resource-server-session-enabled\") === \"false\";\n\n    if (!essWorkaroundDisabled) {\n      await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);\n    }\n\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n\n    if (!sessionInfo) {\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n    }\n\n    return Object.assign(sessionInfo, {\n      fetch: authFetch,\n      expirationDate: typeof tokens.expiresIn === \"number\" ? referenceTime + tokens.expiresIn * 1000 : null\n    });\n  }\n\n}\n\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;","map":{"version":3,"sources":["../../../../src/login/oidc/redirectHandler/AuthCodeRedirectHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nconst fetchFactory_1 = require(\"../../../authenticatedFetch/fetchFactory\");\nconst constant_1 = require(\"../../../constant\");\nexports.DEFAULT_LIFESPAN = 30 * 60 * 1000;\nasync function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {\n    const webIdAsUrl = new URL(webId);\n    const resourceServerIri = webIdAsUrl.origin;\n    await authenticatedFetch(webId);\n    try {\n        const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);\n        if (resourceServerResponse.status === 200) {\n            await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);\n            return;\n        }\n        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n    }\n    catch (_e) {\n        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n    }\n}\nclass AuthCodeRedirectHandler {\n    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar) {\n        this.storageUtility = storageUtility;\n        this.sessionInfoManager = sessionInfoManager;\n        this.issuerConfigFetcher = issuerConfigFetcher;\n        this.clientRegistrar = clientRegistrar;\n    }\n    async canHandle(redirectUrl) {\n        try {\n            const myUrl = new URL(redirectUrl);\n            return (myUrl.searchParams.get(\"code\") !== null &&\n                myUrl.searchParams.get(\"state\") !== null);\n        }\n        catch (e) {\n            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);\n        }\n    }\n    async handle(redirectUrl) {\n        if (!(await this.canHandle(redirectUrl))) {\n            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);\n        }\n        const url = new URL(redirectUrl);\n        const oauthState = url.searchParams.get(\"state\");\n        const storedSessionId = (await this.storageUtility.getForUser(oauthState, \"sessionId\", {\n            errorIfNull: true,\n        }));\n        const isDpop = (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\n            \"true\";\n        const issuer = (await this.storageUtility.getForUser(storedSessionId, \"issuer\", { errorIfNull: true }));\n        window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, storedSessionId);\n        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);\n        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);\n        let tokens;\n        let authFetch;\n        const referenceTime = Date.now();\n        if (isDpop) {\n            const codeVerifier = (await this.storageUtility.getForUser(storedSessionId, \"codeVerifier\", { errorIfNull: true }));\n            const storedRedirectIri = (await this.storageUtility.getForUser(storedSessionId, \"redirectUrl\", { errorIfNull: true }));\n            tokens = await oidc_client_ext_1.getDpopToken(issuerConfig, client, {\n                grantType: \"authorization_code\",\n                code: url.searchParams.get(\"code\"),\n                codeVerifier,\n                redirectUrl: storedRedirectIri,\n            });\n            authFetch = await fetchFactory_1.buildDpopFetch(tokens.accessToken, tokens.dpopKey);\n        }\n        else {\n            tokens = await oidc_client_ext_1.getBearerToken(url.toString());\n            authFetch = fetchFactory_1.buildBearerFetch(tokens.accessToken);\n        }\n        await this.storageUtility.setForUser(storedSessionId, {\n            refreshToken: \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\n            webId: tokens.webId,\n            isLoggedIn: \"true\",\n        }, { secure: true });\n        url.searchParams.delete(\"code\");\n        await this.storageUtility.setForUser(storedSessionId, {\n            redirectUrl: url.toString(),\n            idToken: tokens.idToken,\n        }, {\n            secure: false,\n        });\n        const essWorkaroundDisabled = window.localStorage.getItem(\"tmp-resource-server-session-enabled\") ===\n            \"false\";\n        if (!essWorkaroundDisabled) {\n            await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);\n        }\n        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n        if (!sessionInfo) {\n            throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n        }\n        return Object.assign(sessionInfo, {\n            fetch: authFetch,\n            expirationDate: typeof tokens.expiresIn === \"number\"\n                ? referenceTime + tokens.expiresIn * 1000\n                : null,\n        });\n    }\n}\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;\n//# sourceMappingURL=AuthCodeRedirectHandler.js.map"]},"metadata":{},"sourceType":"script"}