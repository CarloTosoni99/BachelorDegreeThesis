{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nclass JOSEError extends Error {\n  constructor(message) {\n    super(message);\n    this.code = JOSEError.code;\n    this.name = this.constructor.name;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n}\n\nJOSEError.code = 'ERR_JOSE_GENERIC';\n\nclass JWTClaimValidationFailed extends JOSEError {\n  constructor(message, claim = 'unspecified', reason = 'unspecified') {\n    super(message);\n    this.code = JWTClaimValidationFailed.code;\n    this.claim = claim;\n    this.reason = reason;\n  }\n\n}\n\nJWTClaimValidationFailed.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n\nclass JOSEAlgNotAllowed extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JOSEAlgNotAllowed.code;\n  }\n\n}\n\nJOSEAlgNotAllowed.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n\nclass JOSENotSupported extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JOSENotSupported.code;\n  }\n\n}\n\nJOSENotSupported.code = 'ERR_JOSE_NOT_SUPPORTED';\n\nclass JWEDecryptionFailed extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWEDecryptionFailed.code;\n    this.message = 'decryption operation failed';\n  }\n\n}\n\nJWEDecryptionFailed.code = 'ERR_JWE_DECRYPTION_FAILED';\n\nclass JWEInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWEInvalid.code;\n  }\n\n}\n\nJWEInvalid.code = 'ERR_JWE_INVALID';\n\nclass JWSInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWSInvalid.code;\n  }\n\n}\n\nJWSInvalid.code = 'ERR_JWS_INVALID';\n\nclass JWTInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWTInvalid.code;\n  }\n\n}\n\nJWTInvalid.code = 'ERR_JWT_INVALID';\n\nclass JWKInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWKInvalid.code;\n  }\n\n}\n\nJWKInvalid.code = 'ERR_JWK_INVALID';\n\nclass JWKSInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWKSInvalid.code;\n  }\n\n}\n\nJWKSInvalid.code = 'ERR_JWKS_INVALID';\n\nclass JWKSNoMatchingKey extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWKSNoMatchingKey.code;\n    this.message = 'no applicable key found in the JSON Web Key Set';\n  }\n\n}\n\nJWKSNoMatchingKey.code = 'ERR_JWKS_NO_MATCHING_KEY';\n\nclass JWKSMultipleMatchingKeys extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWKSMultipleMatchingKeys.code;\n    this.message = 'multiple matching keys found in the JSON Web Key Set';\n  }\n\n}\n\nJWKSMultipleMatchingKeys.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n\nclass JWSSignatureVerificationFailed extends JOSEError {\n  constructor() {\n    super(...arguments);\n    this.code = JWSSignatureVerificationFailed.code;\n    this.message = 'signature verification failed';\n  }\n\n}\n\nJWSSignatureVerificationFailed.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n\nclass JWTExpired extends JWTClaimValidationFailed {\n  constructor() {\n    super(...arguments);\n    this.code = JWTExpired.code;\n  }\n\n}\n\nJWTExpired.code = 'ERR_JWT_EXPIRED';\n\nconst isDisjoint = (...headers) => {\n  const sources = headers.filter(Boolean);\n\n  if (sources.length === 0 || sources.length === 1) {\n    return true;\n  }\n\n  let acc;\n\n  for (const header of sources) {\n    const parameters = Object.keys(header);\n\n    if (!acc || acc.size === 0) {\n      acc = new Set(parameters);\n      continue;\n    }\n\n    for (const parameter of parameters) {\n      if (acc.has(parameter)) {\n        return false;\n      }\n\n      acc.add(parameter);\n    }\n  }\n\n  return true;\n};\n\nfunction isObjectLike(value) {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction isObject(input) {\n  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(input) === null) {\n    return true;\n  }\n\n  let proto = input;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(input) === proto;\n}\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\n\nfunction concat(...buffers) {\n  const size = buffers.reduce((acc, {\n    length\n  }) => acc + length, 0);\n  const buf = new Uint8Array(size);\n  let i = 0;\n  buffers.forEach(buffer => {\n    buf.set(buffer, i);\n    i += buffer.length;\n  });\n  return buf;\n}\n\nfunction p2s(alg, p2sInput) {\n  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\n\nfunction writeUInt32BE(buf, value, offset) {\n  if (value < 0 || value >= MAX_INT32) {\n    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n  }\n\n  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\n\nfunction uint64be(value) {\n  const high = Math.floor(value / MAX_INT32);\n  const low = value % MAX_INT32;\n  const buf = new Uint8Array(8);\n  writeUInt32BE(buf, high, 0);\n  writeUInt32BE(buf, low, 4);\n  return buf;\n}\n\nfunction uint32be(value) {\n  const buf = new Uint8Array(4);\n  writeUInt32BE(buf, value);\n  return buf;\n}\n\nfunction lengthAndInput(input) {\n  return concat(uint32be(input.length), input);\n}\n\nasync function concatKdf(digest, secret, bits, value) {\n  const iterations = Math.ceil((bits >> 3) / 32);\n  let res;\n\n  for (let iter = 1; iter <= iterations; iter++) {\n    const buf = new Uint8Array(4 + secret.length + value.length);\n    buf.set(uint32be(iter));\n    buf.set(secret, 4);\n    buf.set(value, 4 + secret.length);\n\n    if (!res) {\n      res = await digest('sha256', buf);\n    } else {\n      res = concat(res, await digest('sha256', buf));\n    }\n  }\n\n  res = res.slice(0, bits >> 3);\n  return res;\n}\n\nfunction getGlobal() {\n  if (typeof globalThis !== 'undefined') return globalThis;\n  if (typeof self !== 'undefined') return self;\n  if (typeof window !== 'undefined') return window;\n  throw new Error('unable to locate global object');\n}\n\nvar globalThis$1 = getGlobal();\n\nconst encode$1 = input => {\n  let unencoded = input;\n\n  if (typeof unencoded === 'string') {\n    unencoded = encoder.encode(unencoded);\n  }\n\n  const CHUNK_SIZE = 0x8000;\n  const arr = [];\n\n  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n  }\n\n  const base64string = globalThis$1.btoa(arr.join(''));\n  return base64string.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\nconst decode$1 = input => {\n  let encoded = input;\n\n  if (encoded instanceof Uint8Array) {\n    encoded = decoder.decode(encoded);\n  }\n\n  encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n\n  try {\n    return new Uint8Array(globalThis$1.atob(encoded).split('').map(c => c.charCodeAt(0)));\n  } catch (_a) {\n    throw new TypeError('The input to be decoded is not correctly encoded.');\n  }\n};\n\nconst bitLengths$1 = new Map([['A128CBC-HS256', 128], ['A128GCM', 96], ['A128GCMKW', 96], ['A192CBC-HS384', 128], ['A192GCM', 96], ['A192GCMKW', 96], ['A256CBC-HS512', 128], ['A256GCM', 96], ['A256GCMKW', 96]]);\n\nconst factory$1 = random => alg => {\n  const bitLength = bitLengths$1.get(alg);\n\n  if (!bitLength) {\n    throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n  }\n\n  return random(new Uint8Array(bitLength >> 3));\n};\n\nconst checkIvLength = (enc, iv) => {\n  if (iv.length << 3 !== bitLengths$1.get(enc)) {\n    throw new JWEInvalid('Invalid Initialization Vector length');\n  }\n};\n\nconst checkCekLength = (enc, cek) => {\n  let expected;\n\n  switch (enc) {\n    case 'A128CBC-HS256':\n    case 'A192CBC-HS384':\n    case 'A256CBC-HS512':\n      expected = parseInt(enc.substr(-3), 10);\n\n      if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(`${enc} content encryption requires Uint8Array as key input`);\n      }\n\n      break;\n\n    case 'A128GCM':\n    case 'A192GCM':\n    case 'A256GCM':\n      expected = parseInt(enc.substr(1, 3), 10);\n      break;\n\n    default:\n      throw new JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);\n  }\n\n  if (cek instanceof Uint8Array) {\n    if (cek.length << 3 !== expected) {\n      throw new JWEInvalid('Invalid Content Encryption Key length');\n    }\n\n    return;\n  }\n\n  if (cek.algorithm !== undefined) {\n    const {\n      length\n    } = cek.algorithm;\n\n    if (length !== expected) {\n      throw new JWEInvalid('Invalid Content Encryption Key length');\n    }\n\n    return;\n  }\n\n  throw new TypeError('Invalid Content Encryption Key type');\n};\n\nconst timingSafeEqual = (a, b) => {\n  if (!(a instanceof Uint8Array)) {\n    throw new TypeError('First argument must be a buffer');\n  }\n\n  if (!(b instanceof Uint8Array)) {\n    throw new TypeError('Second argument must be a buffer');\n  }\n\n  if (a.length !== b.length) {\n    throw new TypeError('Input buffers must have the same length');\n  }\n\n  const len = a.length;\n  let out = 0;\n  let i = -1;\n\n  while (++i < len) {\n    out |= a[i] ^ b[i];\n  }\n\n  return out === 0;\n};\n\nvar crypto = globalThis$1.crypto;\n\nfunction isCryptoKey(key) {\n  if (typeof globalThis$1.CryptoKey === 'undefined') {\n    return false;\n  }\n\n  return key != null && key instanceof globalThis$1.CryptoKey;\n}\n\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n  const keySize = parseInt(enc.substr(1, 3), 10);\n  const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n  const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n    hash: {\n      name: `SHA-${keySize << 1}`\n    },\n    name: 'HMAC'\n  }, false, ['sign']);\n  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n  const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n  let macCheckPassed;\n\n  try {\n    macCheckPassed = timingSafeEqual(tag, expectedTag);\n  } catch (_a) {}\n\n  if (!macCheckPassed) {\n    throw new JWEDecryptionFailed();\n  }\n\n  let plaintext;\n\n  try {\n    plaintext = new Uint8Array(await crypto.subtle.decrypt({\n      iv,\n      name: 'AES-CBC'\n    }, encKey, ciphertext));\n  } catch (_b) {}\n\n  if (!plaintext) {\n    throw new JWEDecryptionFailed();\n  }\n\n  return plaintext;\n}\n\nasync function gcmDecrypt(cek, ciphertext, iv, tag, aad) {\n  const encKey = cek instanceof Uint8Array ? await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']) : cek;\n\n  try {\n    return new Uint8Array(await crypto.subtle.decrypt({\n      additionalData: aad,\n      iv,\n      name: 'AES-GCM',\n      tagLength: 128\n    }, encKey, concat(ciphertext, tag)));\n  } catch (err) {\n    throw new JWEDecryptionFailed();\n  }\n}\n\nconst decrypt$2 = async (enc, cek, ciphertext, iv, tag, aad) => {\n  if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n    throw new TypeError('invalid key input');\n  }\n\n  checkCekLength(enc, cek);\n  checkIvLength(enc, iv);\n\n  if (enc.substr(4, 3) === 'CBC') {\n    return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n  }\n\n  return gcmDecrypt(cek, ciphertext, iv, tag, aad);\n};\n\nconst inflate = async () => {\n  throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation, e.g. using the \"pako\" module.');\n};\n\nconst deflate = async () => {\n  throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime.');\n};\n\nconst bogusWebCrypto = [{\n  hash: {\n    name: 'SHA-256'\n  },\n  name: 'HMAC'\n}, true, ['sign']];\n\nfunction checkKeySize(key, alg) {\n  if (key.algorithm.length !== parseInt(alg.substr(1, 3), 10)) {\n    throw new TypeError(`invalid key size for alg: ${alg}`);\n  }\n}\n\nfunction getCryptoKey$2(key, usage) {\n  if (isCryptoKey(key)) {\n    return key;\n  }\n\n  if (key instanceof Uint8Array) {\n    return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n  }\n\n  throw new TypeError('invalid key input');\n}\n\nconst wrap$1 = async (alg, key, cek) => {\n  const cryptoKey = await getCryptoKey$2(key, 'wrapKey');\n  checkKeySize(cryptoKey, alg);\n  const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n  return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\n\nconst unwrap$1 = async (alg, key, encryptedKey) => {\n  const cryptoKey = await getCryptoKey$2(key, 'unwrapKey');\n  checkKeySize(cryptoKey, alg);\n  const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);\n  return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n};\n\nconst digest = async (algorithm, data) => {\n  const subtleDigest = `SHA-${algorithm.substr(-3)}`;\n  return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));\n};\n\nconst deriveKey = async (publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) => {\n  if (!isCryptoKey(publicKey)) {\n    throw new TypeError('invalid key input');\n  }\n\n  if (!isCryptoKey(privateKey)) {\n    throw new TypeError('invalid key input');\n  }\n\n  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n\n  if (!privateKey.usages.includes('deriveBits')) {\n    throw new TypeError('ECDH-ES private key \"usages\" must include \"deriveBits\"');\n  }\n\n  const sharedSecret = new Uint8Array(await crypto.subtle.deriveBits({\n    name: 'ECDH',\n    public: publicKey\n  }, privateKey, Math.ceil(parseInt(privateKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3));\n  return concatKdf(digest, sharedSecret, keyLength, value);\n};\n\nconst generateEpk = async key => {\n  if (!isCryptoKey(key)) {\n    throw new TypeError('invalid key input');\n  }\n\n  return (await crypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: key.algorithm.namedCurve\n  }, true, ['deriveBits'])).privateKey;\n};\n\nconst ecdhAllowed = key => {\n  if (!isCryptoKey(key)) {\n    throw new TypeError('invalid key input');\n  }\n\n  return ['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve);\n};\n\nconst random$1 = crypto.getRandomValues.bind(crypto);\n\nfunction checkP2s(p2s) {\n  if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n    throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n  }\n}\n\nfunction getCryptoKey$1(key) {\n  if (key instanceof Uint8Array) {\n    return crypto.subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);\n  }\n\n  if (isCryptoKey(key)) {\n    return key;\n  }\n\n  throw new TypeError('invalid key input');\n}\n\nconst encrypt$2 = async (alg, key, cek, p2c = Math.floor(Math.random() * 2049) + 2048, p2s$1 = random$1(new Uint8Array(16))) => {\n  checkP2s(p2s$1);\n  const salt = p2s(alg, p2s$1);\n  const keylen = parseInt(alg.substr(13, 3), 10);\n  const subtleAlg = {\n    hash: {\n      name: `SHA-${alg.substr(8, 3)}`\n    },\n    iterations: p2c,\n    name: 'PBKDF2',\n    salt\n  };\n  const wrapAlg = {\n    length: keylen,\n    name: 'AES-KW'\n  };\n  const cryptoKey = await getCryptoKey$1(key);\n  let derived;\n\n  if (cryptoKey.usages.includes('deriveBits')) {\n    derived = new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n  } else if (cryptoKey.usages.includes('deriveKey')) {\n    derived = await crypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey']);\n  } else {\n    throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n  }\n\n  const encryptedKey = await wrap$1(alg.substr(-6), derived, cek);\n  return {\n    encryptedKey,\n    p2c,\n    p2s: encode$1(p2s$1)\n  };\n};\n\nconst decrypt$1 = async (alg, key, encryptedKey, p2c, p2s$1) => {\n  checkP2s(p2s$1);\n  const salt = p2s(alg, p2s$1);\n  const keylen = parseInt(alg.substr(13, 3), 10);\n  const subtleAlg = {\n    hash: {\n      name: `SHA-${alg.substr(8, 3)}`\n    },\n    iterations: p2c,\n    name: 'PBKDF2',\n    salt\n  };\n  const wrapAlg = {\n    length: keylen,\n    name: 'AES-KW'\n  };\n  const cryptoKey = await getCryptoKey$1(key);\n  let derived;\n\n  if (cryptoKey.usages.includes('deriveBits')) {\n    derived = new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n  } else if (cryptoKey.usages.includes('deriveKey')) {\n    derived = await crypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['unwrapKey']);\n  } else {\n    throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n  }\n\n  return unwrap$1(alg.substr(-6), derived, encryptedKey);\n};\n\nfunction subtleRsaEs(alg) {\n  switch (alg) {\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      return 'RSA-OAEP';\n\n    default:\n      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n  }\n}\n\nvar checkKeyLength = (alg, key) => {\n  if (alg.startsWith('HS')) {\n    const bitlen = parseInt(alg.substr(-3), 10);\n    const {\n      length\n    } = key.algorithm;\n\n    if (typeof length !== 'number' || length < bitlen) {\n      throw new TypeError(`${alg} requires symmetric keys to be ${bitlen} bits or larger`);\n    }\n  }\n\n  if (alg.startsWith('RS') || alg.startsWith('PS')) {\n    const {\n      modulusLength\n    } = key.algorithm;\n\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n    }\n  }\n};\n\nconst encrypt$1 = async (alg, key, cek) => {\n  if (!isCryptoKey(key)) {\n    throw new TypeError('invalid key input');\n  }\n\n  checkKeyLength(alg, key);\n\n  if (key.usages.includes('encrypt')) {\n    return new Uint8Array(await crypto.subtle.encrypt(subtleRsaEs(alg), key, cek));\n  }\n\n  if (key.usages.includes('wrapKey')) {\n    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, key, subtleRsaEs(alg)));\n  }\n\n  throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n};\n\nconst decrypt = async (alg, key, encryptedKey) => {\n  if (!isCryptoKey(key)) {\n    throw new TypeError('invalid key input');\n  }\n\n  checkKeyLength(alg, key);\n\n  if (key.usages.includes('decrypt')) {\n    return new Uint8Array(await crypto.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));\n  }\n\n  if (key.usages.includes('unwrapKey')) {\n    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, key, subtleRsaEs(alg), ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n  }\n\n  throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n};\n\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n  const keySize = parseInt(enc.substr(1, 3), 10);\n  const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n  const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n    hash: {\n      name: `SHA-${keySize << 1}`\n    },\n    name: 'HMAC'\n  }, false, ['sign']);\n  const ciphertext = new Uint8Array(await crypto.subtle.encrypt({\n    iv,\n    name: 'AES-CBC'\n  }, encKey, plaintext));\n  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n  const tag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n  return {\n    ciphertext,\n    tag\n  };\n}\n\nasync function gcmEncrypt(plaintext, cek, iv, aad) {\n  const encKey = cek instanceof Uint8Array ? await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']) : cek;\n  const encrypted = new Uint8Array(await crypto.subtle.encrypt({\n    additionalData: aad,\n    iv,\n    name: 'AES-GCM',\n    tagLength: 128\n  }, encKey, plaintext));\n  const tag = encrypted.slice(-16);\n  const ciphertext = encrypted.slice(0, -16);\n  return {\n    ciphertext,\n    tag\n  };\n}\n\nconst encrypt = async (enc, plaintext, cek, iv, aad) => {\n  if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n    throw new TypeError('invalid key input');\n  }\n\n  checkCekLength(enc, cek);\n  checkIvLength(enc, iv);\n\n  if (enc.substr(4, 3) === 'CBC') {\n    return cbcEncrypt(enc, plaintext, cek, iv, aad);\n  }\n\n  return gcmEncrypt(plaintext, cek, iv, aad);\n};\n\nconst generateIv$1 = factory$1(random$1);\n\nconst wrap = async (alg, key, cek, iv) => {\n  const jweAlgorithm = alg.substr(0, 7);\n  iv || (iv = generateIv$1(jweAlgorithm));\n  const {\n    ciphertext: encryptedKey,\n    tag\n  } = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n  return {\n    encryptedKey,\n    iv: encode$1(iv),\n    tag: encode$1(tag)\n  };\n};\n\nconst unwrap = async (alg, key, encryptedKey, iv, tag) => {\n  const jweAlgorithm = alg.substr(0, 7);\n  return decrypt$2(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n};\n\nconst bitLengths = new Map([['A128CBC-HS256', 256], ['A128GCM', 128], ['A192CBC-HS384', 384], ['A192GCM', 192], ['A256CBC-HS512', 512], ['A256GCM', 256]]);\n\nconst factory = random => alg => {\n  const bitLength = bitLengths.get(alg);\n\n  if (!bitLength) {\n    throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n  }\n\n  return random(new Uint8Array(bitLength >> 3));\n};\n\nfunction subtleMapping(jwk) {\n  let algorithm;\n  let keyUsages;\n\n  switch (jwk.kty) {\n    case 'oct':\n      {\n        switch (jwk.alg) {\n          case 'HS256':\n          case 'HS384':\n          case 'HS512':\n            algorithm = {\n              name: 'HMAC',\n              hash: {\n                name: `SHA-${jwk.alg.substr(-3)}`\n              }\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n\n          case 'A128CBC-HS256':\n          case 'A192CBC-HS384':\n          case 'A256CBC-HS512':\n            throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);\n\n          case 'A128GCM':\n          case 'A192GCM':\n          case 'A256GCM':\n          case 'A128GCMKW':\n          case 'A192GCMKW':\n          case 'A256GCMKW':\n            algorithm = {\n              name: 'AES-GCM'\n            };\n            keyUsages = ['encrypt', 'decrypt'];\n            break;\n\n          case 'A128KW':\n          case 'A192KW':\n          case 'A256KW':\n            algorithm = {\n              name: 'AES-KW'\n            };\n            keyUsages = ['wrapKey', 'unwrapKey'];\n            break;\n\n          case 'PBES2-HS256+A128KW':\n          case 'PBES2-HS384+A192KW':\n          case 'PBES2-HS512+A256KW':\n            algorithm = {\n              name: 'PBKDF2'\n            };\n            keyUsages = ['deriveBits'];\n            break;\n\n          default:\n            throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n        }\n\n        break;\n      }\n\n    case 'RSA':\n      {\n        switch (jwk.alg) {\n          case 'PS256':\n          case 'PS384':\n          case 'PS512':\n            algorithm = {\n              name: 'RSA-PSS',\n              hash: {\n                name: `SHA-${jwk.alg.substr(-3)}`\n              }\n            };\n            keyUsages = jwk.d ? ['sign'] : ['verify'];\n            break;\n\n          case 'RS256':\n          case 'RS384':\n          case 'RS512':\n            algorithm = {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: {\n                name: `SHA-${jwk.alg.substr(-3)}`\n              }\n            };\n            keyUsages = jwk.d ? ['sign'] : ['verify'];\n            break;\n\n          case 'RSA-OAEP':\n          case 'RSA-OAEP-256':\n          case 'RSA-OAEP-384':\n          case 'RSA-OAEP-512':\n            algorithm = {\n              name: 'RSA-OAEP',\n              hash: {\n                name: `SHA-${parseInt(jwk.alg.substr(-3), 10) || 1}`\n              }\n            };\n            keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n            break;\n\n          default:\n            throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n        }\n\n        break;\n      }\n\n    case 'EC':\n      {\n        switch (jwk.alg) {\n          case 'ES256':\n          case 'ES384':\n          case 'ES512':\n            algorithm = {\n              name: 'ECDSA',\n              namedCurve: jwk.crv\n            };\n            keyUsages = jwk.d ? ['sign'] : ['verify'];\n            break;\n\n          case 'ECDH-ES':\n          case 'ECDH-ES+A128KW':\n          case 'ECDH-ES+A192KW':\n          case 'ECDH-ES+A256KW':\n            algorithm = {\n              name: 'ECDH',\n              namedCurve: jwk.crv\n            };\n            keyUsages = jwk.d ? ['deriveBits'] : [];\n            break;\n\n          default:\n            throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n        }\n\n        break;\n      }\n\n    default:\n      throw new JOSENotSupported('unsupported or invalid JWK \"kty\" (Key Type) Parameter value');\n  }\n\n  return {\n    algorithm,\n    keyUsages\n  };\n}\n\nconst parse = async jwk => {\n  var _a, _b;\n\n  const {\n    algorithm,\n    keyUsages\n  } = subtleMapping(jwk);\n  let format = 'jwk';\n  let keyData = { ...jwk\n  };\n  delete keyData.alg;\n\n  if (algorithm.name === 'PBKDF2') {\n    format = 'raw';\n    keyData = decode$1(jwk.k);\n  }\n\n  return crypto.subtle.importKey(format, keyData, algorithm, (_a = jwk.ext) !== null && _a !== void 0 ? _a : false, (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages);\n};\n\nasync function parseJwk(jwk, alg, octAsKeyObject) {\n  if (!isObject(jwk)) {\n    throw new TypeError('JWK must be an object');\n  }\n\n  alg || (alg = jwk.alg);\n\n  if (typeof alg !== 'string' || !alg) {\n    throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n  }\n\n  switch (jwk.kty) {\n    case 'oct':\n      if (typeof jwk.k !== 'string' || !jwk.k) {\n        throw new TypeError('missing \"k\" (Key Value) Parameter value');\n      }\n\n      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;\n\n      if (octAsKeyObject) {\n        return parse({ ...jwk,\n          alg,\n          ext: false\n        });\n      }\n\n      return decode$1(jwk.k);\n\n    case 'RSA':\n      if (jwk.oth !== undefined) {\n        throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n      }\n\n    case 'EC':\n    case 'OKP':\n      return parse({ ...jwk,\n        alg\n      });\n\n    default:\n      throw new JOSENotSupported('unsupported \"kty\" (Key Type) Parameter value');\n  }\n}\n\nfunction assertEnryptedKey(encryptedKey) {\n  if (!encryptedKey) {\n    throw new JWEInvalid('JWE Encrypted Key missing');\n  }\n}\n\nfunction assertHeaderParameter(joseHeader, parameter, name) {\n  if (joseHeader[parameter] === undefined) {\n    throw new JWEInvalid(`JOSE Header ${name} (${parameter}) missing`);\n  }\n}\n\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader) {\n  switch (alg) {\n    case 'dir':\n      {\n        if (encryptedKey !== undefined) {\n          throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        }\n\n        return key;\n      }\n\n    case 'ECDH-ES':\n      if (encryptedKey !== undefined) {\n        throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n      }\n\n    case 'ECDH-ES+A128KW':\n    case 'ECDH-ES+A192KW':\n    case 'ECDH-ES+A256KW':\n      {\n        assertHeaderParameter(joseHeader, 'epk', 'Ephemeral Public Key');\n\n        if (!ecdhAllowed(key)) {\n          throw new JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');\n        }\n\n        const epk = await parseJwk(joseHeader.epk, alg);\n        let partyUInfo;\n        let partyVInfo;\n        if (joseHeader.apu !== undefined) partyUInfo = decode$1(joseHeader.apu);\n        if (joseHeader.apv !== undefined) partyVInfo = decode$1(joseHeader.apv);\n        const sharedSecret = await deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, parseInt(alg.substr(-5, 3), 10) || bitLengths.get(joseHeader.enc), partyUInfo, partyVInfo);\n\n        if (alg === 'ECDH-ES') {\n          return sharedSecret;\n        }\n\n        assertEnryptedKey(encryptedKey);\n        const kwAlg = alg.substr(-6);\n        return unwrap$1(kwAlg, sharedSecret, encryptedKey);\n      }\n\n    case 'RSA1_5':\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      {\n        assertEnryptedKey(encryptedKey);\n        return decrypt(alg, key, encryptedKey);\n      }\n\n    case 'PBES2-HS256+A128KW':\n    case 'PBES2-HS384+A192KW':\n    case 'PBES2-HS512+A256KW':\n      {\n        assertEnryptedKey(encryptedKey);\n        assertHeaderParameter(joseHeader, 'p2c', 'PBES2 Count');\n        assertHeaderParameter(joseHeader, 'p2s', 'PBES2 Salt');\n        const {\n          p2c\n        } = joseHeader;\n        const p2s = decode$1(joseHeader.p2s);\n        return decrypt$1(alg, key, encryptedKey, p2c, p2s);\n      }\n\n    case 'A128KW':\n    case 'A192KW':\n    case 'A256KW':\n      {\n        assertEnryptedKey(encryptedKey);\n        return unwrap$1(alg, key, encryptedKey);\n      }\n\n    case 'A128GCMKW':\n    case 'A192GCMKW':\n    case 'A256GCMKW':\n      {\n        assertEnryptedKey(encryptedKey);\n        assertHeaderParameter(joseHeader, 'iv', 'Initialization Vector');\n        assertHeaderParameter(joseHeader, 'tag', 'Authentication Tag');\n        const iv = decode$1(joseHeader.iv);\n        const tag = decode$1(joseHeader.tag);\n        return unwrap(alg, key, encryptedKey, iv, tag);\n      }\n\n    default:\n      {\n        throw new JOSENotSupported('unsupported or invalid \"alg\" (JWE Algorithm) header value');\n      }\n  }\n}\n\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {\n    throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n  }\n\n  if (!protectedHeader || protectedHeader.crit === undefined) {\n    return new Set();\n  }\n\n  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some(input => typeof input !== 'string' || input.length === 0)) {\n    throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n  }\n\n  let recognized;\n\n  if (recognizedOption !== undefined) {\n    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n  } else {\n    recognized = recognizedDefault;\n  }\n\n  for (const parameter of protectedHeader.crit) {\n    if (!recognized.has(parameter)) {\n      throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n    }\n\n    if (joseHeader[parameter] === undefined) {\n      throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n      throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n    }\n  }\n\n  return new Set(protectedHeader.crit);\n}\n\nconst validateAlgorithms = (option, algorithms) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string'))) {\n    throw new TypeError(`\"${option}\" option must be an array of strings`);\n  }\n\n  if (!algorithms) {\n    return undefined;\n  }\n\n  return new Set(algorithms);\n};\n\nconst generateCek$1 = factory(random$1);\nconst checkExtensions$3 = validateCrit.bind(undefined, JWEInvalid, new Map());\nconst checkAlgOption$1 = validateAlgorithms.bind(undefined, 'keyManagementAlgorithms');\nconst checkEncOption = validateAlgorithms.bind(undefined, 'contentEncryptionAlgorithms');\n\nasync function flattenedDecrypt(jwe, key, options) {\n  var _a;\n\n  if (!isObject(jwe)) {\n    throw new JWEInvalid('Flattened JWE must be an object');\n  }\n\n  if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n    throw new JWEInvalid('JOSE Header missing');\n  }\n\n  if (typeof jwe.iv !== 'string') {\n    throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');\n  }\n\n  if (typeof jwe.ciphertext !== 'string') {\n    throw new JWEInvalid('JWE Ciphertext missing or incorrect type');\n  }\n\n  if (typeof jwe.tag !== 'string') {\n    throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');\n  }\n\n  if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n    throw new JWEInvalid('JWE Protected Header incorrect type');\n  }\n\n  if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n    throw new JWEInvalid('JWE Encrypted Key incorrect type');\n  }\n\n  if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n    throw new JWEInvalid('JWE AAD incorrect type');\n  }\n\n  if (jwe.header !== undefined && !isObject(jwe.header)) {\n    throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');\n  }\n\n  if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n    throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n  }\n\n  let parsedProt;\n\n  if (jwe.protected) {\n    const protectedHeader = decode$1(jwe.protected);\n    parsedProt = JSON.parse(decoder.decode(protectedHeader));\n  }\n\n  if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n    throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n  }\n\n  const joseHeader = { ...parsedProt,\n    ...jwe.header,\n    ...jwe.unprotected\n  };\n  checkExtensions$3(options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n\n  if (joseHeader.zip !== undefined) {\n    if (!parsedProt || !parsedProt.zip) {\n      throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n    }\n\n    if (joseHeader.zip !== 'DEF') {\n      throw new JOSENotSupported('unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n    }\n  }\n\n  const {\n    alg,\n    enc\n  } = joseHeader;\n\n  if (typeof alg !== 'string' || !alg) {\n    throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n  }\n\n  if (typeof enc !== 'string' || !enc) {\n    throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n  }\n\n  const keyManagementAlgorithms = options && checkAlgOption$1(options.keyManagementAlgorithms);\n  const contentEncryptionAlgorithms = options && checkEncOption(options.contentEncryptionAlgorithms);\n\n  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n    throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n  }\n\n  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n    throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed');\n  }\n\n  let encryptedKey;\n\n  if (jwe.encrypted_key !== undefined) {\n    encryptedKey = decode$1(jwe.encrypted_key);\n  }\n\n  if (typeof key === 'function') {\n    key = await key(parsedProt, jwe);\n  }\n\n  let cek;\n\n  try {\n    cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader);\n  } catch (err) {\n    if (err instanceof TypeError) {\n      throw err;\n    }\n\n    cek = generateCek$1(enc);\n  }\n\n  const iv = decode$1(jwe.iv);\n  const tag = decode$1(jwe.tag);\n  const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');\n  let additionalData;\n\n  if (jwe.aad !== undefined) {\n    additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad));\n  } else {\n    additionalData = protectedHeader;\n  }\n\n  let plaintext = await decrypt$2(enc, cek, decode$1(jwe.ciphertext), iv, tag, additionalData);\n\n  if (joseHeader.zip === 'DEF') {\n    plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);\n  }\n\n  const result = {\n    plaintext\n  };\n\n  if (jwe.protected !== undefined) {\n    result.protectedHeader = parsedProt;\n  }\n\n  if (jwe.aad !== undefined) {\n    result.additionalAuthenticatedData = decode$1(jwe.aad);\n  }\n\n  if (jwe.unprotected !== undefined) {\n    result.sharedUnprotectedHeader = jwe.unprotected;\n  }\n\n  if (jwe.header !== undefined) {\n    result.unprotectedHeader = jwe.header;\n  }\n\n  return result;\n}\n\nasync function compactDecrypt(jwe, key, options) {\n  if (jwe instanceof Uint8Array) {\n    jwe = decoder.decode(jwe);\n  }\n\n  if (typeof jwe !== 'string') {\n    throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n  }\n\n  const {\n    0: protectedHeader,\n    1: encryptedKey,\n    2: iv,\n    3: ciphertext,\n    4: tag,\n    length\n  } = jwe.split('.');\n\n  if (length !== 5) {\n    throw new JWEInvalid('Invalid Compact JWE');\n  }\n\n  const decrypted = await flattenedDecrypt({\n    ciphertext: ciphertext || undefined,\n    iv: iv || undefined,\n    protected: protectedHeader || undefined,\n    tag: tag || undefined,\n    encrypted_key: encryptedKey || undefined\n  }, key, options);\n  return {\n    plaintext: decrypted.plaintext,\n    protectedHeader: decrypted.protectedHeader\n  };\n}\n\nconst keyToJWK = async key => {\n  if (!isCryptoKey(key)) {\n    throw new TypeError('invalid key input');\n  }\n\n  if (!key.extractable) {\n    throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n  }\n\n  const {\n    ext,\n    key_ops,\n    alg,\n    use,\n    ...jwk\n  } = await crypto.subtle.exportKey('jwk', key);\n  return jwk;\n};\n\nasync function fromKeyLike(key) {\n  if (key instanceof Uint8Array) {\n    return {\n      kty: 'oct',\n      k: encode$1(key)\n    };\n  }\n\n  return keyToJWK(key);\n}\n\nconst generateCek = factory(random$1);\n\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n  let encryptedKey;\n  let parameters;\n  let cek;\n\n  switch (alg) {\n    case 'dir':\n      {\n        cek = key;\n        break;\n      }\n\n    case 'ECDH-ES':\n    case 'ECDH-ES+A128KW':\n    case 'ECDH-ES+A192KW':\n    case 'ECDH-ES+A256KW':\n      {\n        if (!ecdhAllowed(key)) {\n          throw new JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');\n        }\n\n        const {\n          apu,\n          apv\n        } = providedParameters;\n        let {\n          epk: ephemeralKey\n        } = providedParameters;\n        ephemeralKey || (ephemeralKey = await generateEpk(key));\n        const {\n          x,\n          y,\n          crv,\n          kty\n        } = await fromKeyLike(ephemeralKey);\n        const sharedSecret = await deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, parseInt(alg.substr(-5, 3), 10) || bitLengths.get(enc), apu, apv);\n        parameters = {\n          epk: {\n            x,\n            y,\n            crv,\n            kty\n          }\n        };\n        if (apu) parameters.apu = encode$1(apu);\n        if (apv) parameters.apv = encode$1(apv);\n\n        if (alg === 'ECDH-ES') {\n          cek = sharedSecret;\n          break;\n        }\n\n        cek = providedCek || generateCek(enc);\n        const kwAlg = alg.substr(-6);\n        encryptedKey = await wrap$1(kwAlg, sharedSecret, cek);\n        break;\n      }\n\n    case 'RSA1_5':\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      {\n        cek = providedCek || generateCek(enc);\n        encryptedKey = await encrypt$1(alg, key, cek);\n        break;\n      }\n\n    case 'PBES2-HS256+A128KW':\n    case 'PBES2-HS384+A192KW':\n    case 'PBES2-HS512+A256KW':\n      {\n        cek = providedCek || generateCek(enc);\n        const {\n          p2c,\n          p2s\n        } = providedParameters;\n        ({\n          encryptedKey,\n          ...parameters\n        } = await encrypt$2(alg, key, cek, p2c, p2s));\n        break;\n      }\n\n    case 'A128KW':\n    case 'A192KW':\n    case 'A256KW':\n      {\n        cek = providedCek || generateCek(enc);\n        encryptedKey = await wrap$1(alg, key, cek);\n        break;\n      }\n\n    case 'A128GCMKW':\n    case 'A192GCMKW':\n    case 'A256GCMKW':\n      {\n        cek = providedCek || generateCek(enc);\n        const {\n          iv\n        } = providedParameters;\n        ({\n          encryptedKey,\n          ...parameters\n        } = await wrap(alg, key, cek, iv));\n        break;\n      }\n\n    default:\n      {\n        throw new JOSENotSupported('unsupported or invalid \"alg\" (JWE Algorithm) header value');\n      }\n  }\n\n  return {\n    cek,\n    encryptedKey,\n    parameters\n  };\n}\n\nconst generateIv = factory$1(random$1);\nconst checkExtensions$2 = validateCrit.bind(undefined, JWEInvalid, new Map());\n\nclass FlattenedEncrypt {\n  constructor(plaintext) {\n    this._plaintext = plaintext;\n  }\n\n  setKeyManagementParameters(parameters) {\n    if (this._keyManagementParameters) {\n      throw new TypeError('setKeyManagementParameters can only be called once');\n    }\n\n    this._keyManagementParameters = parameters;\n    return this;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n    if (this._sharedUnprotectedHeader) {\n      throw new TypeError('setSharedUnprotectedHeader can only be called once');\n    }\n\n    this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n    return this;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  setAdditionalAuthenticatedData(aad) {\n    this._aad = aad;\n    return this;\n  }\n\n  setContentEncryptionKey(cek) {\n    if (this._cek) {\n      throw new TypeError('setContentEncryptionKey can only be called once');\n    }\n\n    this._cek = cek;\n    return this;\n  }\n\n  setInitializationVector(iv) {\n    if (this._iv) {\n      throw new TypeError('setInitializationVector can only be called once');\n    }\n\n    this._iv = iv;\n    return this;\n  }\n\n  async encrypt(key, options) {\n    if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n      throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n    }\n\n    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n      throw new JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n    }\n\n    const joseHeader = { ...this._protectedHeader,\n      ...this._unprotectedHeader,\n      ...this._sharedUnprotectedHeader\n    };\n    checkExtensions$2(options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n\n    if (joseHeader.zip !== undefined) {\n      if (!this._protectedHeader || !this._protectedHeader.zip) {\n        throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n      }\n\n      if (joseHeader.zip !== 'DEF') {\n        throw new JOSENotSupported('unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n      }\n    }\n\n    const {\n      alg,\n      enc\n    } = joseHeader;\n\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n\n    if (typeof enc !== 'string' || !enc) {\n      throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n    }\n\n    let encryptedKey;\n\n    if (alg === 'dir') {\n      if (this._cek) {\n        throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n      }\n    } else if (alg === 'ECDH-ES') {\n      if (this._cek) {\n        throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n      }\n    }\n\n    let cek;\n    {\n      let parameters;\n      ({\n        cek,\n        encryptedKey,\n        parameters\n      } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n\n      if (parameters) {\n        if (!this._protectedHeader) {\n          this.setProtectedHeader(parameters);\n        } else {\n          this._protectedHeader = { ...this._protectedHeader,\n            ...parameters\n          };\n        }\n      }\n    }\n    this._iv || (this._iv = generateIv(enc));\n    let additionalData;\n    let protectedHeader;\n    let aadMember;\n\n    if (this._protectedHeader) {\n      protectedHeader = encoder.encode(encode$1(JSON.stringify(this._protectedHeader)));\n    } else {\n      protectedHeader = encoder.encode('');\n    }\n\n    if (this._aad) {\n      aadMember = encode$1(this._aad);\n      additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n    } else {\n      additionalData = protectedHeader;\n    }\n\n    let ciphertext;\n    let tag;\n\n    if (joseHeader.zip === 'DEF') {\n      const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n      ({\n        ciphertext,\n        tag\n      } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n    } else {\n      ({\n        ciphertext,\n        tag\n      } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n    }\n\n    const jwe = {\n      ciphertext: encode$1(ciphertext),\n      iv: encode$1(this._iv),\n      tag: encode$1(tag)\n    };\n\n    if (encryptedKey) {\n      jwe.encrypted_key = encode$1(encryptedKey);\n    }\n\n    if (aadMember) {\n      jwe.aad = aadMember;\n    }\n\n    if (this._protectedHeader) {\n      jwe.protected = decoder.decode(protectedHeader);\n    }\n\n    if (this._sharedUnprotectedHeader) {\n      jwe.unprotected = this._sharedUnprotectedHeader;\n    }\n\n    if (this._unprotectedHeader) {\n      jwe.header = this._unprotectedHeader;\n    }\n\n    return jwe;\n  }\n\n}\n\nclass CompactEncrypt {\n  constructor(plaintext) {\n    this._flattened = new FlattenedEncrypt(plaintext);\n  }\n\n  setContentEncryptionKey(cek) {\n    this._flattened.setContentEncryptionKey(cek);\n\n    return this;\n  }\n\n  setInitializationVector(iv) {\n    this._flattened.setInitializationVector(iv);\n\n    return this;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    this._flattened.setProtectedHeader(protectedHeader);\n\n    return this;\n  }\n\n  setKeyManagementParameters(parameters) {\n    this._flattened.setKeyManagementParameters(parameters);\n\n    return this;\n  }\n\n  async encrypt(key, options) {\n    const jwe = await this._flattened.encrypt(key, options);\n    return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n  }\n\n}\n\nasync function generalDecrypt(jwe, key, options) {\n  if (!isObject(jwe)) {\n    throw new JWEInvalid('General JWE must be an object');\n  }\n\n  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {\n    throw new JWEInvalid('JWE Recipients missing or incorrect type');\n  }\n\n  for (const recipient of jwe.recipients) {\n    try {\n      return await flattenedDecrypt({\n        aad: jwe.aad,\n        ciphertext: jwe.ciphertext,\n        encrypted_key: recipient.encrypted_key,\n        header: recipient.header,\n        iv: jwe.iv,\n        protected: jwe.protected,\n        tag: jwe.tag,\n        unprotected: jwe.unprotected\n      }, key, options);\n    } catch (_a) {}\n  }\n\n  throw new JWEDecryptionFailed();\n}\n\nasync function EmbeddedJWK(protectedHeader, token) {\n  const joseHeader = { ...protectedHeader,\n    ...token.header\n  };\n\n  if (!isObject(joseHeader.jwk)) {\n    throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n  }\n\n  const key = await parseJwk(joseHeader.jwk, joseHeader.alg, true);\n\n  if (key.type !== 'public') {\n    throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n  }\n\n  return key;\n}\n\nconst check = (value, description) => {\n  if (typeof value !== 'string' || !value) {\n    throw new JWKInvalid(`${description} missing or invalid`);\n  }\n};\n\nasync function calculateThumbprint(jwk, digestAlgorithm = 'sha256') {\n  if (!isObject(jwk)) {\n    throw new TypeError('JWK must be an object');\n  }\n\n  let components;\n\n  switch (jwk.kty) {\n    case 'EC':\n      check(jwk.crv, '\"crv\" (Curve) Parameter');\n      check(jwk.x, '\"x\" (X Coordinate) Parameter');\n      check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n      components = {\n        crv: jwk.crv,\n        kty: jwk.kty,\n        x: jwk.x,\n        y: jwk.y\n      };\n      break;\n\n    case 'OKP':\n      check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n      check(jwk.x, '\"x\" (Public Key) Parameter');\n      components = {\n        crv: jwk.crv,\n        kty: jwk.kty,\n        x: jwk.x\n      };\n      break;\n\n    case 'RSA':\n      check(jwk.e, '\"e\" (Exponent) Parameter');\n      check(jwk.n, '\"n\" (Modulus) Parameter');\n      components = {\n        e: jwk.e,\n        kty: jwk.kty,\n        n: jwk.n\n      };\n      break;\n\n    case 'oct':\n      check(jwk.k, '\"k\" (Key Value) Parameter');\n      components = {\n        k: jwk.k,\n        kty: jwk.kty\n      };\n      break;\n\n    default:\n      throw new JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n  }\n\n  const data = encoder.encode(JSON.stringify(components));\n  return encode$1(await digest(digestAlgorithm, data));\n}\n\nconst fetchJwks = async (url, timeout) => {\n  let controller;\n\n  if (typeof AbortController === 'function') {\n    controller = new AbortController();\n    setTimeout(() => controller.abort(), timeout);\n  }\n\n  const response = await globalThis$1.fetch(url.href, {\n    signal: controller ? controller.signal : undefined,\n    redirect: 'manual',\n    referrerPolicy: 'no-referrer',\n    credentials: 'omit',\n    mode: 'cors',\n    method: 'GET'\n  });\n\n  if (response.status !== 200) {\n    throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n  }\n\n  try {\n    return await response.json();\n  } catch (err) {\n    throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n  }\n};\n\nfunction getKtyFromAlg(alg) {\n  switch (alg.substr(0, 2)) {\n    case 'RS':\n    case 'PS':\n      return 'RSA';\n\n    case 'ES':\n      return 'EC';\n\n    case 'Ed':\n      return 'OKP';\n\n    default:\n      throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n  }\n}\n\nfunction isJWKLike(key) {\n  return isObject(key);\n}\n\nclass RemoteJWKSet {\n  constructor(url, options) {\n    this._cached = new WeakMap();\n\n    if (!(url instanceof URL)) {\n      throw new TypeError('url must be an instance of URL');\n    }\n\n    this._url = new URL(url.href);\n    this._options = {\n      agent: options === null || options === void 0 ? void 0 : options.agent\n    };\n    this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;\n    this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;\n  }\n\n  coolingDown() {\n    if (typeof this._cooldownStarted === 'undefined') {\n      return false;\n    }\n\n    return Date.now() < this._cooldownStarted + this._cooldownDuration;\n  }\n\n  async getKey(protectedHeader) {\n    if (!this._jwks) {\n      await this.reload();\n    }\n\n    const candidates = this._jwks.keys.filter(jwk => {\n      let candidate = jwk.kty === getKtyFromAlg(protectedHeader.alg);\n\n      if (candidate && typeof protectedHeader.kid === 'string') {\n        candidate = protectedHeader.kid === jwk.kid;\n      }\n\n      if (candidate && typeof jwk.alg === 'string') {\n        candidate = protectedHeader.alg === jwk.alg;\n      }\n\n      if (candidate && typeof jwk.use === 'string') {\n        candidate = jwk.use === 'sig';\n      }\n\n      if (candidate && Array.isArray(jwk.key_ops)) {\n        candidate = jwk.key_ops.includes('verify');\n      }\n\n      if (candidate && protectedHeader.alg === 'EdDSA') {\n        candidate = ['Ed25519', 'Ed448'].includes(jwk.crv);\n      }\n\n      if (candidate) {\n        switch (protectedHeader.alg) {\n          case 'ES256':\n            candidate = jwk.crv === 'P-256';\n            break;\n\n          case 'ES256K':\n            candidate = jwk.crv === 'secp256k1';\n            break;\n\n          case 'ES384':\n            candidate = jwk.crv === 'P-384';\n            break;\n\n          case 'ES512':\n            candidate = jwk.crv === 'P-521';\n            break;\n        }\n      }\n\n      return candidate;\n    });\n\n    const {\n      0: jwk,\n      length\n    } = candidates;\n\n    if (length === 0) {\n      if (this.coolingDown() === false) {\n        await this.reload();\n        return this.getKey(protectedHeader);\n      }\n\n      throw new JWKSNoMatchingKey();\n    } else if (length !== 1) {\n      throw new JWKSMultipleMatchingKeys();\n    }\n\n    if (!this._cached.has(jwk)) {\n      this._cached.set(jwk, {});\n    }\n\n    const cached = this._cached.get(jwk);\n\n    if (cached[protectedHeader.alg] === undefined) {\n      const keyObject = await parseJwk({ ...jwk,\n        alg: protectedHeader.alg\n      });\n\n      if (keyObject.type !== 'public') {\n        throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n      }\n\n      cached[protectedHeader.alg] = keyObject;\n    }\n\n    return cached[protectedHeader.alg];\n  }\n\n  async reload() {\n    if (!this._pendingFetch) {\n      this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options).then(json => {\n        if (typeof json !== 'object' || !json || !Array.isArray(json.keys) || !json.keys.every(isJWKLike)) {\n          throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n\n        this._jwks = {\n          keys: json.keys\n        };\n        this._cooldownStarted = Date.now();\n        this._pendingFetch = undefined;\n      }).catch(err => {\n        this._pendingFetch = undefined;\n        throw err;\n      });\n    }\n\n    await this._pendingFetch;\n  }\n\n}\n\nfunction createRemoteJWKSet(url, options) {\n  const set = new RemoteJWKSet(url, options);\n  return set.getKey.bind(set);\n}\n\nfunction subtleDsa(alg) {\n  switch (alg) {\n    case 'HS256':\n      return {\n        hash: {\n          name: 'SHA-256'\n        },\n        name: 'HMAC'\n      };\n\n    case 'HS384':\n      return {\n        hash: {\n          name: 'SHA-384'\n        },\n        name: 'HMAC'\n      };\n\n    case 'HS512':\n      return {\n        hash: {\n          name: 'SHA-512'\n        },\n        name: 'HMAC'\n      };\n\n    case 'PS256':\n      return {\n        hash: {\n          name: 'SHA-256'\n        },\n        name: 'RSA-PSS',\n        saltLength: 256 >> 3\n      };\n\n    case 'PS384':\n      return {\n        hash: {\n          name: 'SHA-384'\n        },\n        name: 'RSA-PSS',\n        saltLength: 384 >> 3\n      };\n\n    case 'PS512':\n      return {\n        hash: {\n          name: 'SHA-512'\n        },\n        name: 'RSA-PSS',\n        saltLength: 512 >> 3\n      };\n\n    case 'RS256':\n      return {\n        hash: {\n          name: 'SHA-256'\n        },\n        name: 'RSASSA-PKCS1-v1_5'\n      };\n\n    case 'RS384':\n      return {\n        hash: {\n          name: 'SHA-384'\n        },\n        name: 'RSASSA-PKCS1-v1_5'\n      };\n\n    case 'RS512':\n      return {\n        hash: {\n          name: 'SHA-512'\n        },\n        name: 'RSASSA-PKCS1-v1_5'\n      };\n\n    case 'ES256':\n      return {\n        hash: {\n          name: 'SHA-256'\n        },\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      };\n\n    case 'ES384':\n      return {\n        hash: {\n          name: 'SHA-384'\n        },\n        name: 'ECDSA',\n        namedCurve: 'P-384'\n      };\n\n    case 'ES512':\n      return {\n        hash: {\n          name: 'SHA-512'\n        },\n        name: 'ECDSA',\n        namedCurve: 'P-521'\n      };\n\n    default:\n      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n  }\n}\n\nfunction getCryptoKey(alg, key, usage) {\n  if (isCryptoKey(key)) {\n    return key;\n  }\n\n  if (key instanceof Uint8Array) {\n    if (!alg.startsWith('HS')) {\n      throw new TypeError('symmetric keys are only applicable for HMAC-based algorithms');\n    }\n\n    return crypto.subtle.importKey('raw', key, {\n      hash: {\n        name: `SHA-${alg.substr(-3)}`\n      },\n      name: 'HMAC'\n    }, false, [usage]);\n  }\n\n  throw new TypeError('invalid key input');\n}\n\nconst sign = async (alg, key, data) => {\n  const cryptoKey = await getCryptoKey(alg, key, 'sign');\n  checkKeyLength(alg, cryptoKey);\n  const signature = await crypto.subtle.sign(subtleDsa(alg), cryptoKey, data);\n  return new Uint8Array(signature);\n};\n\nconst checkKeyType = (alg, key) => {\n  if (alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || alg.match(/^A\\d{3}(?:GCM)KW$/)) {\n    if (key instanceof Uint8Array || key.type === 'secret') {\n      return;\n    }\n\n    throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type \"secret\"');\n  }\n\n  if (key instanceof Uint8Array) {\n    throw new TypeError('CryptoKey or KeyObject instances must be used for asymmetric algorithms');\n  }\n\n  if (key.type === 'secret') {\n    throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type \"secret\"');\n  }\n};\n\nconst checkExtensions$1 = validateCrit.bind(undefined, JWSInvalid, new Map([['b64', true]]));\n\nclass FlattenedSign {\n  constructor(payload) {\n    this._payload = payload;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  async sign(key, options) {\n    if (!this._protectedHeader && !this._unprotectedHeader) {\n      throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n    }\n\n    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    const joseHeader = { ...this._protectedHeader,\n      ...this._unprotectedHeader\n    };\n    const extensions = checkExtensions$1(options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n    let b64 = true;\n\n    if (extensions.has('b64')) {\n      b64 = this._protectedHeader.b64;\n\n      if (typeof b64 !== 'boolean') {\n        throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n      }\n    }\n\n    const {\n      alg\n    } = joseHeader;\n\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n\n    checkKeyType(alg, key);\n    let payload = this._payload;\n\n    if (b64) {\n      payload = encoder.encode(encode$1(payload));\n    }\n\n    let protectedHeader;\n\n    if (this._protectedHeader) {\n      protectedHeader = encoder.encode(encode$1(JSON.stringify(this._protectedHeader)));\n    } else {\n      protectedHeader = encoder.encode('');\n    }\n\n    const data = concat(protectedHeader, encoder.encode('.'), payload);\n    const signature = await sign(alg, key, data);\n    const jws = {\n      signature: encode$1(signature)\n    };\n\n    if (b64) {\n      jws.payload = decoder.decode(payload);\n    }\n\n    if (this._unprotectedHeader) {\n      jws.header = this._unprotectedHeader;\n    }\n\n    if (this._protectedHeader) {\n      jws.protected = decoder.decode(protectedHeader);\n    }\n\n    return jws;\n  }\n\n}\n\nclass CompactSign {\n  constructor(payload) {\n    this._flattened = new FlattenedSign(payload);\n  }\n\n  setProtectedHeader(protectedHeader) {\n    this._flattened.setProtectedHeader(protectedHeader);\n\n    return this;\n  }\n\n  async sign(key, options) {\n    const jws = await this._flattened.sign(key, options);\n\n    if (jws.payload === undefined) {\n      throw new TypeError('use the flattened module for creating JWS with b64: false');\n    }\n\n    return `${jws.protected}.${jws.payload}.${jws.signature}`;\n  }\n\n}\n\nconst verify = async (alg, key, signature, data) => {\n  const cryptoKey = await getCryptoKey(alg, key, 'verify');\n  checkKeyLength(alg, cryptoKey);\n  const algorithm = subtleDsa(alg);\n\n  try {\n    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n  } catch (_a) {\n    return false;\n  }\n};\n\nconst checkExtensions = validateCrit.bind(undefined, JWSInvalid, new Map([['b64', true]]));\nconst checkAlgOption = validateAlgorithms.bind(undefined, 'algorithms');\n\nasync function flattenedVerify(jws, key, options) {\n  var _a;\n\n  if (!isObject(jws)) {\n    throw new JWSInvalid('Flattened JWS must be an object');\n  }\n\n  if (jws.protected === undefined && jws.header === undefined) {\n    throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n  }\n\n  if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n    throw new JWSInvalid('JWS Protected Header incorrect type');\n  }\n\n  if (jws.payload === undefined) {\n    throw new JWSInvalid('JWS Payload missing');\n  }\n\n  if (typeof jws.signature !== 'string') {\n    throw new JWSInvalid('JWS Signature missing or incorrect type');\n  }\n\n  if (jws.header !== undefined && !isObject(jws.header)) {\n    throw new JWSInvalid('JWS Unprotected Header incorrect type');\n  }\n\n  let parsedProt = {};\n\n  if (jws.protected) {\n    const protectedHeader = decode$1(jws.protected);\n    parsedProt = JSON.parse(decoder.decode(protectedHeader));\n  }\n\n  if (!isDisjoint(parsedProt, jws.header)) {\n    throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n  }\n\n  const joseHeader = { ...parsedProt,\n    ...jws.header\n  };\n  const extensions = checkExtensions(options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n  let b64 = true;\n\n  if (extensions.has('b64')) {\n    b64 = parsedProt.b64;\n\n    if (typeof b64 !== 'boolean') {\n      throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n    }\n  }\n\n  const {\n    alg\n  } = joseHeader;\n\n  if (typeof alg !== 'string' || !alg) {\n    throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n  }\n\n  const algorithms = options && checkAlgOption(options.algorithms);\n\n  if (algorithms && !algorithms.has(alg)) {\n    throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n  }\n\n  if (b64) {\n    if (typeof jws.payload !== 'string') {\n      throw new JWSInvalid('JWS Payload must be a string');\n    }\n  } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n    throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n  }\n\n  if (typeof key === 'function') {\n    key = await key(parsedProt, jws);\n  }\n\n  checkKeyType(alg, key);\n  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n  const signature = decode$1(jws.signature);\n  const verified = await verify(alg, key, signature, data);\n\n  if (!verified) {\n    throw new JWSSignatureVerificationFailed();\n  }\n\n  let payload;\n\n  if (b64) {\n    payload = decode$1(jws.payload);\n  } else if (typeof jws.payload === 'string') {\n    payload = encoder.encode(jws.payload);\n  } else {\n    payload = jws.payload;\n  }\n\n  const result = {\n    payload\n  };\n\n  if (jws.protected !== undefined) {\n    result.protectedHeader = parsedProt;\n  }\n\n  if (jws.header !== undefined) {\n    result.unprotectedHeader = jws.header;\n  }\n\n  return result;\n}\n\nasync function compactVerify(jws, key, options) {\n  if (jws instanceof Uint8Array) {\n    jws = decoder.decode(jws);\n  }\n\n  if (typeof jws !== 'string') {\n    throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n  }\n\n  const {\n    0: protectedHeader,\n    1: payload,\n    2: signature,\n    length\n  } = jws.split('.');\n\n  if (length !== 3) {\n    throw new JWSInvalid('Invalid Compact JWS');\n  }\n\n  const verified = await flattenedVerify({\n    payload: payload || undefined,\n    protected: protectedHeader || undefined,\n    signature: signature || undefined\n  }, key, options);\n  return {\n    payload: verified.payload,\n    protectedHeader: verified.protectedHeader\n  };\n}\n\nconst signatureRef = new WeakMap();\n\nclass IndividualSignature {\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  set _protectedHeader(value) {\n    signatureRef.get(this).protectedHeader = value;\n  }\n\n  get _protectedHeader() {\n    return signatureRef.get(this).protectedHeader;\n  }\n\n  set _unprotectedHeader(value) {\n    signatureRef.get(this).unprotectedHeader = value;\n  }\n\n  get _unprotectedHeader() {\n    return signatureRef.get(this).unprotectedHeader;\n  }\n\n}\n\nclass GeneralSign {\n  constructor(payload) {\n    this._signatures = [];\n    this._payload = payload;\n  }\n\n  addSignature(key, options) {\n    const signature = new IndividualSignature();\n    signatureRef.set(signature, {\n      key,\n      options\n    });\n\n    this._signatures.push(signature);\n\n    return signature;\n  }\n\n  async sign() {\n    if (!this._signatures.length) {\n      throw new JWSInvalid('at least one signature must be added');\n    }\n\n    const jws = {\n      signatures: []\n    };\n    await Promise.all(this._signatures.map(async (sig, i) => {\n      const {\n        protectedHeader,\n        unprotectedHeader,\n        options,\n        key\n      } = signatureRef.get(sig);\n      const flattened = new FlattenedSign(this._payload);\n\n      if (protectedHeader) {\n        flattened.setProtectedHeader(protectedHeader);\n      }\n\n      if (unprotectedHeader) {\n        flattened.setUnprotectedHeader(unprotectedHeader);\n      }\n\n      const {\n        payload,\n        ...rest\n      } = await flattened.sign(key, options);\n\n      if ('payload' in jws && jws.payload !== payload) {\n        throw new JWSInvalid(`index ${i} signature produced a different payload`);\n      } else {\n        jws.payload = payload;\n      }\n\n      jws.signatures.push(rest);\n    }));\n\n    if ('payload' in jws && jws.payload === undefined) {\n      delete jws.payload;\n    }\n\n    return jws;\n  }\n\n}\n\nasync function generalVerify(jws, key, options) {\n  if (!isObject(jws)) {\n    throw new JWSInvalid('General JWS must be an object');\n  }\n\n  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {\n    throw new JWSInvalid('JWS Signatures missing or incorrect type');\n  }\n\n  for (const signature of jws.signatures) {\n    try {\n      return await flattenedVerify({\n        header: signature.header,\n        payload: jws.payload,\n        protected: signature.protected,\n        signature: signature.signature\n      }, key, options);\n    } catch (_a) {}\n  }\n\n  throw new JWSSignatureVerificationFailed();\n}\n\nvar epoch = date => Math.floor(date.getTime() / 1000);\n\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\n\nvar secs = str => {\n  const matched = REGEX.exec(str);\n\n  if (!matched) {\n    throw new TypeError('invalid time period format');\n  }\n\n  const value = parseFloat(matched[1]);\n  const unit = matched[2].toLowerCase();\n\n  switch (unit) {\n    case 'sec':\n    case 'secs':\n    case 'second':\n    case 'seconds':\n    case 's':\n      return Math.round(value);\n\n    case 'minute':\n    case 'minutes':\n    case 'min':\n    case 'mins':\n    case 'm':\n      return Math.round(value * minute);\n\n    case 'hour':\n    case 'hours':\n    case 'hr':\n    case 'hrs':\n    case 'h':\n      return Math.round(value * hour);\n\n    case 'day':\n    case 'days':\n    case 'd':\n      return Math.round(value * day);\n\n    case 'week':\n    case 'weeks':\n    case 'w':\n      return Math.round(value * week);\n\n    default:\n      return Math.round(value * year);\n  }\n};\n\nconst normalizeTyp = value => value.toLowerCase().replace(/^application\\//, '');\n\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  }\n\n  if (Array.isArray(audPayload)) {\n    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n  }\n\n  return false;\n};\n\nvar jwtPayload = (protectedHeader, encodedPayload, options = {}) => {\n  const {\n    typ\n  } = options;\n\n  if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n    throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n  }\n\n  let payload;\n\n  try {\n    payload = JSON.parse(decoder.decode(encodedPayload));\n  } catch (_a) {}\n\n  if (!isObject(payload)) {\n    throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n  }\n\n  const {\n    issuer\n  } = options;\n\n  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n    throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n  }\n\n  const {\n    subject\n  } = options;\n\n  if (subject && payload.sub !== subject) {\n    throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n  }\n\n  const {\n    audience\n  } = options;\n\n  if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n  }\n\n  let tolerance;\n\n  switch (typeof options.clockTolerance) {\n    case 'string':\n      tolerance = secs(options.clockTolerance);\n      break;\n\n    case 'number':\n      tolerance = options.clockTolerance;\n      break;\n\n    case 'undefined':\n      tolerance = 0;\n      break;\n\n    default:\n      throw new TypeError('invalid clockTolerance option type');\n  }\n\n  const {\n    currentDate\n  } = options;\n  const now = epoch(currentDate || new Date());\n\n  if (payload.iat !== undefined || options.maxTokenAge) {\n    if (typeof payload.iat !== 'number') {\n      throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n    }\n\n    if (payload.exp === undefined && payload.iat > now + tolerance) {\n      throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n    }\n  }\n\n  if (payload.nbf !== undefined) {\n    if (typeof payload.nbf !== 'number') {\n      throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n    }\n\n    if (payload.nbf > now + tolerance) {\n      throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n    }\n  }\n\n  if (payload.exp !== undefined) {\n    if (typeof payload.exp !== 'number') {\n      throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n    }\n\n    if (payload.exp <= now - tolerance) {\n      throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n    }\n  }\n\n  if (options.maxTokenAge) {\n    const age = now - payload.iat;\n    const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : secs(options.maxTokenAge);\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n    }\n  }\n\n  return payload;\n};\n\nasync function jwtDecrypt(jwt, key, options) {\n  const decrypted = await compactDecrypt(jwt, key, options);\n  const payload = jwtPayload(decrypted.protectedHeader, decrypted.plaintext, options);\n  const {\n    protectedHeader\n  } = decrypted;\n\n  if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n    throw new JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', 'iss', 'mismatch');\n  }\n\n  if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n    throw new JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', 'sub', 'mismatch');\n  }\n\n  if (protectedHeader.aud !== undefined && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n    throw new JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', 'aud', 'mismatch');\n  }\n\n  return {\n    payload,\n    protectedHeader\n  };\n}\n\nclass ProduceJWT {\n  constructor(payload) {\n    if (!isObject(payload)) {\n      throw new TypeError('JWT Claims Set MUST be an object');\n    }\n\n    this._payload = payload;\n  }\n\n  setIssuer(issuer) {\n    this._payload = { ...this._payload,\n      iss: issuer\n    };\n    return this;\n  }\n\n  setSubject(subject) {\n    this._payload = { ...this._payload,\n      sub: subject\n    };\n    return this;\n  }\n\n  setAudience(audience) {\n    this._payload = { ...this._payload,\n      aud: audience\n    };\n    return this;\n  }\n\n  setJti(jwtId) {\n    this._payload = { ...this._payload,\n      jti: jwtId\n    };\n    return this;\n  }\n\n  setNotBefore(input) {\n    if (typeof input === 'number') {\n      this._payload = { ...this._payload,\n        nbf: input\n      };\n    } else {\n      this._payload = { ...this._payload,\n        nbf: epoch(new Date()) + secs(input)\n      };\n    }\n\n    return this;\n  }\n\n  setExpirationTime(input) {\n    if (typeof input === 'number') {\n      this._payload = { ...this._payload,\n        exp: input\n      };\n    } else {\n      this._payload = { ...this._payload,\n        exp: epoch(new Date()) + secs(input)\n      };\n    }\n\n    return this;\n  }\n\n  setIssuedAt(input) {\n    if (typeof input === 'undefined') {\n      this._payload = { ...this._payload,\n        iat: epoch(new Date())\n      };\n    } else {\n      this._payload = { ...this._payload,\n        iat: input\n      };\n    }\n\n    return this;\n  }\n\n}\n\nclass EncryptJWT extends ProduceJWT {\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setKeyManagementParameters(parameters) {\n    if (this._keyManagementParameters) {\n      throw new TypeError('setKeyManagementParameters can only be called once');\n    }\n\n    this._keyManagementParameters = parameters;\n    return this;\n  }\n\n  setContentEncryptionKey(cek) {\n    if (this._cek) {\n      throw new TypeError('setContentEncryptionKey can only be called once');\n    }\n\n    this._cek = cek;\n    return this;\n  }\n\n  setInitializationVector(iv) {\n    if (this._iv) {\n      throw new TypeError('setInitializationVector can only be called once');\n    }\n\n    this._iv = iv;\n    return this;\n  }\n\n  replicateIssuerAsHeader() {\n    this._replicateIssuerAsHeader = true;\n    return this;\n  }\n\n  replicateSubjectAsHeader() {\n    this._replicateSubjectAsHeader = true;\n    return this;\n  }\n\n  replicateAudienceAsHeader() {\n    this._replicateAudienceAsHeader = true;\n    return this;\n  }\n\n  async encrypt(key, options) {\n    const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));\n\n    if (this._replicateIssuerAsHeader) {\n      this._protectedHeader = { ...this._protectedHeader,\n        iss: this._payload.iss\n      };\n    }\n\n    if (this._replicateSubjectAsHeader) {\n      this._protectedHeader = { ...this._protectedHeader,\n        sub: this._payload.sub\n      };\n    }\n\n    if (this._replicateAudienceAsHeader) {\n      this._protectedHeader = { ...this._protectedHeader,\n        aud: this._payload.aud\n      };\n    }\n\n    enc.setProtectedHeader(this._protectedHeader);\n\n    if (this._iv) {\n      enc.setInitializationVector(this._iv);\n    }\n\n    if (this._cek) {\n      enc.setContentEncryptionKey(this._cek);\n    }\n\n    if (this._keyManagementParameters) {\n      enc.setKeyManagementParameters(this._keyManagementParameters);\n    }\n\n    return enc.encrypt(key, options);\n  }\n\n}\n\nclass SignJWT extends ProduceJWT {\n  setProtectedHeader(protectedHeader) {\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  async sign(key, options) {\n    var _a;\n\n    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n    sig.setProtectedHeader(this._protectedHeader);\n\n    if (((_a = this._protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && this._protectedHeader.b64 === false) {\n      throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n\n    return sig.sign(key, options);\n  }\n\n}\n\nclass UnsecuredJWT extends ProduceJWT {\n  encode() {\n    const header = encode$1(JSON.stringify({\n      alg: 'none'\n    }));\n    const payload = encode$1(JSON.stringify(this._payload));\n    return `${header}.${payload}.`;\n  }\n\n  static decode(jwt, options) {\n    if (typeof jwt !== 'string') {\n      throw new JWTInvalid('Unsecured JWT must be a string');\n    }\n\n    const {\n      0: encodedHeader,\n      1: encodedPayload,\n      2: signature,\n      length\n    } = jwt.split('.');\n\n    if (length !== 3 || signature !== '') {\n      throw new JWTInvalid('Invalid Unsecured JWT');\n    }\n\n    let header;\n\n    try {\n      header = JSON.parse(decoder.decode(decode$1(encodedHeader)));\n      if (header.alg !== 'none') throw new Error();\n    } catch (_a) {\n      throw new JWTInvalid('Invalid Unsecured JWT');\n    }\n\n    const payload = jwtPayload(header, decode$1(encodedPayload), options);\n    return {\n      payload,\n      header\n    };\n  }\n\n}\n\nasync function jwtVerify(jwt, key, options) {\n  var _a;\n\n  const verified = await compactVerify(jwt, key, options);\n\n  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {\n    throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n  }\n\n  const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n  return {\n    payload,\n    protectedHeader: verified.protectedHeader\n  };\n}\n\nconst encode = encode$1;\nconst decode = decode$1;\n\nfunction decodeProtectedHeader(token) {\n  let protectedB64u;\n\n  if (typeof token === 'string') {\n    const parts = token.split('.');\n\n    if (parts.length === 3 || parts.length === 5) {\n      [protectedB64u] = parts;\n    }\n  } else if (typeof token === 'object' && token) {\n    if ('protected' in token) {\n      protectedB64u = token.protected;\n    } else {\n      throw new TypeError('Token does not contain a Protected Header');\n    }\n  }\n\n  try {\n    if (typeof protectedB64u !== 'string' || !protectedB64u) {\n      throw new Error();\n    }\n\n    const result = JSON.parse(decoder.decode(decode(protectedB64u)));\n\n    if (!isObject(result)) {\n      throw new Error();\n    }\n\n    return result;\n  } catch (err) {\n    throw new TypeError('Invalid Token or Protected Header formatting');\n  }\n}\n\nasync function generateSecret$1(alg, options) {\n  var _a;\n\n  let length;\n  let algorithm;\n  let keyUsages;\n\n  switch (alg) {\n    case 'HS256':\n    case 'HS384':\n    case 'HS512':\n      length = parseInt(alg.substr(-3), 10);\n      algorithm = {\n        name: 'HMAC',\n        hash: {\n          name: `SHA-${alg.substr(-3)}`\n        },\n        length\n      };\n      keyUsages = ['sign', 'verify'];\n      break;\n\n    case 'A128CBC-HS256':\n    case 'A192CBC-HS384':\n    case 'A256CBC-HS512':\n      length = parseInt(alg.substr(-3), 10);\n      return random$1(new Uint8Array(length >> 3));\n\n    case 'A128KW':\n    case 'A192KW':\n    case 'A256KW':\n      length = parseInt(alg.substring(1, 4), 10);\n      algorithm = {\n        name: 'AES-KW',\n        length\n      };\n      keyUsages = ['wrapKey', 'unwrapKey'];\n      break;\n\n    case 'A128GCMKW':\n    case 'A192GCMKW':\n    case 'A256GCMKW':\n    case 'A128GCM':\n    case 'A192GCM':\n    case 'A256GCM':\n      length = parseInt(alg.substring(1, 4), 10);\n      algorithm = {\n        name: 'AES-GCM',\n        length\n      };\n      keyUsages = ['encrypt', 'decrypt'];\n      break;\n\n    default:\n      throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n  }\n\n  return crypto.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n}\n\nfunction getModulusLengthOption(options) {\n  var _a;\n\n  const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;\n\n  if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n    throw new JOSENotSupported('invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n  }\n\n  return modulusLength;\n}\n\nasync function generateKeyPair$1(alg, options) {\n  var _a, _b;\n\n  let algorithm;\n  let keyUsages;\n\n  switch (alg) {\n    case 'PS256':\n    case 'PS384':\n    case 'PS512':\n      algorithm = {\n        name: 'RSA-PSS',\n        hash: {\n          name: `SHA-${alg.substr(-3)}`\n        },\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        modulusLength: getModulusLengthOption(options)\n      };\n      keyUsages = ['sign', 'verify'];\n      break;\n\n    case 'RS256':\n    case 'RS384':\n    case 'RS512':\n      algorithm = {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: {\n          name: `SHA-${alg.substr(-3)}`\n        },\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        modulusLength: getModulusLengthOption(options)\n      };\n      keyUsages = ['sign', 'verify'];\n      break;\n\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      algorithm = {\n        name: 'RSA-OAEP',\n        hash: {\n          name: `SHA-${parseInt(alg.substr(-3), 10) || 1}`\n        },\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        modulusLength: getModulusLengthOption(options)\n      };\n      keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n      break;\n\n    case 'ES256':\n      algorithm = {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      };\n      keyUsages = ['sign', 'verify'];\n      break;\n\n    case 'ES384':\n      algorithm = {\n        name: 'ECDSA',\n        namedCurve: 'P-384'\n      };\n      keyUsages = ['sign', 'verify'];\n      break;\n\n    case 'ES512':\n      algorithm = {\n        name: 'ECDSA',\n        namedCurve: 'P-521'\n      };\n      keyUsages = ['sign', 'verify'];\n      break;\n\n    case 'ECDH-ES':\n    case 'ECDH-ES+A128KW':\n    case 'ECDH-ES+A192KW':\n    case 'ECDH-ES+A256KW':\n      algorithm = {\n        name: 'ECDH',\n        namedCurve: (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : 'P-256'\n      };\n      keyUsages = ['deriveKey', 'deriveBits'];\n      break;\n\n    default:\n      throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n  }\n\n  return crypto.subtle.generateKey(algorithm, (_b = options === null || options === void 0 ? void 0 : options.extractable) !== null && _b !== void 0 ? _b : false, keyUsages);\n}\n\nasync function generateKeyPair(alg, options) {\n  return generateKeyPair$1(alg, options);\n}\n\nasync function generateSecret(alg, options) {\n  return generateSecret$1(alg, options);\n}\n\nconst random = random$1;\nexports.CompactEncrypt = CompactEncrypt;\nexports.CompactSign = CompactSign;\nexports.EmbeddedJWK = EmbeddedJWK;\nexports.EncryptJWT = EncryptJWT;\nexports.FlattenedEncrypt = FlattenedEncrypt;\nexports.FlattenedSign = FlattenedSign;\nexports.GeneralSign = GeneralSign;\nexports.JOSEAlgNotAllowed = JOSEAlgNotAllowed;\nexports.JOSEError = JOSEError;\nexports.JOSENotSupported = JOSENotSupported;\nexports.JWEDecryptionFailed = JWEDecryptionFailed;\nexports.JWEInvalid = JWEInvalid;\nexports.JWKInvalid = JWKInvalid;\nexports.JWKSInvalid = JWKSInvalid;\nexports.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;\nexports.JWKSNoMatchingKey = JWKSNoMatchingKey;\nexports.JWSInvalid = JWSInvalid;\nexports.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;\nexports.JWTClaimValidationFailed = JWTClaimValidationFailed;\nexports.JWTExpired = JWTExpired;\nexports.JWTInvalid = JWTInvalid;\nexports.SignJWT = SignJWT;\nexports.UnsecuredJWT = UnsecuredJWT;\nexports.base64UrlDecode = decode;\nexports.base64UrlEncode = encode;\nexports.calculateThumbprint = calculateThumbprint;\nexports.compactDecrypt = compactDecrypt;\nexports.compactVerify = compactVerify;\nexports.createRemoteJWKSet = createRemoteJWKSet;\nexports.decodeProtectedHeader = decodeProtectedHeader;\nexports.flattenedDecrypt = flattenedDecrypt;\nexports.flattenedVerify = flattenedVerify;\nexports.fromKeyLike = fromKeyLike;\nexports.generalDecrypt = generalDecrypt;\nexports.generalVerify = generalVerify;\nexports.generateKeyPair = generateKeyPair;\nexports.generateSecret = generateSecret;\nexports.jwtDecrypt = jwtDecrypt;\nexports.jwtVerify = jwtVerify;\nexports.parseJwk = parseJwk;\nexports.random = random;","map":{"version":3,"sources":["/home/carlo/Desktop/Project/my-solid-blog-test/node_modules/@inrupt/jose-legacy-modules/dist/index.browser.js"],"names":["Object","defineProperty","exports","value","JOSEError","Error","constructor","message","code","name","captureStackTrace","JWTClaimValidationFailed","claim","reason","JOSEAlgNotAllowed","arguments","JOSENotSupported","JWEDecryptionFailed","JWEInvalid","JWSInvalid","JWTInvalid","JWKInvalid","JWKSInvalid","JWKSNoMatchingKey","JWKSMultipleMatchingKeys","JWSSignatureVerificationFailed","JWTExpired","isDisjoint","headers","sources","filter","Boolean","length","acc","header","parameters","keys","size","Set","parameter","has","add","isObjectLike","isObject","input","prototype","toString","call","getPrototypeOf","proto","encoder","TextEncoder","decoder","TextDecoder","MAX_INT32","concat","buffers","reduce","buf","Uint8Array","i","forEach","buffer","set","p2s","alg","p2sInput","encode","writeUInt32BE","offset","RangeError","uint64be","high","Math","floor","low","uint32be","lengthAndInput","concatKdf","digest","secret","bits","iterations","ceil","res","iter","slice","getGlobal","globalThis","self","window","globalThis$1","encode$1","unencoded","CHUNK_SIZE","arr","push","String","fromCharCode","apply","subarray","base64string","btoa","join","replace","decode$1","encoded","decode","atob","split","map","c","charCodeAt","_a","TypeError","bitLengths$1","Map","factory$1","random","bitLength","get","checkIvLength","enc","iv","checkCekLength","cek","expected","parseInt","substr","algorithm","undefined","timingSafeEqual","a","b","len","out","crypto","isCryptoKey","key","CryptoKey","cbcDecrypt","ciphertext","tag","aad","keySize","encKey","subtle","importKey","macKey","hash","macData","expectedTag","sign","macCheckPassed","plaintext","decrypt","_b","gcmDecrypt","additionalData","tagLength","err","decrypt$2","inflate","deflate","bogusWebCrypto","checkKeySize","getCryptoKey$2","usage","wrap$1","cryptoKey","cryptoKeyCek","wrapKey","unwrap$1","encryptedKey","unwrapKey","exportKey","data","subtleDigest","deriveKey","publicKey","privateKey","keyLength","apu","apv","usages","includes","sharedSecret","deriveBits","public","namedCurve","generateEpk","generateKey","ecdhAllowed","random$1","getRandomValues","bind","checkP2s","getCryptoKey$1","encrypt$2","p2c","p2s$1","salt","keylen","subtleAlg","wrapAlg","derived","decrypt$1","subtleRsaEs","checkKeyLength","startsWith","bitlen","modulusLength","encrypt$1","encrypt","cbcEncrypt","gcmEncrypt","encrypted","generateIv$1","wrap","jweAlgorithm","unwrap","bitLengths","factory","subtleMapping","jwk","keyUsages","kty","d","crv","parse","format","keyData","k","ext","key_ops","parseJwk","octAsKeyObject","oth","assertEnryptedKey","assertHeaderParameter","joseHeader","decryptKeyManagement","epk","partyUInfo","partyVInfo","kwAlg","validateCrit","Err","recognizedDefault","recognizedOption","protectedHeader","crit","Array","isArray","some","recognized","entries","validateAlgorithms","option","algorithms","s","generateCek$1","checkExtensions$3","checkAlgOption$1","checkEncOption","flattenedDecrypt","jwe","options","protected","unprotected","encrypted_key","parsedProt","JSON","zip","keyManagementAlgorithms","contentEncryptionAlgorithms","inflateRaw","result","additionalAuthenticatedData","sharedUnprotectedHeader","unprotectedHeader","compactDecrypt","decrypted","keyToJWK","extractable","use","fromKeyLike","generateCek","encryptKeyManagement","providedCek","providedParameters","ephemeralKey","x","y","generateIv","checkExtensions$2","FlattenedEncrypt","_plaintext","setKeyManagementParameters","_keyManagementParameters","setProtectedHeader","_protectedHeader","setSharedUnprotectedHeader","_sharedUnprotectedHeader","setUnprotectedHeader","_unprotectedHeader","setAdditionalAuthenticatedData","_aad","setContentEncryptionKey","_cek","setInitializationVector","_iv","aadMember","stringify","deflated","deflateRaw","CompactEncrypt","_flattened","generalDecrypt","recipients","every","recipient","EmbeddedJWK","token","type","check","description","calculateThumbprint","digestAlgorithm","components","e","n","fetchJwks","url","timeout","controller","AbortController","setTimeout","abort","response","fetch","href","signal","redirect","referrerPolicy","credentials","mode","method","status","json","getKtyFromAlg","isJWKLike","RemoteJWKSet","_cached","WeakMap","URL","_url","_options","agent","_timeoutDuration","timeoutDuration","_cooldownDuration","cooldownDuration","coolingDown","_cooldownStarted","Date","now","getKey","_jwks","reload","candidates","candidate","kid","cached","keyObject","_pendingFetch","then","catch","createRemoteJWKSet","subtleDsa","saltLength","getCryptoKey","signature","checkKeyType","match","checkExtensions$1","FlattenedSign","payload","_payload","extensions","b64","jws","CompactSign","verify","checkExtensions","checkAlgOption","flattenedVerify","verified","compactVerify","signatureRef","IndividualSignature","GeneralSign","_signatures","addSignature","signatures","Promise","all","sig","flattened","rest","generalVerify","epoch","date","getTime","minute","hour","day","week","year","REGEX","secs","str","matched","exec","parseFloat","unit","toLowerCase","round","normalizeTyp","checkAudiencePresence","audPayload","audOption","jwtPayload","encodedPayload","typ","issuer","iss","subject","sub","audience","aud","tolerance","clockTolerance","currentDate","iat","maxTokenAge","exp","nbf","age","max","jwtDecrypt","jwt","ProduceJWT","setIssuer","setSubject","setAudience","setJti","jwtId","jti","setNotBefore","setExpirationTime","setIssuedAt","EncryptJWT","replicateIssuerAsHeader","_replicateIssuerAsHeader","replicateSubjectAsHeader","_replicateSubjectAsHeader","replicateAudienceAsHeader","_replicateAudienceAsHeader","SignJWT","UnsecuredJWT","encodedHeader","jwtVerify","decodeProtectedHeader","protectedB64u","parts","generateSecret$1","substring","getModulusLengthOption","generateKeyPair$1","publicExponent","generateKeyPair","generateSecret","base64UrlDecode","base64UrlEncode"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,MAAMC,SAAN,SAAwBC,KAAxB,CAA8B;AAC1BC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,UAAMA,OAAN;AACA,SAAKC,IAAL,GAAYJ,SAAS,CAACI,IAAtB;AACA,SAAKC,IAAL,GAAY,KAAKH,WAAL,CAAiBG,IAA7B;;AACA,QAAIJ,KAAK,CAACK,iBAAV,EAA6B;AACzBL,MAAAA,KAAK,CAACK,iBAAN,CAAwB,IAAxB,EAA8B,KAAKJ,WAAnC;AACH;AACJ;;AARyB;;AAU9BF,SAAS,CAACI,IAAV,GAAiB,kBAAjB;;AACA,MAAMG,wBAAN,SAAuCP,SAAvC,CAAiD;AAC7CE,EAAAA,WAAW,CAACC,OAAD,EAAUK,KAAK,GAAG,aAAlB,EAAiCC,MAAM,GAAG,aAA1C,EAAyD;AAChE,UAAMN,OAAN;AACA,SAAKC,IAAL,GAAYG,wBAAwB,CAACH,IAArC;AACA,SAAKI,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACH;;AAN4C;;AAQjDF,wBAAwB,CAACH,IAAzB,GAAgC,iCAAhC;;AACA,MAAMM,iBAAN,SAAgCV,SAAhC,CAA0C;AACtCE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYM,iBAAiB,CAACN,IAA9B;AACH;;AAJqC;;AAM1CM,iBAAiB,CAACN,IAAlB,GAAyB,0BAAzB;;AACA,MAAMQ,gBAAN,SAA+BZ,SAA/B,CAAyC;AACrCE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYQ,gBAAgB,CAACR,IAA7B;AACH;;AAJoC;;AAMzCQ,gBAAgB,CAACR,IAAjB,GAAwB,wBAAxB;;AACA,MAAMS,mBAAN,SAAkCb,SAAlC,CAA4C;AACxCE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYS,mBAAmB,CAACT,IAAhC;AACA,SAAKD,OAAL,GAAe,6BAAf;AACH;;AALuC;;AAO5CU,mBAAmB,CAACT,IAApB,GAA2B,2BAA3B;;AACA,MAAMU,UAAN,SAAyBd,SAAzB,CAAmC;AAC/BE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYU,UAAU,CAACV,IAAvB;AACH;;AAJ8B;;AAMnCU,UAAU,CAACV,IAAX,GAAkB,iBAAlB;;AACA,MAAMW,UAAN,SAAyBf,SAAzB,CAAmC;AAC/BE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYW,UAAU,CAACX,IAAvB;AACH;;AAJ8B;;AAMnCW,UAAU,CAACX,IAAX,GAAkB,iBAAlB;;AACA,MAAMY,UAAN,SAAyBhB,SAAzB,CAAmC;AAC/BE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYY,UAAU,CAACZ,IAAvB;AACH;;AAJ8B;;AAMnCY,UAAU,CAACZ,IAAX,GAAkB,iBAAlB;;AACA,MAAMa,UAAN,SAAyBjB,SAAzB,CAAmC;AAC/BE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYa,UAAU,CAACb,IAAvB;AACH;;AAJ8B;;AAMnCa,UAAU,CAACb,IAAX,GAAkB,iBAAlB;;AACA,MAAMc,WAAN,SAA0BlB,SAA1B,CAAoC;AAChCE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYc,WAAW,CAACd,IAAxB;AACH;;AAJ+B;;AAMpCc,WAAW,CAACd,IAAZ,GAAmB,kBAAnB;;AACA,MAAMe,iBAAN,SAAgCnB,SAAhC,CAA0C;AACtCE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYe,iBAAiB,CAACf,IAA9B;AACA,SAAKD,OAAL,GAAe,iDAAf;AACH;;AALqC;;AAO1CgB,iBAAiB,CAACf,IAAlB,GAAyB,0BAAzB;;AACA,MAAMgB,wBAAN,SAAuCpB,SAAvC,CAAiD;AAC7CE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYgB,wBAAwB,CAAChB,IAArC;AACA,SAAKD,OAAL,GAAe,sDAAf;AACH;;AAL4C;;AAOjDiB,wBAAwB,CAAChB,IAAzB,GAAgC,iCAAhC;;AACA,MAAMiB,8BAAN,SAA6CrB,SAA7C,CAAuD;AACnDE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYiB,8BAA8B,CAACjB,IAA3C;AACA,SAAKD,OAAL,GAAe,+BAAf;AACH;;AALkD;;AAOvDkB,8BAA8B,CAACjB,IAA/B,GAAsC,uCAAtC;;AACA,MAAMkB,UAAN,SAAyBf,wBAAzB,CAAkD;AAC9CL,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGS,SAAT;AACA,SAAKP,IAAL,GAAYkB,UAAU,CAAClB,IAAvB;AACH;;AAJ6C;;AAMlDkB,UAAU,CAAClB,IAAX,GAAkB,iBAAlB;;AAEA,MAAMmB,UAAU,GAAG,CAAC,GAAGC,OAAJ,KAAgB;AAC/B,QAAMC,OAAO,GAAGD,OAAO,CAACE,MAAR,CAAeC,OAAf,CAAhB;;AACA,MAAIF,OAAO,CAACG,MAAR,KAAmB,CAAnB,IAAwBH,OAAO,CAACG,MAAR,KAAmB,CAA/C,EAAkD;AAC9C,WAAO,IAAP;AACH;;AACD,MAAIC,GAAJ;;AACA,OAAK,MAAMC,MAAX,IAAqBL,OAArB,EAA8B;AAC1B,UAAMM,UAAU,GAAGnC,MAAM,CAACoC,IAAP,CAAYF,MAAZ,CAAnB;;AACA,QAAI,CAACD,GAAD,IAAQA,GAAG,CAACI,IAAJ,KAAa,CAAzB,EAA4B;AACxBJ,MAAAA,GAAG,GAAG,IAAIK,GAAJ,CAAQH,UAAR,CAAN;AACA;AACH;;AACD,SAAK,MAAMI,SAAX,IAAwBJ,UAAxB,EAAoC;AAChC,UAAIF,GAAG,CAACO,GAAJ,CAAQD,SAAR,CAAJ,EAAwB;AACpB,eAAO,KAAP;AACH;;AACDN,MAAAA,GAAG,CAACQ,GAAJ,CAAQF,SAAR;AACH;AACJ;;AACD,SAAO,IAAP;AACH,CApBD;;AAsBA,SAASG,YAAT,CAAsBvC,KAAtB,EAA6B;AACzB,SAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA9C;AACH;;AACD,SAASwC,QAAT,CAAkBC,KAAlB,EAAyB;AACrB,MAAI,CAACF,YAAY,CAACE,KAAD,CAAb,IAAwB5C,MAAM,CAAC6C,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BH,KAA/B,MAA0C,iBAAtE,EAAyF;AACrF,WAAO,KAAP;AACH;;AACD,MAAI5C,MAAM,CAACgD,cAAP,CAAsBJ,KAAtB,MAAiC,IAArC,EAA2C;AACvC,WAAO,IAAP;AACH;;AACD,MAAIK,KAAK,GAAGL,KAAZ;;AACA,SAAO5C,MAAM,CAACgD,cAAP,CAAsBC,KAAtB,MAAiC,IAAxC,EAA8C;AAC1CA,IAAAA,KAAK,GAAGjD,MAAM,CAACgD,cAAP,CAAsBC,KAAtB,CAAR;AACH;;AACD,SAAOjD,MAAM,CAACgD,cAAP,CAAsBJ,KAAtB,MAAiCK,KAAxC;AACH;;AAED,MAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACA,MAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACA,MAAMC,SAAS,GAAG,KAAK,EAAvB;;AACA,SAASC,MAAT,CAAgB,GAAGC,OAAnB,EAA4B;AACxB,QAAMnB,IAAI,GAAGmB,OAAO,CAACC,MAAR,CAAe,CAACxB,GAAD,EAAM;AAAED,IAAAA;AAAF,GAAN,KAAqBC,GAAG,GAAGD,MAA1C,EAAkD,CAAlD,CAAb;AACA,QAAM0B,GAAG,GAAG,IAAIC,UAAJ,CAAetB,IAAf,CAAZ;AACA,MAAIuB,CAAC,GAAG,CAAR;AACAJ,EAAAA,OAAO,CAACK,OAAR,CAAiBC,MAAD,IAAY;AACxBJ,IAAAA,GAAG,CAACK,GAAJ,CAAQD,MAAR,EAAgBF,CAAhB;AACAA,IAAAA,CAAC,IAAIE,MAAM,CAAC9B,MAAZ;AACH,GAHD;AAIA,SAAO0B,GAAP;AACH;;AACD,SAASM,GAAT,CAAaC,GAAb,EAAkBC,QAAlB,EAA4B;AACxB,SAAOX,MAAM,CAACL,OAAO,CAACiB,MAAR,CAAeF,GAAf,CAAD,EAAsB,IAAIN,UAAJ,CAAe,CAAC,CAAD,CAAf,CAAtB,EAA2CO,QAA3C,CAAb;AACH;;AACD,SAASE,aAAT,CAAuBV,GAAvB,EAA4BvD,KAA5B,EAAmCkE,MAAnC,EAA2C;AACvC,MAAIlE,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAImD,SAA1B,EAAqC;AACjC,UAAM,IAAIgB,UAAJ,CAAgB,6BAA4BhB,SAAS,GAAG,CAAE,cAAanD,KAAM,EAA7E,CAAN;AACH;;AACDuD,EAAAA,GAAG,CAACK,GAAJ,CAAQ,CAAC5D,KAAK,KAAK,EAAX,EAAeA,KAAK,KAAK,EAAzB,EAA6BA,KAAK,KAAK,CAAvC,EAA0CA,KAAK,GAAG,IAAlD,CAAR,EAAiEkE,MAAjE;AACH;;AACD,SAASE,QAAT,CAAkBpE,KAAlB,EAAyB;AACrB,QAAMqE,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWvE,KAAK,GAAGmD,SAAnB,CAAb;AACA,QAAMqB,GAAG,GAAGxE,KAAK,GAAGmD,SAApB;AACA,QAAMI,GAAG,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAZ;AACAS,EAAAA,aAAa,CAACV,GAAD,EAAMc,IAAN,EAAY,CAAZ,CAAb;AACAJ,EAAAA,aAAa,CAACV,GAAD,EAAMiB,GAAN,EAAW,CAAX,CAAb;AACA,SAAOjB,GAAP;AACH;;AACD,SAASkB,QAAT,CAAkBzE,KAAlB,EAAyB;AACrB,QAAMuD,GAAG,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAZ;AACAS,EAAAA,aAAa,CAACV,GAAD,EAAMvD,KAAN,CAAb;AACA,SAAOuD,GAAP;AACH;;AACD,SAASmB,cAAT,CAAwBjC,KAAxB,EAA+B;AAC3B,SAAOW,MAAM,CAACqB,QAAQ,CAAChC,KAAK,CAACZ,MAAP,CAAT,EAAyBY,KAAzB,CAAb;AACH;;AACD,eAAekC,SAAf,CAAyBC,MAAzB,EAAiCC,MAAjC,EAAyCC,IAAzC,EAA+C9E,KAA/C,EAAsD;AAClD,QAAM+E,UAAU,GAAGT,IAAI,CAACU,IAAL,CAAU,CAACF,IAAI,IAAI,CAAT,IAAc,EAAxB,CAAnB;AACA,MAAIG,GAAJ;;AACA,OAAK,IAAIC,IAAI,GAAG,CAAhB,EAAmBA,IAAI,IAAIH,UAA3B,EAAuCG,IAAI,EAA3C,EAA+C;AAC3C,UAAM3B,GAAG,GAAG,IAAIC,UAAJ,CAAe,IAAIqB,MAAM,CAAChD,MAAX,GAAoB7B,KAAK,CAAC6B,MAAzC,CAAZ;AACA0B,IAAAA,GAAG,CAACK,GAAJ,CAAQa,QAAQ,CAACS,IAAD,CAAhB;AACA3B,IAAAA,GAAG,CAACK,GAAJ,CAAQiB,MAAR,EAAgB,CAAhB;AACAtB,IAAAA,GAAG,CAACK,GAAJ,CAAQ5D,KAAR,EAAe,IAAI6E,MAAM,CAAChD,MAA1B;;AACA,QAAI,CAACoD,GAAL,EAAU;AACNA,MAAAA,GAAG,GAAG,MAAML,MAAM,CAAC,QAAD,EAAWrB,GAAX,CAAlB;AACH,KAFD,MAGK;AACD0B,MAAAA,GAAG,GAAG7B,MAAM,CAAC6B,GAAD,EAAM,MAAML,MAAM,CAAC,QAAD,EAAWrB,GAAX,CAAlB,CAAZ;AACH;AACJ;;AACD0B,EAAAA,GAAG,GAAGA,GAAG,CAACE,KAAJ,CAAU,CAAV,EAAaL,IAAI,IAAI,CAArB,CAAN;AACA,SAAOG,GAAP;AACH;;AAED,SAASG,SAAT,GAAqB;AACjB,MAAI,OAAOC,UAAP,KAAsB,WAA1B,EACI,OAAOA,UAAP;AACJ,MAAI,OAAOC,IAAP,KAAgB,WAApB,EACI,OAAOA,IAAP;AACJ,MAAI,OAAOC,MAAP,KAAkB,WAAtB,EACI,OAAOA,MAAP;AACJ,QAAM,IAAIrF,KAAJ,CAAU,gCAAV,CAAN;AACH;;AACD,IAAIsF,YAAY,GAAGJ,SAAS,EAA5B;;AAEA,MAAMK,QAAQ,GAAIhD,KAAD,IAAW;AACxB,MAAIiD,SAAS,GAAGjD,KAAhB;;AACA,MAAI,OAAOiD,SAAP,KAAqB,QAAzB,EAAmC;AAC/BA,IAAAA,SAAS,GAAG3C,OAAO,CAACiB,MAAR,CAAe0B,SAAf,CAAZ;AACH;;AACD,QAAMC,UAAU,GAAG,MAAnB;AACA,QAAMC,GAAG,GAAG,EAAZ;;AACA,OAAK,IAAInC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiC,SAAS,CAAC7D,MAA9B,EAAsC4B,CAAC,IAAIkC,UAA3C,EAAuD;AACnDC,IAAAA,GAAG,CAACC,IAAJ,CAASC,MAAM,CAACC,YAAP,CAAoBC,KAApB,CAA0B,IAA1B,EAAgCN,SAAS,CAACO,QAAV,CAAmBxC,CAAnB,EAAsBA,CAAC,GAAGkC,UAA1B,CAAhC,CAAT;AACH;;AACD,QAAMO,YAAY,GAAGV,YAAY,CAACW,IAAb,CAAkBP,GAAG,CAACQ,IAAJ,CAAS,EAAT,CAAlB,CAArB;AACA,SAAOF,YAAY,CAACG,OAAb,CAAqB,IAArB,EAA2B,EAA3B,EAA+BA,OAA/B,CAAuC,KAAvC,EAA8C,GAA9C,EAAmDA,OAAnD,CAA2D,KAA3D,EAAkE,GAAlE,CAAP;AACH,CAZD;;AAaA,MAAMC,QAAQ,GAAI7D,KAAD,IAAW;AACxB,MAAI8D,OAAO,GAAG9D,KAAd;;AACA,MAAI8D,OAAO,YAAY/C,UAAvB,EAAmC;AAC/B+C,IAAAA,OAAO,GAAGtD,OAAO,CAACuD,MAAR,CAAeD,OAAf,CAAV;AACH;;AACDA,EAAAA,OAAO,GAAGA,OAAO,CAACF,OAAR,CAAgB,IAAhB,EAAsB,GAAtB,EAA2BA,OAA3B,CAAmC,IAAnC,EAAyC,GAAzC,EAA8CA,OAA9C,CAAsD,KAAtD,EAA6D,EAA7D,CAAV;;AACA,MAAI;AACA,WAAO,IAAI7C,UAAJ,CAAegC,YAAY,CAC7BiB,IADiB,CACZF,OADY,EAEjBG,KAFiB,CAEX,EAFW,EAGjBC,GAHiB,CAGZC,CAAD,IAAOA,CAAC,CAACC,UAAF,CAAa,CAAb,CAHM,CAAf,CAAP;AAIH,GALD,CAMA,OAAOC,EAAP,EAAW;AACP,UAAM,IAAIC,SAAJ,CAAc,mDAAd,CAAN;AACH;AACJ,CAfD;;AAiBA,MAAMC,YAAY,GAAG,IAAIC,GAAJ,CAAQ,CACzB,CAAC,eAAD,EAAkB,GAAlB,CADyB,EAEzB,CAAC,SAAD,EAAY,EAAZ,CAFyB,EAGzB,CAAC,WAAD,EAAc,EAAd,CAHyB,EAIzB,CAAC,eAAD,EAAkB,GAAlB,CAJyB,EAKzB,CAAC,SAAD,EAAY,EAAZ,CALyB,EAMzB,CAAC,WAAD,EAAc,EAAd,CANyB,EAOzB,CAAC,eAAD,EAAkB,GAAlB,CAPyB,EAQzB,CAAC,SAAD,EAAY,EAAZ,CARyB,EASzB,CAAC,WAAD,EAAc,EAAd,CATyB,CAAR,CAArB;;AAWA,MAAMC,SAAS,GAAIC,MAAD,IAAarD,GAAD,IAAS;AACnC,QAAMsD,SAAS,GAAGJ,YAAY,CAACK,GAAb,CAAiBvD,GAAjB,CAAlB;;AACA,MAAI,CAACsD,SAAL,EAAgB;AACZ,UAAM,IAAIvG,gBAAJ,CAAsB,8BAA6BiD,GAAI,EAAvD,CAAN;AACH;;AACD,SAAOqD,MAAM,CAAC,IAAI3D,UAAJ,CAAe4D,SAAS,IAAI,CAA5B,CAAD,CAAb;AACH,CAND;;AAQA,MAAME,aAAa,GAAG,CAACC,GAAD,EAAMC,EAAN,KAAa;AAC/B,MAAIA,EAAE,CAAC3F,MAAH,IAAa,CAAb,KAAmBmF,YAAY,CAACK,GAAb,CAAiBE,GAAjB,CAAvB,EAA8C;AAC1C,UAAM,IAAIxG,UAAJ,CAAe,sCAAf,CAAN;AACH;AACJ,CAJD;;AAMA,MAAM0G,cAAc,GAAG,CAACF,GAAD,EAAMG,GAAN,KAAc;AACjC,MAAIC,QAAJ;;AACA,UAAQJ,GAAR;AACI,SAAK,eAAL;AACA,SAAK,eAAL;AACA,SAAK,eAAL;AACII,MAAAA,QAAQ,GAAGC,QAAQ,CAACL,GAAG,CAACM,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB,EAAjB,CAAnB;;AACA,UAAI,EAAEH,GAAG,YAAYlE,UAAjB,CAAJ,EAAkC;AAC9B,cAAM,IAAIuD,SAAJ,CAAe,GAAEQ,GAAI,sDAArB,CAAN;AACH;;AACD;;AACJ,SAAK,SAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACII,MAAAA,QAAQ,GAAGC,QAAQ,CAACL,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAD,EAAmB,EAAnB,CAAnB;AACA;;AACJ;AACI,YAAM,IAAIhH,gBAAJ,CAAsB,gCAA+B0G,GAAI,6DAAzD,CAAN;AAfR;;AAiBA,MAAIG,GAAG,YAAYlE,UAAnB,EAA+B;AAC3B,QAAIkE,GAAG,CAAC7F,MAAJ,IAAc,CAAd,KAAoB8F,QAAxB,EAAkC;AAC9B,YAAM,IAAI5G,UAAJ,CAAe,uCAAf,CAAN;AACH;;AACD;AACH;;AACD,MAAI2G,GAAG,CAACI,SAAJ,KAAkBC,SAAtB,EAAiC;AAC7B,UAAM;AAAElG,MAAAA;AAAF,QAAa6F,GAAG,CAACI,SAAvB;;AACA,QAAIjG,MAAM,KAAK8F,QAAf,EAAyB;AACrB,YAAM,IAAI5G,UAAJ,CAAe,uCAAf,CAAN;AACH;;AACD;AACH;;AACD,QAAM,IAAIgG,SAAJ,CAAc,qCAAd,CAAN;AACH,CAjCD;;AAmCA,MAAMiB,eAAe,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC9B,MAAI,EAAED,CAAC,YAAYzE,UAAf,CAAJ,EAAgC;AAC5B,UAAM,IAAIuD,SAAJ,CAAc,iCAAd,CAAN;AACH;;AACD,MAAI,EAAEmB,CAAC,YAAY1E,UAAf,CAAJ,EAAgC;AAC5B,UAAM,IAAIuD,SAAJ,CAAc,kCAAd,CAAN;AACH;;AACD,MAAIkB,CAAC,CAACpG,MAAF,KAAaqG,CAAC,CAACrG,MAAnB,EAA2B;AACvB,UAAM,IAAIkF,SAAJ,CAAc,yCAAd,CAAN;AACH;;AACD,QAAMoB,GAAG,GAAGF,CAAC,CAACpG,MAAd;AACA,MAAIuG,GAAG,GAAG,CAAV;AACA,MAAI3E,CAAC,GAAG,CAAC,CAAT;;AACA,SAAO,EAAEA,CAAF,GAAM0E,GAAb,EAAkB;AACdC,IAAAA,GAAG,IAAIH,CAAC,CAACxE,CAAD,CAAD,GAAOyE,CAAC,CAACzE,CAAD,CAAf;AACH;;AACD,SAAO2E,GAAG,KAAK,CAAf;AACH,CAjBD;;AAmBA,IAAIC,MAAM,GAAG7C,YAAY,CAAC6C,MAA1B;;AACA,SAASC,WAAT,CAAqBC,GAArB,EAA0B;AACtB,MAAI,OAAO/C,YAAY,CAACgD,SAApB,KAAkC,WAAtC,EAAmD;AAC/C,WAAO,KAAP;AACH;;AACD,SAAOD,GAAG,IAAI,IAAP,IAAeA,GAAG,YAAY/C,YAAY,CAACgD,SAAlD;AACH;;AAED,eAAeC,UAAf,CAA0BlB,GAA1B,EAA+BG,GAA/B,EAAoCgB,UAApC,EAAgDlB,EAAhD,EAAoDmB,GAApD,EAAyDC,GAAzD,EAA8D;AAC1D,QAAMC,OAAO,GAAGjB,QAAQ,CAACL,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAD,EAAmB,EAAnB,CAAxB;AACA,QAAMiB,MAAM,GAAG,MAAMT,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAAG,CAACzB,QAAJ,CAAa4C,OAAO,IAAI,CAAxB,CAA/B,EAA2D,SAA3D,EAAsE,KAAtE,EAA6E,CAAC,SAAD,CAA7E,CAArB;AACA,QAAMI,MAAM,GAAG,MAAMZ,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAAG,CAACzB,QAAJ,CAAa,CAAb,EAAgB4C,OAAO,IAAI,CAA3B,CAA/B,EAA8D;AAC/EK,IAAAA,IAAI,EAAE;AAAE5I,MAAAA,IAAI,EAAG,OAAMuI,OAAO,IAAI,CAAE;AAA5B,KADyE;AAE/EvI,IAAAA,IAAI,EAAE;AAFyE,GAA9D,EAGlB,KAHkB,EAGX,CAAC,MAAD,CAHW,CAArB;AAIA,QAAM6I,OAAO,GAAG/F,MAAM,CAACwF,GAAD,EAAMpB,EAAN,EAAUkB,UAAV,EAAsBtE,QAAQ,CAACwE,GAAG,CAAC/G,MAAJ,IAAc,CAAf,CAA9B,CAAtB;AACA,QAAMuH,WAAW,GAAG,IAAI5F,UAAJ,CAAe,CAAC,MAAM6E,MAAM,CAACU,MAAP,CAAcM,IAAd,CAAmB,MAAnB,EAA2BJ,MAA3B,EAAmCE,OAAnC,CAAP,EAAoDhE,KAApD,CAA0D,CAA1D,EAA6D0D,OAAO,IAAI,CAAxE,CAAf,CAApB;AACA,MAAIS,cAAJ;;AACA,MAAI;AACAA,IAAAA,cAAc,GAAGtB,eAAe,CAACW,GAAD,EAAMS,WAAN,CAAhC;AACH,GAFD,CAGA,OAAOtC,EAAP,EAAW,CACV;;AACD,MAAI,CAACwC,cAAL,EAAqB;AACjB,UAAM,IAAIxI,mBAAJ,EAAN;AACH;;AACD,MAAIyI,SAAJ;;AACA,MAAI;AACAA,IAAAA,SAAS,GAAG,IAAI/F,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcS,OAAd,CAAsB;AAAEhC,MAAAA,EAAF;AAAMlH,MAAAA,IAAI,EAAE;AAAZ,KAAtB,EAA+CwI,MAA/C,EAAuDJ,UAAvD,CAArB,CAAZ;AACH,GAFD,CAGA,OAAOe,EAAP,EAAW,CACV;;AACD,MAAI,CAACF,SAAL,EAAgB;AACZ,UAAM,IAAIzI,mBAAJ,EAAN;AACH;;AACD,SAAOyI,SAAP;AACH;;AACD,eAAeG,UAAf,CAA0BhC,GAA1B,EAA+BgB,UAA/B,EAA2ClB,EAA3C,EAA+CmB,GAA/C,EAAoDC,GAApD,EAAyD;AACrD,QAAME,MAAM,GAAGpB,GAAG,YAAYlE,UAAf,GACT,MAAM6E,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAA/B,EAAoC,SAApC,EAA+C,KAA/C,EAAsD,CAAC,SAAD,CAAtD,CADG,GAETA,GAFN;;AAGA,MAAI;AACA,WAAO,IAAIlE,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcS,OAAd,CAAsB;AAC9CG,MAAAA,cAAc,EAAEf,GAD8B;AAE9CpB,MAAAA,EAF8C;AAG9ClH,MAAAA,IAAI,EAAE,SAHwC;AAI9CsJ,MAAAA,SAAS,EAAE;AAJmC,KAAtB,EAKzBd,MALyB,EAKjB1F,MAAM,CAACsF,UAAD,EAAaC,GAAb,CALW,CAArB,CAAP;AAMH,GAPD,CAQA,OAAOkB,GAAP,EAAY;AACR,UAAM,IAAI/I,mBAAJ,EAAN;AACH;AACJ;;AACD,MAAMgJ,SAAS,GAAG,OAAOvC,GAAP,EAAYG,GAAZ,EAAiBgB,UAAjB,EAA6BlB,EAA7B,EAAiCmB,GAAjC,EAAsCC,GAAtC,KAA8C;AAC5D,MAAI,CAACN,WAAW,CAACZ,GAAD,CAAZ,IAAqB,EAAEA,GAAG,YAAYlE,UAAjB,CAAzB,EAAuD;AACnD,UAAM,IAAIuD,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACDU,EAAAA,cAAc,CAACF,GAAD,EAAMG,GAAN,CAAd;AACAJ,EAAAA,aAAa,CAACC,GAAD,EAAMC,EAAN,CAAb;;AACA,MAAID,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAc,CAAd,MAAqB,KAAzB,EAAgC;AAC5B,WAAOY,UAAU,CAAClB,GAAD,EAAMG,GAAN,EAAWgB,UAAX,EAAuBlB,EAAvB,EAA2BmB,GAA3B,EAAgCC,GAAhC,CAAjB;AACH;;AACD,SAAOc,UAAU,CAAChC,GAAD,EAAMgB,UAAN,EAAkBlB,EAAlB,EAAsBmB,GAAtB,EAA2BC,GAA3B,CAAjB;AACH,CAVD;;AAYA,MAAMmB,OAAO,GAAG,YAAY;AACxB,QAAM,IAAIlJ,gBAAJ,CAAqB,sNAArB,CAAN;AACH,CAFD;;AAGA,MAAMmJ,OAAO,GAAG,YAAY;AACxB,QAAM,IAAInJ,gBAAJ,CAAqB,iGAArB,CAAN;AACH,CAFD;;AAIA,MAAMoJ,cAAc,GAAG,CACnB;AAAEf,EAAAA,IAAI,EAAE;AAAE5I,IAAAA,IAAI,EAAE;AAAR,GAAR;AAA6BA,EAAAA,IAAI,EAAE;AAAnC,CADmB,EAEnB,IAFmB,EAGnB,CAAC,MAAD,CAHmB,CAAvB;;AAMA,SAAS4J,YAAT,CAAsB3B,GAAtB,EAA2BzE,GAA3B,EAAgC;AAC5B,MAAIyE,GAAG,CAACT,SAAJ,CAAcjG,MAAd,KAAyB+F,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAD,EAAmB,EAAnB,CAArC,EAA6D;AACzD,UAAM,IAAId,SAAJ,CAAe,6BAA4BjD,GAAI,EAA/C,CAAN;AACH;AACJ;;AACD,SAASqG,cAAT,CAAwB5B,GAAxB,EAA6B6B,KAA7B,EAAoC;AAChC,MAAI9B,WAAW,CAACC,GAAD,CAAf,EAAsB;AAClB,WAAOA,GAAP;AACH;;AACD,MAAIA,GAAG,YAAY/E,UAAnB,EAA+B;AAC3B,WAAO6E,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BT,GAA/B,EAAoC,QAApC,EAA8C,IAA9C,EAAoD,CAAC6B,KAAD,CAApD,CAAP;AACH;;AACD,QAAM,IAAIrD,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,MAAMsD,MAAM,GAAG,OAAOvG,GAAP,EAAYyE,GAAZ,EAAiBb,GAAjB,KAAyB;AACpC,QAAM4C,SAAS,GAAG,MAAMH,cAAc,CAAC5B,GAAD,EAAM,SAAN,CAAtC;AACA2B,EAAAA,YAAY,CAACI,SAAD,EAAYxG,GAAZ,CAAZ;AACA,QAAMyG,YAAY,GAAG,MAAMlC,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAA/B,EAAoC,GAAGuC,cAAvC,CAA3B;AACA,SAAO,IAAIzG,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcyB,OAAd,CAAsB,KAAtB,EAA6BD,YAA7B,EAA2CD,SAA3C,EAAsD,QAAtD,CAArB,CAAP;AACH,CALD;;AAMA,MAAMG,QAAQ,GAAG,OAAO3G,GAAP,EAAYyE,GAAZ,EAAiBmC,YAAjB,KAAkC;AAC/C,QAAMJ,SAAS,GAAG,MAAMH,cAAc,CAAC5B,GAAD,EAAM,WAAN,CAAtC;AACA2B,EAAAA,YAAY,CAACI,SAAD,EAAYxG,GAAZ,CAAZ;AACA,QAAMyG,YAAY,GAAG,MAAMlC,MAAM,CAACU,MAAP,CAAc4B,SAAd,CAAwB,KAAxB,EAA+BD,YAA/B,EAA6CJ,SAA7C,EAAwD,QAAxD,EAAkE,GAAGL,cAArE,CAA3B;AACA,SAAO,IAAIzG,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAc6B,SAAd,CAAwB,KAAxB,EAA+BL,YAA/B,CAArB,CAAP;AACH,CALD;;AAOA,MAAM3F,MAAM,GAAG,OAAOkD,SAAP,EAAkB+C,IAAlB,KAA2B;AACtC,QAAMC,YAAY,GAAI,OAAMhD,SAAS,CAACD,MAAV,CAAiB,CAAC,CAAlB,CAAqB,EAAjD;AACA,SAAO,IAAIrE,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcnE,MAAd,CAAqBkG,YAArB,EAAmCD,IAAnC,CAArB,CAAP;AACH,CAHD;;AAKA,MAAME,SAAS,GAAG,OAAOC,SAAP,EAAkBC,UAAlB,EAA8BnD,SAA9B,EAAyCoD,SAAzC,EAAoDC,GAAG,GAAG,IAAI3H,UAAJ,CAAe,CAAf,CAA1D,EAA6E4H,GAAG,GAAG,IAAI5H,UAAJ,CAAe,CAAf,CAAnF,KAAyG;AACvH,MAAI,CAAC8E,WAAW,CAAC0C,SAAD,CAAhB,EAA6B;AACzB,UAAM,IAAIjE,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,MAAI,CAACuB,WAAW,CAAC2C,UAAD,CAAhB,EAA8B;AAC1B,UAAM,IAAIlE,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,QAAM/G,KAAK,GAAGoD,MAAM,CAACsB,cAAc,CAAC3B,OAAO,CAACiB,MAAR,CAAe8D,SAAf,CAAD,CAAf,EAA4CpD,cAAc,CAACyG,GAAD,CAA1D,EAAiEzG,cAAc,CAAC0G,GAAD,CAA/E,EAAsF3G,QAAQ,CAACyG,SAAD,CAA9F,CAApB;;AACA,MAAI,CAACD,UAAU,CAACI,MAAX,CAAkBC,QAAlB,CAA2B,YAA3B,CAAL,EAA+C;AAC3C,UAAM,IAAIvE,SAAJ,CAAc,wDAAd,CAAN;AACH;;AACD,QAAMwE,YAAY,GAAG,IAAI/H,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcyC,UAAd,CAAyB;AAC/DlL,IAAAA,IAAI,EAAE,MADyD;AAE/DmL,IAAAA,MAAM,EAAET;AAFuD,GAAzB,EAGvCC,UAHuC,EAG3B3G,IAAI,CAACU,IAAL,CAAU4C,QAAQ,CAACqD,UAAU,CAACnD,SAAX,CAAqB4D,UAArB,CAAgC7D,MAAhC,CAAuC,CAAC,CAAxC,CAAD,EAA6C,EAA7C,CAAR,GAA2D,CAArE,KACX,CAJsC,CAArB,CAArB;AAKA,SAAOlD,SAAS,CAACC,MAAD,EAAS2G,YAAT,EAAuBL,SAAvB,EAAkClL,KAAlC,CAAhB;AACH,CAjBD;;AAkBA,MAAM2L,WAAW,GAAG,MAAOpD,GAAP,IAAe;AAC/B,MAAI,CAACD,WAAW,CAACC,GAAD,CAAhB,EAAuB;AACnB,UAAM,IAAIxB,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,SAAO,CAAC,MAAMsB,MAAM,CAACU,MAAP,CAAc6C,WAAd,CAA0B;AAAEtL,IAAAA,IAAI,EAAE,MAAR;AAAgBoL,IAAAA,UAAU,EAAEnD,GAAG,CAACT,SAAJ,CAAc4D;AAA1C,GAA1B,EAAkF,IAAlF,EAAwF,CAAC,YAAD,CAAxF,CAAP,EAAgHT,UAAvH;AACH,CALD;;AAMA,MAAMY,WAAW,GAAItD,GAAD,IAAS;AACzB,MAAI,CAACD,WAAW,CAACC,GAAD,CAAhB,EAAuB;AACnB,UAAM,IAAIxB,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,SAAO,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,EAA4BuE,QAA5B,CAAqC/C,GAAG,CAACT,SAAJ,CAAc4D,UAAnD,CAAP;AACH,CALD;;AAOA,MAAMI,QAAQ,GAAGzD,MAAM,CAAC0D,eAAP,CAAuBC,IAAvB,CAA4B3D,MAA5B,CAAjB;;AAEA,SAAS4D,QAAT,CAAkBpI,GAAlB,EAAuB;AACnB,MAAI,EAAEA,GAAG,YAAYL,UAAjB,KAAgCK,GAAG,CAAChC,MAAJ,GAAa,CAAjD,EAAoD;AAChD,UAAM,IAAId,UAAJ,CAAe,2CAAf,CAAN;AACH;AACJ;;AAED,SAASmL,cAAT,CAAwB3D,GAAxB,EAA6B;AACzB,MAAIA,GAAG,YAAY/E,UAAnB,EAA+B;AAC3B,WAAO6E,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BT,GAA/B,EAAoC,QAApC,EAA8C,KAA9C,EAAqD,CAAC,YAAD,CAArD,CAAP;AACH;;AACD,MAAID,WAAW,CAACC,GAAD,CAAf,EAAsB;AAClB,WAAOA,GAAP;AACH;;AACD,QAAM,IAAIxB,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,MAAMoF,SAAS,GAAG,OAAOrI,GAAP,EAAYyE,GAAZ,EAAiBb,GAAjB,EAAsB0E,GAAG,GAAG9H,IAAI,CAACC,KAAL,CAAWD,IAAI,CAAC6C,MAAL,KAAgB,IAA3B,IAAmC,IAA/D,EAAqEkF,KAAK,GAAGP,QAAQ,CAAC,IAAItI,UAAJ,CAAe,EAAf,CAAD,CAArF,KAA8G;AAC5HyI,EAAAA,QAAQ,CAACI,KAAD,CAAR;AACA,QAAMC,IAAI,GAAGzI,GAAG,CAACC,GAAD,EAAMuI,KAAN,CAAhB;AACA,QAAME,MAAM,GAAG3E,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,EAAX,EAAe,CAAf,CAAD,EAAoB,EAApB,CAAvB;AACA,QAAM2E,SAAS,GAAG;AACdtD,IAAAA,IAAI,EAAE;AAAE5I,MAAAA,IAAI,EAAG,OAAMwD,GAAG,CAAC+D,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAiB;AAAhC,KADQ;AAEd9C,IAAAA,UAAU,EAAEqH,GAFE;AAGd9L,IAAAA,IAAI,EAAE,QAHQ;AAIdgM,IAAAA;AAJc,GAAlB;AAMA,QAAMG,OAAO,GAAG;AACZ5K,IAAAA,MAAM,EAAE0K,MADI;AAEZjM,IAAAA,IAAI,EAAE;AAFM,GAAhB;AAIA,QAAMgK,SAAS,GAAG,MAAM4B,cAAc,CAAC3D,GAAD,CAAtC;AACA,MAAImE,OAAJ;;AACA,MAAIpC,SAAS,CAACe,MAAV,CAAiBC,QAAjB,CAA0B,YAA1B,CAAJ,EAA6C;AACzCoB,IAAAA,OAAO,GAAG,IAAIlJ,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcyC,UAAd,CAAyBgB,SAAzB,EAAoClC,SAApC,EAA+CiC,MAA/C,CAArB,CAAV;AACH,GAFD,MAGK,IAAIjC,SAAS,CAACe,MAAV,CAAiBC,QAAjB,CAA0B,WAA1B,CAAJ,EAA4C;AAC7CoB,IAAAA,OAAO,GAAG,MAAMrE,MAAM,CAACU,MAAP,CAAcgC,SAAd,CAAwByB,SAAxB,EAAmClC,SAAnC,EAA8CmC,OAA9C,EAAuD,KAAvD,EAA8D,CAAC,SAAD,CAA9D,CAAhB;AACH,GAFI,MAGA;AACD,UAAM,IAAI1F,SAAJ,CAAc,8DAAd,CAAN;AACH;;AACD,QAAM2D,YAAY,GAAG,MAAML,MAAM,CAACvG,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB6E,OAAjB,EAA0BhF,GAA1B,CAAjC;AACA,SAAO;AAAEgD,IAAAA,YAAF;AAAgB0B,IAAAA,GAAhB;AAAqBvI,IAAAA,GAAG,EAAE4B,QAAQ,CAAC4G,KAAD;AAAlC,GAAP;AACH,CA3BD;;AA4BA,MAAMM,SAAS,GAAG,OAAO7I,GAAP,EAAYyE,GAAZ,EAAiBmC,YAAjB,EAA+B0B,GAA/B,EAAoCC,KAApC,KAA8C;AAC5DJ,EAAAA,QAAQ,CAACI,KAAD,CAAR;AACA,QAAMC,IAAI,GAAGzI,GAAG,CAACC,GAAD,EAAMuI,KAAN,CAAhB;AACA,QAAME,MAAM,GAAG3E,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,EAAX,EAAe,CAAf,CAAD,EAAoB,EAApB,CAAvB;AACA,QAAM2E,SAAS,GAAG;AACdtD,IAAAA,IAAI,EAAE;AAAE5I,MAAAA,IAAI,EAAG,OAAMwD,GAAG,CAAC+D,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAiB;AAAhC,KADQ;AAEd9C,IAAAA,UAAU,EAAEqH,GAFE;AAGd9L,IAAAA,IAAI,EAAE,QAHQ;AAIdgM,IAAAA;AAJc,GAAlB;AAMA,QAAMG,OAAO,GAAG;AACZ5K,IAAAA,MAAM,EAAE0K,MADI;AAEZjM,IAAAA,IAAI,EAAE;AAFM,GAAhB;AAIA,QAAMgK,SAAS,GAAG,MAAM4B,cAAc,CAAC3D,GAAD,CAAtC;AACA,MAAImE,OAAJ;;AACA,MAAIpC,SAAS,CAACe,MAAV,CAAiBC,QAAjB,CAA0B,YAA1B,CAAJ,EAA6C;AACzCoB,IAAAA,OAAO,GAAG,IAAIlJ,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcyC,UAAd,CAAyBgB,SAAzB,EAAoClC,SAApC,EAA+CiC,MAA/C,CAArB,CAAV;AACH,GAFD,MAGK,IAAIjC,SAAS,CAACe,MAAV,CAAiBC,QAAjB,CAA0B,WAA1B,CAAJ,EAA4C;AAC7CoB,IAAAA,OAAO,GAAG,MAAMrE,MAAM,CAACU,MAAP,CAAcgC,SAAd,CAAwByB,SAAxB,EAAmClC,SAAnC,EAA8CmC,OAA9C,EAAuD,KAAvD,EAA8D,CAAC,WAAD,CAA9D,CAAhB;AACH,GAFI,MAGA;AACD,UAAM,IAAI1F,SAAJ,CAAc,8DAAd,CAAN;AACH;;AACD,SAAO0D,QAAQ,CAAC3G,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB6E,OAAjB,EAA0BhC,YAA1B,CAAf;AACH,CA1BD;;AA4BA,SAASkC,WAAT,CAAqB9I,GAArB,EAA0B;AACtB,UAAQA,GAAR;AACI,SAAK,UAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AACI,aAAO,UAAP;;AACJ;AACI,YAAM,IAAIjD,gBAAJ,CAAsB,OAAMiD,GAAI,6DAAhC,CAAN;AAPR;AASH;;AAED,IAAI+I,cAAc,GAAG,CAAC/I,GAAD,EAAMyE,GAAN,KAAc;AAC/B,MAAIzE,GAAG,CAACgJ,UAAJ,CAAe,IAAf,CAAJ,EAA0B;AACtB,UAAMC,MAAM,GAAGnF,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB,EAAjB,CAAvB;AACA,UAAM;AAAEhG,MAAAA;AAAF,QAAa0G,GAAG,CAACT,SAAvB;;AACA,QAAI,OAAOjG,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,GAAGkL,MAA3C,EAAmD;AAC/C,YAAM,IAAIhG,SAAJ,CAAe,GAAEjD,GAAI,kCAAiCiJ,MAAO,iBAA7D,CAAN;AACH;AACJ;;AACD,MAAIjJ,GAAG,CAACgJ,UAAJ,CAAe,IAAf,KAAwBhJ,GAAG,CAACgJ,UAAJ,CAAe,IAAf,CAA5B,EAAkD;AAC9C,UAAM;AAAEE,MAAAA;AAAF,QAAoBzE,GAAG,CAACT,SAA9B;;AACA,QAAI,OAAOkF,aAAP,KAAyB,QAAzB,IAAqCA,aAAa,GAAG,IAAzD,EAA+D;AAC3D,YAAM,IAAIjG,SAAJ,CAAe,GAAEjD,GAAI,uDAArB,CAAN;AACH;AACJ;AACJ,CAdD;;AAgBA,MAAMmJ,SAAS,GAAG,OAAOnJ,GAAP,EAAYyE,GAAZ,EAAiBb,GAAjB,KAAyB;AACvC,MAAI,CAACY,WAAW,CAACC,GAAD,CAAhB,EAAuB;AACnB,UAAM,IAAIxB,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD8F,EAAAA,cAAc,CAAC/I,GAAD,EAAMyE,GAAN,CAAd;;AACA,MAAIA,GAAG,CAAC8C,MAAJ,CAAWC,QAAX,CAAoB,SAApB,CAAJ,EAAoC;AAChC,WAAO,IAAI9H,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcmE,OAAd,CAAsBN,WAAW,CAAC9I,GAAD,CAAjC,EAAwCyE,GAAxC,EAA6Cb,GAA7C,CAArB,CAAP;AACH;;AACD,MAAIa,GAAG,CAAC8C,MAAJ,CAAWC,QAAX,CAAoB,SAApB,CAAJ,EAAoC;AAChC,UAAMf,YAAY,GAAG,MAAMlC,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAA/B,EAAoC,GAAGuC,cAAvC,CAA3B;AACA,WAAO,IAAIzG,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcyB,OAAd,CAAsB,KAAtB,EAA6BD,YAA7B,EAA2ChC,GAA3C,EAAgDqE,WAAW,CAAC9I,GAAD,CAA3D,CAArB,CAAP;AACH;;AACD,QAAM,IAAIiD,SAAJ,CAAc,8EAAd,CAAN;AACH,CAbD;;AAcA,MAAMyC,OAAO,GAAG,OAAO1F,GAAP,EAAYyE,GAAZ,EAAiBmC,YAAjB,KAAkC;AAC9C,MAAI,CAACpC,WAAW,CAACC,GAAD,CAAhB,EAAuB;AACnB,UAAM,IAAIxB,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD8F,EAAAA,cAAc,CAAC/I,GAAD,EAAMyE,GAAN,CAAd;;AACA,MAAIA,GAAG,CAAC8C,MAAJ,CAAWC,QAAX,CAAoB,SAApB,CAAJ,EAAoC;AAChC,WAAO,IAAI9H,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcS,OAAd,CAAsBoD,WAAW,CAAC9I,GAAD,CAAjC,EAAwCyE,GAAxC,EAA6CmC,YAA7C,CAArB,CAAP;AACH;;AACD,MAAInC,GAAG,CAAC8C,MAAJ,CAAWC,QAAX,CAAoB,WAApB,CAAJ,EAAsC;AAClC,UAAMf,YAAY,GAAG,MAAMlC,MAAM,CAACU,MAAP,CAAc4B,SAAd,CAAwB,KAAxB,EAA+BD,YAA/B,EAA6CnC,GAA7C,EAAkDqE,WAAW,CAAC9I,GAAD,CAA7D,EAAoE,GAAGmG,cAAvE,CAA3B;AACA,WAAO,IAAIzG,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAc6B,SAAd,CAAwB,KAAxB,EAA+BL,YAA/B,CAArB,CAAP;AACH;;AACD,QAAM,IAAIxD,SAAJ,CAAc,gFAAd,CAAN;AACH,CAbD;;AAeA,eAAeoG,UAAf,CAA0B5F,GAA1B,EAA+BgC,SAA/B,EAA0C7B,GAA1C,EAA+CF,EAA/C,EAAmDoB,GAAnD,EAAwD;AACpD,QAAMC,OAAO,GAAGjB,QAAQ,CAACL,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAD,EAAmB,EAAnB,CAAxB;AACA,QAAMiB,MAAM,GAAG,MAAMT,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAAG,CAACzB,QAAJ,CAAa4C,OAAO,IAAI,CAAxB,CAA/B,EAA2D,SAA3D,EAAsE,KAAtE,EAA6E,CAAC,SAAD,CAA7E,CAArB;AACA,QAAMI,MAAM,GAAG,MAAMZ,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAAG,CAACzB,QAAJ,CAAa,CAAb,EAAgB4C,OAAO,IAAI,CAA3B,CAA/B,EAA8D;AAC/EK,IAAAA,IAAI,EAAE;AAAE5I,MAAAA,IAAI,EAAG,OAAMuI,OAAO,IAAI,CAAE;AAA5B,KADyE;AAE/EvI,IAAAA,IAAI,EAAE;AAFyE,GAA9D,EAGlB,KAHkB,EAGX,CAAC,MAAD,CAHW,CAArB;AAIA,QAAMoI,UAAU,GAAG,IAAIlF,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcmE,OAAd,CAAsB;AAC1D1F,IAAAA,EAD0D;AAE1DlH,IAAAA,IAAI,EAAE;AAFoD,GAAtB,EAGrCwI,MAHqC,EAG7BS,SAH6B,CAArB,CAAnB;AAIA,QAAMJ,OAAO,GAAG/F,MAAM,CAACwF,GAAD,EAAMpB,EAAN,EAAUkB,UAAV,EAAsBtE,QAAQ,CAACwE,GAAG,CAAC/G,MAAJ,IAAc,CAAf,CAA9B,CAAtB;AACA,QAAM8G,GAAG,GAAG,IAAInF,UAAJ,CAAe,CAAC,MAAM6E,MAAM,CAACU,MAAP,CAAcM,IAAd,CAAmB,MAAnB,EAA2BJ,MAA3B,EAAmCE,OAAnC,CAAP,EAAoDhE,KAApD,CAA0D,CAA1D,EAA6D0D,OAAO,IAAI,CAAxE,CAAf,CAAZ;AACA,SAAO;AAAEH,IAAAA,UAAF;AAAcC,IAAAA;AAAd,GAAP;AACH;;AACD,eAAeyE,UAAf,CAA0B7D,SAA1B,EAAqC7B,GAArC,EAA0CF,EAA1C,EAA8CoB,GAA9C,EAAmD;AAC/C,QAAME,MAAM,GAAGpB,GAAG,YAAYlE,UAAf,GACT,MAAM6E,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BtB,GAA/B,EAAoC,SAApC,EAA+C,KAA/C,EAAsD,CAAC,SAAD,CAAtD,CADG,GAETA,GAFN;AAGA,QAAM2F,SAAS,GAAG,IAAI7J,UAAJ,CAAe,MAAM6E,MAAM,CAACU,MAAP,CAAcmE,OAAd,CAAsB;AACzDvD,IAAAA,cAAc,EAAEf,GADyC;AAEzDpB,IAAAA,EAFyD;AAGzDlH,IAAAA,IAAI,EAAE,SAHmD;AAIzDsJ,IAAAA,SAAS,EAAE;AAJ8C,GAAtB,EAKpCd,MALoC,EAK5BS,SAL4B,CAArB,CAAlB;AAMA,QAAMZ,GAAG,GAAG0E,SAAS,CAAClI,KAAV,CAAgB,CAAC,EAAjB,CAAZ;AACA,QAAMuD,UAAU,GAAG2E,SAAS,CAAClI,KAAV,CAAgB,CAAhB,EAAmB,CAAC,EAApB,CAAnB;AACA,SAAO;AAAEuD,IAAAA,UAAF;AAAcC,IAAAA;AAAd,GAAP;AACH;;AACD,MAAMuE,OAAO,GAAG,OAAO3F,GAAP,EAAYgC,SAAZ,EAAuB7B,GAAvB,EAA4BF,EAA5B,EAAgCoB,GAAhC,KAAwC;AACpD,MAAI,CAACN,WAAW,CAACZ,GAAD,CAAZ,IAAqB,EAAEA,GAAG,YAAYlE,UAAjB,CAAzB,EAAuD;AACnD,UAAM,IAAIuD,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACDU,EAAAA,cAAc,CAACF,GAAD,EAAMG,GAAN,CAAd;AACAJ,EAAAA,aAAa,CAACC,GAAD,EAAMC,EAAN,CAAb;;AACA,MAAID,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAc,CAAd,MAAqB,KAAzB,EAAgC;AAC5B,WAAOsF,UAAU,CAAC5F,GAAD,EAAMgC,SAAN,EAAiB7B,GAAjB,EAAsBF,EAAtB,EAA0BoB,GAA1B,CAAjB;AACH;;AACD,SAAOwE,UAAU,CAAC7D,SAAD,EAAY7B,GAAZ,EAAiBF,EAAjB,EAAqBoB,GAArB,CAAjB;AACH,CAVD;;AAYA,MAAM0E,YAAY,GAAGpG,SAAS,CAAC4E,QAAD,CAA9B;;AACA,MAAMyB,IAAI,GAAG,OAAOzJ,GAAP,EAAYyE,GAAZ,EAAiBb,GAAjB,EAAsBF,EAAtB,KAA6B;AACtC,QAAMgG,YAAY,GAAG1J,GAAG,CAAC+D,MAAJ,CAAW,CAAX,EAAc,CAAd,CAArB;AACAL,EAAAA,EAAE,KAAKA,EAAE,GAAG8F,YAAY,CAACE,YAAD,CAAtB,CAAF;AACA,QAAM;AAAE9E,IAAAA,UAAU,EAAEgC,YAAd;AAA4B/B,IAAAA;AAA5B,MAAoC,MAAMuE,OAAO,CAACM,YAAD,EAAe9F,GAAf,EAAoBa,GAApB,EAAyBf,EAAzB,EAA6B,IAAIhE,UAAJ,CAAe,CAAf,CAA7B,CAAvD;AACA,SAAO;AAAEkH,IAAAA,YAAF;AAAgBlD,IAAAA,EAAE,EAAE/B,QAAQ,CAAC+B,EAAD,CAA5B;AAAkCmB,IAAAA,GAAG,EAAElD,QAAQ,CAACkD,GAAD;AAA/C,GAAP;AACH,CALD;;AAMA,MAAM8E,MAAM,GAAG,OAAO3J,GAAP,EAAYyE,GAAZ,EAAiBmC,YAAjB,EAA+BlD,EAA/B,EAAmCmB,GAAnC,KAA2C;AACtD,QAAM6E,YAAY,GAAG1J,GAAG,CAAC+D,MAAJ,CAAW,CAAX,EAAc,CAAd,CAArB;AACA,SAAOiC,SAAS,CAAC0D,YAAD,EAAejF,GAAf,EAAoBmC,YAApB,EAAkClD,EAAlC,EAAsCmB,GAAtC,EAA2C,IAAInF,UAAJ,CAAe,CAAf,CAA3C,CAAhB;AACH,CAHD;;AAKA,MAAMkK,UAAU,GAAG,IAAIzG,GAAJ,CAAQ,CACvB,CAAC,eAAD,EAAkB,GAAlB,CADuB,EAEvB,CAAC,SAAD,EAAY,GAAZ,CAFuB,EAGvB,CAAC,eAAD,EAAkB,GAAlB,CAHuB,EAIvB,CAAC,SAAD,EAAY,GAAZ,CAJuB,EAKvB,CAAC,eAAD,EAAkB,GAAlB,CALuB,EAMvB,CAAC,SAAD,EAAY,GAAZ,CANuB,CAAR,CAAnB;;AAQA,MAAM0G,OAAO,GAAIxG,MAAD,IAAarD,GAAD,IAAS;AACjC,QAAMsD,SAAS,GAAGsG,UAAU,CAACrG,GAAX,CAAevD,GAAf,CAAlB;;AACA,MAAI,CAACsD,SAAL,EAAgB;AACZ,UAAM,IAAIvG,gBAAJ,CAAsB,8BAA6BiD,GAAI,EAAvD,CAAN;AACH;;AACD,SAAOqD,MAAM,CAAC,IAAI3D,UAAJ,CAAe4D,SAAS,IAAI,CAA5B,CAAD,CAAb;AACH,CAND;;AAQA,SAASwG,aAAT,CAAuBC,GAAvB,EAA4B;AACxB,MAAI/F,SAAJ;AACA,MAAIgG,SAAJ;;AACA,UAAQD,GAAG,CAACE,GAAZ;AACI,SAAK,KAAL;AAAY;AACR,gBAAQF,GAAG,CAAC/J,GAAZ;AACI,eAAK,OAAL;AACA,eAAK,OAAL;AACA,eAAK,OAAL;AACIgE,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE,MAAR;AAAgB4I,cAAAA,IAAI,EAAE;AAAE5I,gBAAAA,IAAI,EAAG,OAAMuN,GAAG,CAAC/J,GAAJ,CAAQ+D,MAAR,CAAe,CAAC,CAAhB,CAAmB;AAAlC;AAAtB,aAAZ;AACAiG,YAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,eAAK,eAAL;AACA,eAAK,eAAL;AACA,eAAK,eAAL;AACI,kBAAM,IAAIjN,gBAAJ,CAAsB,GAAEgN,GAAG,CAAC/J,GAAI,iDAAhC,CAAN;;AACJ,eAAK,SAAL;AACA,eAAK,SAAL;AACA,eAAK,SAAL;AACA,eAAK,WAAL;AACA,eAAK,WAAL;AACA,eAAK,WAAL;AACIgE,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE;AAAR,aAAZ;AACAwN,YAAAA,SAAS,GAAG,CAAC,SAAD,EAAY,SAAZ,CAAZ;AACA;;AACJ,eAAK,QAAL;AACA,eAAK,QAAL;AACA,eAAK,QAAL;AACIhG,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE;AAAR,aAAZ;AACAwN,YAAAA,SAAS,GAAG,CAAC,SAAD,EAAY,WAAZ,CAAZ;AACA;;AACJ,eAAK,oBAAL;AACA,eAAK,oBAAL;AACA,eAAK,oBAAL;AACIhG,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE;AAAR,aAAZ;AACAwN,YAAAA,SAAS,GAAG,CAAC,YAAD,CAAZ;AACA;;AACJ;AACI,kBAAM,IAAIjN,gBAAJ,CAAqB,8DAArB,CAAN;AAjCR;;AAmCA;AACH;;AACD,SAAK,KAAL;AAAY;AACR,gBAAQgN,GAAG,CAAC/J,GAAZ;AACI,eAAK,OAAL;AACA,eAAK,OAAL;AACA,eAAK,OAAL;AACIgE,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE,SAAR;AAAmB4I,cAAAA,IAAI,EAAE;AAAE5I,gBAAAA,IAAI,EAAG,OAAMuN,GAAG,CAAC/J,GAAJ,CAAQ+D,MAAR,CAAe,CAAC,CAAhB,CAAmB;AAAlC;AAAzB,aAAZ;AACAiG,YAAAA,SAAS,GAAGD,GAAG,CAACG,CAAJ,GAAQ,CAAC,MAAD,CAAR,GAAmB,CAAC,QAAD,CAA/B;AACA;;AACJ,eAAK,OAAL;AACA,eAAK,OAAL;AACA,eAAK,OAAL;AACIlG,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE,mBAAR;AAA6B4I,cAAAA,IAAI,EAAE;AAAE5I,gBAAAA,IAAI,EAAG,OAAMuN,GAAG,CAAC/J,GAAJ,CAAQ+D,MAAR,CAAe,CAAC,CAAhB,CAAmB;AAAlC;AAAnC,aAAZ;AACAiG,YAAAA,SAAS,GAAGD,GAAG,CAACG,CAAJ,GAAQ,CAAC,MAAD,CAAR,GAAmB,CAAC,QAAD,CAA/B;AACA;;AACJ,eAAK,UAAL;AACA,eAAK,cAAL;AACA,eAAK,cAAL;AACA,eAAK,cAAL;AACIlG,YAAAA,SAAS,GAAG;AACRxH,cAAAA,IAAI,EAAE,UADE;AAER4I,cAAAA,IAAI,EAAE;AAAE5I,gBAAAA,IAAI,EAAG,OAAMsH,QAAQ,CAACiG,GAAG,CAAC/J,GAAJ,CAAQ+D,MAAR,CAAe,CAAC,CAAhB,CAAD,EAAqB,EAArB,CAAR,IAAoC,CAAE;AAArD;AAFE,aAAZ;AAIAiG,YAAAA,SAAS,GAAGD,GAAG,CAACG,CAAJ,GAAQ,CAAC,SAAD,EAAY,WAAZ,CAAR,GAAmC,CAAC,SAAD,EAAY,SAAZ,CAA/C;AACA;;AACJ;AACI,kBAAM,IAAInN,gBAAJ,CAAqB,8DAArB,CAAN;AAxBR;;AA0BA;AACH;;AACD,SAAK,IAAL;AAAW;AACP,gBAAQgN,GAAG,CAAC/J,GAAZ;AACI,eAAK,OAAL;AACA,eAAK,OAAL;AACA,eAAK,OAAL;AACIgE,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE,OAAR;AAAiBoL,cAAAA,UAAU,EAAEmC,GAAG,CAACI;AAAjC,aAAZ;AACAH,YAAAA,SAAS,GAAGD,GAAG,CAACG,CAAJ,GAAQ,CAAC,MAAD,CAAR,GAAmB,CAAC,QAAD,CAA/B;AACA;;AACJ,eAAK,SAAL;AACA,eAAK,gBAAL;AACA,eAAK,gBAAL;AACA,eAAK,gBAAL;AACIlG,YAAAA,SAAS,GAAG;AAAExH,cAAAA,IAAI,EAAE,MAAR;AAAgBoL,cAAAA,UAAU,EAAEmC,GAAG,CAACI;AAAhC,aAAZ;AACAH,YAAAA,SAAS,GAAGD,GAAG,CAACG,CAAJ,GAAQ,CAAC,YAAD,CAAR,GAAyB,EAArC;AACA;;AACJ;AACI,kBAAM,IAAInN,gBAAJ,CAAqB,8DAArB,CAAN;AAfR;;AAiBA;AACH;;AACD;AACI,YAAM,IAAIA,gBAAJ,CAAqB,6DAArB,CAAN;AAzFR;;AA2FA,SAAO;AAAEiH,IAAAA,SAAF;AAAagG,IAAAA;AAAb,GAAP;AACH;;AACD,MAAMI,KAAK,GAAG,MAAOL,GAAP,IAAe;AACzB,MAAI/G,EAAJ,EAAQ2C,EAAR;;AACA,QAAM;AAAE3B,IAAAA,SAAF;AAAagG,IAAAA;AAAb,MAA2BF,aAAa,CAACC,GAAD,CAA9C;AACA,MAAIM,MAAM,GAAG,KAAb;AACA,MAAIC,OAAO,GAAG,EAAE,GAAGP;AAAL,GAAd;AACA,SAAOO,OAAO,CAACtK,GAAf;;AACA,MAAIgE,SAAS,CAACxH,IAAV,KAAmB,QAAvB,EAAiC;AAC7B6N,IAAAA,MAAM,GAAG,KAAT;AACAC,IAAAA,OAAO,GAAG9H,QAAQ,CAACuH,GAAG,CAACQ,CAAL,CAAlB;AACH;;AACD,SAAOhG,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwBmF,MAAxB,EAAgCC,OAAhC,EAAyCtG,SAAzC,EAAoD,CAAChB,EAAE,GAAG+G,GAAG,CAACS,GAAV,MAAmB,IAAnB,IAA2BxH,EAAE,KAAK,KAAK,CAAvC,GAA2CA,EAA3C,GAAgD,KAApG,EAA2G,CAAC2C,EAAE,GAAGoE,GAAG,CAACU,OAAV,MAAuB,IAAvB,IAA+B9E,EAAE,KAAK,KAAK,CAA3C,GAA+CA,EAA/C,GAAoDqE,SAA/J,CAAP;AACH,CAXD;;AAaA,eAAeU,QAAf,CAAwBX,GAAxB,EAA6B/J,GAA7B,EAAkC2K,cAAlC,EAAkD;AAC9C,MAAI,CAACjM,QAAQ,CAACqL,GAAD,CAAb,EAAoB;AAChB,UAAM,IAAI9G,SAAJ,CAAc,uBAAd,CAAN;AACH;;AACDjD,EAAAA,GAAG,KAAKA,GAAG,GAAG+J,GAAG,CAAC/J,GAAf,CAAH;;AACA,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,UAAM,IAAIiD,SAAJ,CAAc,0DAAd,CAAN;AACH;;AACD,UAAQ8G,GAAG,CAACE,GAAZ;AACI,SAAK,KAAL;AACI,UAAI,OAAOF,GAAG,CAACQ,CAAX,KAAiB,QAAjB,IAA6B,CAACR,GAAG,CAACQ,CAAtC,EAAyC;AACrC,cAAM,IAAItH,SAAJ,CAAc,yCAAd,CAAN;AACH;;AACD0H,MAAAA,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuDA,cAAvD,GAAyEA,cAAc,GAAGZ,GAAG,CAACS,GAAJ,KAAY,IAAtG;;AACA,UAAIG,cAAJ,EAAoB;AAChB,eAAOP,KAAK,CAAC,EAAE,GAAGL,GAAL;AAAU/J,UAAAA,GAAV;AAAewK,UAAAA,GAAG,EAAE;AAApB,SAAD,CAAZ;AACH;;AACD,aAAOhI,QAAQ,CAACuH,GAAG,CAACQ,CAAL,CAAf;;AACJ,SAAK,KAAL;AACI,UAAIR,GAAG,CAACa,GAAJ,KAAY3G,SAAhB,EAA2B;AACvB,cAAM,IAAIlH,gBAAJ,CAAqB,oEAArB,CAAN;AACH;;AACL,SAAK,IAAL;AACA,SAAK,KAAL;AACI,aAAOqN,KAAK,CAAC,EAAE,GAAGL,GAAL;AAAU/J,QAAAA;AAAV,OAAD,CAAZ;;AACJ;AACI,YAAM,IAAIjD,gBAAJ,CAAqB,8CAArB,CAAN;AAlBR;AAoBH;;AAED,SAAS8N,iBAAT,CAA2BjE,YAA3B,EAAyC;AACrC,MAAI,CAACA,YAAL,EAAmB;AACf,UAAM,IAAI3J,UAAJ,CAAe,2BAAf,CAAN;AACH;AACJ;;AACD,SAAS6N,qBAAT,CAA+BC,UAA/B,EAA2CzM,SAA3C,EAAsD9B,IAAtD,EAA4D;AACxD,MAAIuO,UAAU,CAACzM,SAAD,CAAV,KAA0B2F,SAA9B,EAAyC;AACrC,UAAM,IAAIhH,UAAJ,CAAgB,eAAcT,IAAK,KAAI8B,SAAU,WAAjD,CAAN;AACH;AACJ;;AACD,eAAe0M,oBAAf,CAAoChL,GAApC,EAAyCyE,GAAzC,EAA8CmC,YAA9C,EAA4DmE,UAA5D,EAAwE;AACpE,UAAQ/K,GAAR;AACI,SAAK,KAAL;AAAY;AACR,YAAI4G,YAAY,KAAK3C,SAArB,EAAgC;AAC5B,gBAAM,IAAIhH,UAAJ,CAAe,0CAAf,CAAN;AACH;;AACD,eAAOwH,GAAP;AACH;;AACD,SAAK,SAAL;AACI,UAAImC,YAAY,KAAK3C,SAArB,EAAgC;AAC5B,cAAM,IAAIhH,UAAJ,CAAe,0CAAf,CAAN;AACH;;AACL,SAAK,gBAAL;AACA,SAAK,gBAAL;AACA,SAAK,gBAAL;AAAuB;AACnB6N,QAAAA,qBAAqB,CAACC,UAAD,EAAa,KAAb,EAAoB,sBAApB,CAArB;;AACA,YAAI,CAAChD,WAAW,CAACtD,GAAD,CAAhB,EAAuB;AACnB,gBAAM,IAAI1H,gBAAJ,CAAqB,0FAArB,CAAN;AACH;;AACD,cAAMkO,GAAG,GAAG,MAAMP,QAAQ,CAACK,UAAU,CAACE,GAAZ,EAAiBjL,GAAjB,CAA1B;AACA,YAAIkL,UAAJ;AACA,YAAIC,UAAJ;AACA,YAAIJ,UAAU,CAAC1D,GAAX,KAAmBpD,SAAvB,EACIiH,UAAU,GAAG1I,QAAQ,CAACuI,UAAU,CAAC1D,GAAZ,CAArB;AACJ,YAAI0D,UAAU,CAACzD,GAAX,KAAmBrD,SAAvB,EACIkH,UAAU,GAAG3I,QAAQ,CAACuI,UAAU,CAACzD,GAAZ,CAArB;AACJ,cAAMG,YAAY,GAAG,MAAMR,SAAS,CAACgE,GAAD,EAAMxG,GAAN,EAAWzE,GAAG,KAAK,SAAR,GAAoB+K,UAAU,CAACtH,GAA/B,GAAqCzD,GAAhD,EAAqD8D,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,EAAe,CAAf,CAAD,EAAoB,EAApB,CAAR,IAAmC6F,UAAU,CAACrG,GAAX,CAAewH,UAAU,CAACtH,GAA1B,CAAxF,EAAwHyH,UAAxH,EAAoIC,UAApI,CAApC;;AACA,YAAInL,GAAG,KAAK,SAAZ,EAAuB;AACnB,iBAAOyH,YAAP;AACH;;AACDoD,QAAAA,iBAAiB,CAACjE,YAAD,CAAjB;AACA,cAAMwE,KAAK,GAAGpL,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAd;AACA,eAAO4C,QAAQ,CAACyE,KAAD,EAAQ3D,YAAR,EAAsBb,YAAtB,CAAf;AACH;;AACD,SAAK,QAAL;AACA,SAAK,UAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AAAqB;AACjBiE,QAAAA,iBAAiB,CAACjE,YAAD,CAAjB;AACA,eAAOlB,OAAO,CAAC1F,GAAD,EAAMyE,GAAN,EAAWmC,YAAX,CAAd;AACH;;AACD,SAAK,oBAAL;AACA,SAAK,oBAAL;AACA,SAAK,oBAAL;AAA2B;AACvBiE,QAAAA,iBAAiB,CAACjE,YAAD,CAAjB;AACAkE,QAAAA,qBAAqB,CAACC,UAAD,EAAa,KAAb,EAAoB,aAApB,CAArB;AACAD,QAAAA,qBAAqB,CAACC,UAAD,EAAa,KAAb,EAAoB,YAApB,CAArB;AACA,cAAM;AAAEzC,UAAAA;AAAF,YAAUyC,UAAhB;AACA,cAAMhL,GAAG,GAAGyC,QAAQ,CAACuI,UAAU,CAAChL,GAAZ,CAApB;AACA,eAAO8I,SAAS,CAAC7I,GAAD,EAAMyE,GAAN,EAAWmC,YAAX,EAAyB0B,GAAzB,EAA8BvI,GAA9B,CAAhB;AACH;;AACD,SAAK,QAAL;AACA,SAAK,QAAL;AACA,SAAK,QAAL;AAAe;AACX8K,QAAAA,iBAAiB,CAACjE,YAAD,CAAjB;AACA,eAAOD,QAAQ,CAAC3G,GAAD,EAAMyE,GAAN,EAAWmC,YAAX,CAAf;AACH;;AACD,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AAAkB;AACdiE,QAAAA,iBAAiB,CAACjE,YAAD,CAAjB;AACAkE,QAAAA,qBAAqB,CAACC,UAAD,EAAa,IAAb,EAAmB,uBAAnB,CAArB;AACAD,QAAAA,qBAAqB,CAACC,UAAD,EAAa,KAAb,EAAoB,oBAApB,CAArB;AACA,cAAMrH,EAAE,GAAGlB,QAAQ,CAACuI,UAAU,CAACrH,EAAZ,CAAnB;AACA,cAAMmB,GAAG,GAAGrC,QAAQ,CAACuI,UAAU,CAAClG,GAAZ,CAApB;AACA,eAAO8E,MAAM,CAAC3J,GAAD,EAAMyE,GAAN,EAAWmC,YAAX,EAAyBlD,EAAzB,EAA6BmB,GAA7B,CAAb;AACH;;AACD;AAAS;AACL,cAAM,IAAI9H,gBAAJ,CAAqB,2DAArB,CAAN;AACH;AArEL;AAuEH;;AAED,SAASsO,YAAT,CAAsBC,GAAtB,EAA2BC,iBAA3B,EAA8CC,gBAA9C,EAAgEC,eAAhE,EAAiFV,UAAjF,EAA6F;AACzF,MAAIA,UAAU,CAACW,IAAX,KAAoBzH,SAApB,IAAiCwH,eAAe,CAACC,IAAhB,KAAyBzH,SAA9D,EAAyE;AACrE,UAAM,IAAIqH,GAAJ,CAAQ,gEAAR,CAAN;AACH;;AACD,MAAI,CAACG,eAAD,IAAoBA,eAAe,CAACC,IAAhB,KAAyBzH,SAAjD,EAA4D;AACxD,WAAO,IAAI5F,GAAJ,EAAP;AACH;;AACD,MAAI,CAACsN,KAAK,CAACC,OAAN,CAAcH,eAAe,CAACC,IAA9B,CAAD,IACAD,eAAe,CAACC,IAAhB,CAAqB3N,MAArB,KAAgC,CADhC,IAEA0N,eAAe,CAACC,IAAhB,CAAqBG,IAArB,CAA2BlN,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACZ,MAAN,KAAiB,CAAnF,CAFJ,EAE2F;AACvF,UAAM,IAAIuN,GAAJ,CAAQ,uFAAR,CAAN;AACH;;AACD,MAAIQ,UAAJ;;AACA,MAAIN,gBAAgB,KAAKvH,SAAzB,EAAoC;AAChC6H,IAAAA,UAAU,GAAG,IAAI3I,GAAJ,CAAQ,CAAC,GAAGpH,MAAM,CAACgQ,OAAP,CAAeP,gBAAf,CAAJ,EAAsC,GAAGD,iBAAiB,CAACQ,OAAlB,EAAzC,CAAR,CAAb;AACH,GAFD,MAGK;AACDD,IAAAA,UAAU,GAAGP,iBAAb;AACH;;AACD,OAAK,MAAMjN,SAAX,IAAwBmN,eAAe,CAACC,IAAxC,EAA8C;AAC1C,QAAI,CAACI,UAAU,CAACvN,GAAX,CAAeD,SAAf,CAAL,EAAgC;AAC5B,YAAM,IAAIvB,gBAAJ,CAAsB,+BAA8BuB,SAAU,qBAA9D,CAAN;AACH;;AACD,QAAIyM,UAAU,CAACzM,SAAD,CAAV,KAA0B2F,SAA9B,EAAyC;AACrC,YAAM,IAAIqH,GAAJ,CAAS,+BAA8BhN,SAAU,cAAjD,CAAN;AACH,KAFD,MAGK,IAAIwN,UAAU,CAACvI,GAAX,CAAejF,SAAf,KAA6BmN,eAAe,CAACnN,SAAD,CAAf,KAA+B2F,SAAhE,EAA2E;AAC5E,YAAM,IAAIqH,GAAJ,CAAS,+BAA8BhN,SAAU,+BAAjD,CAAN;AACH;AACJ;;AACD,SAAO,IAAID,GAAJ,CAAQoN,eAAe,CAACC,IAAxB,CAAP;AACH;;AAED,MAAMM,kBAAkB,GAAG,CAACC,MAAD,EAASC,UAAT,KAAwB;AAC/C,MAAIA,UAAU,KAAKjI,SAAf,KACC,CAAC0H,KAAK,CAACC,OAAN,CAAcM,UAAd,CAAD,IAA8BA,UAAU,CAACL,IAAX,CAAiBM,CAAD,IAAO,OAAOA,CAAP,KAAa,QAApC,CAD/B,CAAJ,EACmF;AAC/E,UAAM,IAAIlJ,SAAJ,CAAe,IAAGgJ,MAAO,sCAAzB,CAAN;AACH;;AACD,MAAI,CAACC,UAAL,EAAiB;AACb,WAAOjI,SAAP;AACH;;AACD,SAAO,IAAI5F,GAAJ,CAAQ6N,UAAR,CAAP;AACH,CATD;;AAWA,MAAME,aAAa,GAAGvC,OAAO,CAAC7B,QAAD,CAA7B;AACA,MAAMqE,iBAAiB,GAAGhB,YAAY,CAACnD,IAAb,CAAkBjE,SAAlB,EAA6BhH,UAA7B,EAAyC,IAAIkG,GAAJ,EAAzC,CAA1B;AACA,MAAMmJ,gBAAgB,GAAGN,kBAAkB,CAAC9D,IAAnB,CAAwBjE,SAAxB,EAAmC,yBAAnC,CAAzB;AACA,MAAMsI,cAAc,GAAGP,kBAAkB,CAAC9D,IAAnB,CAAwBjE,SAAxB,EAAmC,6BAAnC,CAAvB;;AACA,eAAeuI,gBAAf,CAAgCC,GAAhC,EAAqChI,GAArC,EAA0CiI,OAA1C,EAAmD;AAC/C,MAAI1J,EAAJ;;AACA,MAAI,CAACtE,QAAQ,CAAC+N,GAAD,CAAb,EAAoB;AAChB,UAAM,IAAIxP,UAAJ,CAAe,iCAAf,CAAN;AACH;;AACD,MAAIwP,GAAG,CAACE,SAAJ,KAAkB1I,SAAlB,IAA+BwI,GAAG,CAACxO,MAAJ,KAAegG,SAA9C,IAA2DwI,GAAG,CAACG,WAAJ,KAAoB3I,SAAnF,EAA8F;AAC1F,UAAM,IAAIhH,UAAJ,CAAe,qBAAf,CAAN;AACH;;AACD,MAAI,OAAOwP,GAAG,CAAC/I,EAAX,KAAkB,QAAtB,EAAgC;AAC5B,UAAM,IAAIzG,UAAJ,CAAe,qDAAf,CAAN;AACH;;AACD,MAAI,OAAOwP,GAAG,CAAC7H,UAAX,KAA0B,QAA9B,EAAwC;AACpC,UAAM,IAAI3H,UAAJ,CAAe,0CAAf,CAAN;AACH;;AACD,MAAI,OAAOwP,GAAG,CAAC5H,GAAX,KAAmB,QAAvB,EAAiC;AAC7B,UAAM,IAAI5H,UAAJ,CAAe,kDAAf,CAAN;AACH;;AACD,MAAIwP,GAAG,CAACE,SAAJ,KAAkB1I,SAAlB,IAA+B,OAAOwI,GAAG,CAACE,SAAX,KAAyB,QAA5D,EAAsE;AAClE,UAAM,IAAI1P,UAAJ,CAAe,qCAAf,CAAN;AACH;;AACD,MAAIwP,GAAG,CAACI,aAAJ,KAAsB5I,SAAtB,IAAmC,OAAOwI,GAAG,CAACI,aAAX,KAA6B,QAApE,EAA8E;AAC1E,UAAM,IAAI5P,UAAJ,CAAe,kCAAf,CAAN;AACH;;AACD,MAAIwP,GAAG,CAAC3H,GAAJ,KAAYb,SAAZ,IAAyB,OAAOwI,GAAG,CAAC3H,GAAX,KAAmB,QAAhD,EAA0D;AACtD,UAAM,IAAI7H,UAAJ,CAAe,wBAAf,CAAN;AACH;;AACD,MAAIwP,GAAG,CAACxO,MAAJ,KAAegG,SAAf,IAA4B,CAACvF,QAAQ,CAAC+N,GAAG,CAACxO,MAAL,CAAzC,EAAuD;AACnD,UAAM,IAAIhB,UAAJ,CAAe,8CAAf,CAAN;AACH;;AACD,MAAIwP,GAAG,CAACG,WAAJ,KAAoB3I,SAApB,IAAiC,CAACvF,QAAQ,CAAC+N,GAAG,CAACG,WAAL,CAA9C,EAAiE;AAC7D,UAAM,IAAI3P,UAAJ,CAAe,qDAAf,CAAN;AACH;;AACD,MAAI6P,UAAJ;;AACA,MAAIL,GAAG,CAACE,SAAR,EAAmB;AACf,UAAMlB,eAAe,GAAGjJ,QAAQ,CAACiK,GAAG,CAACE,SAAL,CAAhC;AACAG,IAAAA,UAAU,GAAGC,IAAI,CAAC3C,KAAL,CAAWjL,OAAO,CAACuD,MAAR,CAAe+I,eAAf,CAAX,CAAb;AACH;;AACD,MAAI,CAAC/N,UAAU,CAACoP,UAAD,EAAaL,GAAG,CAACxO,MAAjB,EAAyBwO,GAAG,CAACG,WAA7B,CAAf,EAA0D;AACtD,UAAM,IAAI3P,UAAJ,CAAe,kHAAf,CAAN;AACH;;AACD,QAAM8N,UAAU,GAAG,EACf,GAAG+B,UADY;AAEf,OAAGL,GAAG,CAACxO,MAFQ;AAGf,OAAGwO,GAAG,CAACG;AAHQ,GAAnB;AAKAP,EAAAA,iBAAiB,CAACK,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAChB,IAA3D,EAAiEoB,UAAjE,EAA6E/B,UAA7E,CAAjB;;AACA,MAAIA,UAAU,CAACiC,GAAX,KAAmB/I,SAAvB,EAAkC;AAC9B,QAAI,CAAC6I,UAAD,IAAe,CAACA,UAAU,CAACE,GAA/B,EAAoC;AAChC,YAAM,IAAI/P,UAAJ,CAAe,sEAAf,CAAN;AACH;;AACD,QAAI8N,UAAU,CAACiC,GAAX,KAAmB,KAAvB,EAA8B;AAC1B,YAAM,IAAIjQ,gBAAJ,CAAqB,sEAArB,CAAN;AACH;AACJ;;AACD,QAAM;AAAEiD,IAAAA,GAAF;AAAOyD,IAAAA;AAAP,MAAesH,UAArB;;AACA,MAAI,OAAO/K,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,UAAM,IAAI/C,UAAJ,CAAe,2CAAf,CAAN;AACH;;AACD,MAAI,OAAOwG,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,UAAM,IAAIxG,UAAJ,CAAe,sDAAf,CAAN;AACH;;AACD,QAAMgQ,uBAAuB,GAAGP,OAAO,IAAIJ,gBAAgB,CAACI,OAAO,CAACO,uBAAT,CAA3D;AACA,QAAMC,2BAA2B,GAAGR,OAAO,IAAIH,cAAc,CAACG,OAAO,CAACQ,2BAAT,CAA7D;;AACA,MAAID,uBAAuB,IAAI,CAACA,uBAAuB,CAAC1O,GAAxB,CAA4ByB,GAA5B,CAAhC,EAAkE;AAC9D,UAAM,IAAInD,iBAAJ,CAAsB,gDAAtB,CAAN;AACH;;AACD,MAAIqQ,2BAA2B,IAAI,CAACA,2BAA2B,CAAC3O,GAA5B,CAAgCkF,GAAhC,CAApC,EAA0E;AACtE,UAAM,IAAI5G,iBAAJ,CAAsB,2DAAtB,CAAN;AACH;;AACD,MAAI+J,YAAJ;;AACA,MAAI6F,GAAG,CAACI,aAAJ,KAAsB5I,SAA1B,EAAqC;AACjC2C,IAAAA,YAAY,GAAGpE,QAAQ,CAACiK,GAAG,CAACI,aAAL,CAAvB;AACH;;AACD,MAAI,OAAOpI,GAAP,KAAe,UAAnB,EAA+B;AAC3BA,IAAAA,GAAG,GAAG,MAAMA,GAAG,CAACqI,UAAD,EAAaL,GAAb,CAAf;AACH;;AACD,MAAI7I,GAAJ;;AACA,MAAI;AACAA,IAAAA,GAAG,GAAG,MAAMoH,oBAAoB,CAAChL,GAAD,EAAMyE,GAAN,EAAWmC,YAAX,EAAyBmE,UAAzB,CAAhC;AACH,GAFD,CAGA,OAAOhF,GAAP,EAAY;AACR,QAAIA,GAAG,YAAY9C,SAAnB,EAA8B;AAC1B,YAAM8C,GAAN;AACH;;AACDnC,IAAAA,GAAG,GAAGwI,aAAa,CAAC3I,GAAD,CAAnB;AACH;;AACD,QAAMC,EAAE,GAAGlB,QAAQ,CAACiK,GAAG,CAAC/I,EAAL,CAAnB;AACA,QAAMmB,GAAG,GAAGrC,QAAQ,CAACiK,GAAG,CAAC5H,GAAL,CAApB;AACA,QAAM4G,eAAe,GAAGxM,OAAO,CAACiB,MAAR,CAAe,CAAC8C,EAAE,GAAGyJ,GAAG,CAACE,SAAV,MAAyB,IAAzB,IAAiC3J,EAAE,KAAK,KAAK,CAA7C,GAAiDA,EAAjD,GAAsD,EAArE,CAAxB;AACA,MAAI6C,cAAJ;;AACA,MAAI4G,GAAG,CAAC3H,GAAJ,KAAYb,SAAhB,EAA2B;AACvB4B,IAAAA,cAAc,GAAGvG,MAAM,CAACmM,eAAD,EAAkBxM,OAAO,CAACiB,MAAR,CAAe,GAAf,CAAlB,EAAuCjB,OAAO,CAACiB,MAAR,CAAeuM,GAAG,CAAC3H,GAAnB,CAAvC,CAAvB;AACH,GAFD,MAGK;AACDe,IAAAA,cAAc,GAAG4F,eAAjB;AACH;;AACD,MAAIhG,SAAS,GAAG,MAAMO,SAAS,CAACvC,GAAD,EAAMG,GAAN,EAAWpB,QAAQ,CAACiK,GAAG,CAAC7H,UAAL,CAAnB,EAAqClB,EAArC,EAAyCmB,GAAzC,EAA8CgB,cAA9C,CAA/B;;AACA,MAAIkF,UAAU,CAACiC,GAAX,KAAmB,KAAvB,EAA8B;AAC1BvH,IAAAA,SAAS,GAAG,MAAM,CAAC,CAACiH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACS,UAA3D,KAA0ElH,OAA3E,EAAoFR,SAApF,CAAlB;AACH;;AACD,QAAM2H,MAAM,GAAG;AAAE3H,IAAAA;AAAF,GAAf;;AACA,MAAIgH,GAAG,CAACE,SAAJ,KAAkB1I,SAAtB,EAAiC;AAC7BmJ,IAAAA,MAAM,CAAC3B,eAAP,GAAyBqB,UAAzB;AACH;;AACD,MAAIL,GAAG,CAAC3H,GAAJ,KAAYb,SAAhB,EAA2B;AACvBmJ,IAAAA,MAAM,CAACC,2BAAP,GAAqC7K,QAAQ,CAACiK,GAAG,CAAC3H,GAAL,CAA7C;AACH;;AACD,MAAI2H,GAAG,CAACG,WAAJ,KAAoB3I,SAAxB,EAAmC;AAC/BmJ,IAAAA,MAAM,CAACE,uBAAP,GAAiCb,GAAG,CAACG,WAArC;AACH;;AACD,MAAIH,GAAG,CAACxO,MAAJ,KAAegG,SAAnB,EAA8B;AAC1BmJ,IAAAA,MAAM,CAACG,iBAAP,GAA2Bd,GAAG,CAACxO,MAA/B;AACH;;AACD,SAAOmP,MAAP;AACH;;AAED,eAAeI,cAAf,CAA8Bf,GAA9B,EAAmChI,GAAnC,EAAwCiI,OAAxC,EAAiD;AAC7C,MAAID,GAAG,YAAY/M,UAAnB,EAA+B;AAC3B+M,IAAAA,GAAG,GAAGtN,OAAO,CAACuD,MAAR,CAAe+J,GAAf,CAAN;AACH;;AACD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzB,UAAM,IAAIxP,UAAJ,CAAe,4CAAf,CAAN;AACH;;AACD,QAAM;AAAE,OAAGwO,eAAL;AAAsB,OAAG7E,YAAzB;AAAuC,OAAGlD,EAA1C;AAA8C,OAAGkB,UAAjD;AAA6D,OAAGC,GAAhE;AAAqE9G,IAAAA;AAArE,MAAiF0O,GAAG,CAAC7J,KAAJ,CAAU,GAAV,CAAvF;;AACA,MAAI7E,MAAM,KAAK,CAAf,EAAkB;AACd,UAAM,IAAId,UAAJ,CAAe,qBAAf,CAAN;AACH;;AACD,QAAMwQ,SAAS,GAAG,MAAMjB,gBAAgB,CAAC;AACrC5H,IAAAA,UAAU,EAAGA,UAAU,IAAIX,SADU;AAErCP,IAAAA,EAAE,EAAGA,EAAE,IAAIO,SAF0B;AAGrC0I,IAAAA,SAAS,EAAElB,eAAe,IAAIxH,SAHO;AAIrCY,IAAAA,GAAG,EAAGA,GAAG,IAAIZ,SAJwB;AAKrC4I,IAAAA,aAAa,EAAEjG,YAAY,IAAI3C;AALM,GAAD,EAMrCQ,GANqC,EAMhCiI,OANgC,CAAxC;AAOA,SAAO;AAAEjH,IAAAA,SAAS,EAAEgI,SAAS,CAAChI,SAAvB;AAAkCgG,IAAAA,eAAe,EAAEgC,SAAS,CAAChC;AAA7D,GAAP;AACH;;AAED,MAAMiC,QAAQ,GAAG,MAAOjJ,GAAP,IAAe;AAC5B,MAAI,CAACD,WAAW,CAACC,GAAD,CAAhB,EAAuB;AACnB,UAAM,IAAIxB,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,MAAI,CAACwB,GAAG,CAACkJ,WAAT,EAAsB;AAClB,UAAM,IAAI1K,SAAJ,CAAc,uDAAd,CAAN;AACH;;AACD,QAAM;AAAEuH,IAAAA,GAAF;AAAOC,IAAAA,OAAP;AAAgBzK,IAAAA,GAAhB;AAAqB4N,IAAAA,GAArB;AAA0B,OAAG7D;AAA7B,MAAqC,MAAMxF,MAAM,CAACU,MAAP,CAAc6B,SAAd,CAAwB,KAAxB,EAA+BrC,GAA/B,CAAjD;AACA,SAAOsF,GAAP;AACH,CATD;;AAWA,eAAe8D,WAAf,CAA2BpJ,GAA3B,EAAgC;AAC5B,MAAIA,GAAG,YAAY/E,UAAnB,EAA+B;AAC3B,WAAO;AACHuK,MAAAA,GAAG,EAAE,KADF;AAEHM,MAAAA,CAAC,EAAE5I,QAAQ,CAAC8C,GAAD;AAFR,KAAP;AAIH;;AACD,SAAOiJ,QAAQ,CAACjJ,GAAD,CAAf;AACH;;AAED,MAAMqJ,WAAW,GAAGjE,OAAO,CAAC7B,QAAD,CAA3B;;AACA,eAAe+F,oBAAf,CAAoC/N,GAApC,EAAyCyD,GAAzC,EAA8CgB,GAA9C,EAAmDuJ,WAAnD,EAAgEC,kBAAkB,GAAG,EAArF,EAAyF;AACrF,MAAIrH,YAAJ;AACA,MAAI1I,UAAJ;AACA,MAAI0F,GAAJ;;AACA,UAAQ5D,GAAR;AACI,SAAK,KAAL;AAAY;AACR4D,QAAAA,GAAG,GAAGa,GAAN;AACA;AACH;;AACD,SAAK,SAAL;AACA,SAAK,gBAAL;AACA,SAAK,gBAAL;AACA,SAAK,gBAAL;AAAuB;AACnB,YAAI,CAACsD,WAAW,CAACtD,GAAD,CAAhB,EAAuB;AACnB,gBAAM,IAAI1H,gBAAJ,CAAqB,0FAArB,CAAN;AACH;;AACD,cAAM;AAAEsK,UAAAA,GAAF;AAAOC,UAAAA;AAAP,YAAe2G,kBAArB;AACA,YAAI;AAAEhD,UAAAA,GAAG,EAAEiD;AAAP,YAAwBD,kBAA5B;AACAC,QAAAA,YAAY,KAAKA,YAAY,GAAG,MAAMrG,WAAW,CAACpD,GAAD,CAArC,CAAZ;AACA,cAAM;AAAE0J,UAAAA,CAAF;AAAKC,UAAAA,CAAL;AAAQjE,UAAAA,GAAR;AAAaF,UAAAA;AAAb,YAAqB,MAAM4D,WAAW,CAACK,YAAD,CAA5C;AACA,cAAMzG,YAAY,GAAG,MAAMR,SAAS,CAACxC,GAAD,EAAMyJ,YAAN,EAAoBlO,GAAG,KAAK,SAAR,GAAoByD,GAApB,GAA0BzD,GAA9C,EAAmD8D,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,EAAe,CAAf,CAAD,EAAoB,EAApB,CAAR,IAAmC6F,UAAU,CAACrG,GAAX,CAAeE,GAAf,CAAtF,EAA2G4D,GAA3G,EAAgHC,GAAhH,CAApC;AACApJ,QAAAA,UAAU,GAAG;AAAE+M,UAAAA,GAAG,EAAE;AAAEkD,YAAAA,CAAF;AAAKC,YAAAA,CAAL;AAAQjE,YAAAA,GAAR;AAAaF,YAAAA;AAAb;AAAP,SAAb;AACA,YAAI5C,GAAJ,EACInJ,UAAU,CAACmJ,GAAX,GAAiB1F,QAAQ,CAAC0F,GAAD,CAAzB;AACJ,YAAIC,GAAJ,EACIpJ,UAAU,CAACoJ,GAAX,GAAiB3F,QAAQ,CAAC2F,GAAD,CAAzB;;AACJ,YAAItH,GAAG,KAAK,SAAZ,EAAuB;AACnB4D,UAAAA,GAAG,GAAG6D,YAAN;AACA;AACH;;AACD7D,QAAAA,GAAG,GAAGoK,WAAW,IAAIF,WAAW,CAACrK,GAAD,CAAhC;AACA,cAAM2H,KAAK,GAAGpL,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAd;AACA6C,QAAAA,YAAY,GAAG,MAAML,MAAM,CAAC6E,KAAD,EAAQ3D,YAAR,EAAsB7D,GAAtB,CAA3B;AACA;AACH;;AACD,SAAK,QAAL;AACA,SAAK,UAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AAAqB;AACjBA,QAAAA,GAAG,GAAGoK,WAAW,IAAIF,WAAW,CAACrK,GAAD,CAAhC;AACAmD,QAAAA,YAAY,GAAG,MAAMuC,SAAS,CAACnJ,GAAD,EAAMyE,GAAN,EAAWb,GAAX,CAA9B;AACA;AACH;;AACD,SAAK,oBAAL;AACA,SAAK,oBAAL;AACA,SAAK,oBAAL;AAA2B;AACvBA,QAAAA,GAAG,GAAGoK,WAAW,IAAIF,WAAW,CAACrK,GAAD,CAAhC;AACA,cAAM;AAAE6E,UAAAA,GAAF;AAAOvI,UAAAA;AAAP,YAAekO,kBAArB;AACA,SAAC;AAAErH,UAAAA,YAAF;AAAgB,aAAG1I;AAAnB,YAAkC,MAAMmK,SAAS,CAACrI,GAAD,EAAMyE,GAAN,EAAWb,GAAX,EAAgB0E,GAAhB,EAAqBvI,GAArB,CAAlD;AACA;AACH;;AACD,SAAK,QAAL;AACA,SAAK,QAAL;AACA,SAAK,QAAL;AAAe;AACX6D,QAAAA,GAAG,GAAGoK,WAAW,IAAIF,WAAW,CAACrK,GAAD,CAAhC;AACAmD,QAAAA,YAAY,GAAG,MAAML,MAAM,CAACvG,GAAD,EAAMyE,GAAN,EAAWb,GAAX,CAA3B;AACA;AACH;;AACD,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AAAkB;AACdA,QAAAA,GAAG,GAAGoK,WAAW,IAAIF,WAAW,CAACrK,GAAD,CAAhC;AACA,cAAM;AAAEC,UAAAA;AAAF,YAASuK,kBAAf;AACA,SAAC;AAAErH,UAAAA,YAAF;AAAgB,aAAG1I;AAAnB,YAAkC,MAAMuL,IAAI,CAACzJ,GAAD,EAAMyE,GAAN,EAAWb,GAAX,EAAgBF,EAAhB,CAA7C;AACA;AACH;;AACD;AAAS;AACL,cAAM,IAAI3G,gBAAJ,CAAqB,2DAArB,CAAN;AACH;AAjEL;;AAmEA,SAAO;AAAE6G,IAAAA,GAAF;AAAOgD,IAAAA,YAAP;AAAqB1I,IAAAA;AAArB,GAAP;AACH;;AAED,MAAMmQ,UAAU,GAAGjL,SAAS,CAAC4E,QAAD,CAA5B;AACA,MAAMsG,iBAAiB,GAAGjD,YAAY,CAACnD,IAAb,CAAkBjE,SAAlB,EAA6BhH,UAA7B,EAAyC,IAAIkG,GAAJ,EAAzC,CAA1B;;AACA,MAAMoL,gBAAN,CAAuB;AACnBlS,EAAAA,WAAW,CAACoJ,SAAD,EAAY;AACnB,SAAK+I,UAAL,GAAkB/I,SAAlB;AACH;;AACDgJ,EAAAA,0BAA0B,CAACvQ,UAAD,EAAa;AACnC,QAAI,KAAKwQ,wBAAT,EAAmC;AAC/B,YAAM,IAAIzL,SAAJ,CAAc,oDAAd,CAAN;AACH;;AACD,SAAKyL,wBAAL,GAAgCxQ,UAAhC;AACA,WAAO,IAAP;AACH;;AACDyQ,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,QAAI,KAAKmD,gBAAT,EAA2B;AACvB,YAAM,IAAI3L,SAAJ,CAAc,4CAAd,CAAN;AACH;;AACD,SAAK2L,gBAAL,GAAwBnD,eAAxB;AACA,WAAO,IAAP;AACH;;AACDoD,EAAAA,0BAA0B,CAACvB,uBAAD,EAA0B;AAChD,QAAI,KAAKwB,wBAAT,EAAmC;AAC/B,YAAM,IAAI7L,SAAJ,CAAc,oDAAd,CAAN;AACH;;AACD,SAAK6L,wBAAL,GAAgCxB,uBAAhC;AACA,WAAO,IAAP;AACH;;AACDyB,EAAAA,oBAAoB,CAACxB,iBAAD,EAAoB;AACpC,QAAI,KAAKyB,kBAAT,EAA6B;AACzB,YAAM,IAAI/L,SAAJ,CAAc,8CAAd,CAAN;AACH;;AACD,SAAK+L,kBAAL,GAA0BzB,iBAA1B;AACA,WAAO,IAAP;AACH;;AACD0B,EAAAA,8BAA8B,CAACnK,GAAD,EAAM;AAChC,SAAKoK,IAAL,GAAYpK,GAAZ;AACA,WAAO,IAAP;AACH;;AACDqK,EAAAA,uBAAuB,CAACvL,GAAD,EAAM;AACzB,QAAI,KAAKwL,IAAT,EAAe;AACX,YAAM,IAAInM,SAAJ,CAAc,iDAAd,CAAN;AACH;;AACD,SAAKmM,IAAL,GAAYxL,GAAZ;AACA,WAAO,IAAP;AACH;;AACDyL,EAAAA,uBAAuB,CAAC3L,EAAD,EAAK;AACxB,QAAI,KAAK4L,GAAT,EAAc;AACV,YAAM,IAAIrM,SAAJ,CAAc,iDAAd,CAAN;AACH;;AACD,SAAKqM,GAAL,GAAW5L,EAAX;AACA,WAAO,IAAP;AACH;;AACY,QAAP0F,OAAO,CAAC3E,GAAD,EAAMiI,OAAN,EAAe;AACxB,QAAI,CAAC,KAAKkC,gBAAN,IAA0B,CAAC,KAAKI,kBAAhC,IAAsD,CAAC,KAAKF,wBAAhE,EAA0F;AACtF,YAAM,IAAI7R,UAAJ,CAAe,8GAAf,CAAN;AACH;;AACD,QAAI,CAACS,UAAU,CAAC,KAAKkR,gBAAN,EAAwB,KAAKI,kBAA7B,EAAiD,KAAKF,wBAAtD,CAAf,EAAgG;AAC5F,YAAM,IAAI7R,UAAJ,CAAe,4GAAf,CAAN;AACH;;AACD,UAAM8N,UAAU,GAAG,EACf,GAAG,KAAK6D,gBADO;AAEf,SAAG,KAAKI,kBAFO;AAGf,SAAG,KAAKF;AAHO,KAAnB;AAKAR,IAAAA,iBAAiB,CAAC5B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAChB,IAA3D,EAAiE,KAAKkD,gBAAtE,EAAwF7D,UAAxF,CAAjB;;AACA,QAAIA,UAAU,CAACiC,GAAX,KAAmB/I,SAAvB,EAAkC;AAC9B,UAAI,CAAC,KAAK2K,gBAAN,IAA0B,CAAC,KAAKA,gBAAL,CAAsB5B,GAArD,EAA0D;AACtD,cAAM,IAAI/P,UAAJ,CAAe,sEAAf,CAAN;AACH;;AACD,UAAI8N,UAAU,CAACiC,GAAX,KAAmB,KAAvB,EAA8B;AAC1B,cAAM,IAAIjQ,gBAAJ,CAAqB,sEAArB,CAAN;AACH;AACJ;;AACD,UAAM;AAAEiD,MAAAA,GAAF;AAAOyD,MAAAA;AAAP,QAAesH,UAArB;;AACA,QAAI,OAAO/K,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,YAAM,IAAI/C,UAAJ,CAAe,2DAAf,CAAN;AACH;;AACD,QAAI,OAAOwG,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,YAAM,IAAIxG,UAAJ,CAAe,sEAAf,CAAN;AACH;;AACD,QAAI2J,YAAJ;;AACA,QAAI5G,GAAG,KAAK,KAAZ,EAAmB;AACf,UAAI,KAAKoP,IAAT,EAAe;AACX,cAAM,IAAInM,SAAJ,CAAc,uEAAd,CAAN;AACH;AACJ,KAJD,MAKK,IAAIjD,GAAG,KAAK,SAAZ,EAAuB;AACxB,UAAI,KAAKoP,IAAT,EAAe;AACX,cAAM,IAAInM,SAAJ,CAAc,0EAAd,CAAN;AACH;AACJ;;AACD,QAAIW,GAAJ;AACA;AACI,UAAI1F,UAAJ;AACA,OAAC;AAAE0F,QAAAA,GAAF;AAAOgD,QAAAA,YAAP;AAAqB1I,QAAAA;AAArB,UAAoC,MAAM6P,oBAAoB,CAAC/N,GAAD,EAAMyD,GAAN,EAAWgB,GAAX,EAAgB,KAAK2K,IAArB,EAA2B,KAAKV,wBAAhC,CAA/D;;AACA,UAAIxQ,UAAJ,EAAgB;AACZ,YAAI,CAAC,KAAK0Q,gBAAV,EAA4B;AACxB,eAAKD,kBAAL,CAAwBzQ,UAAxB;AACH,SAFD,MAGK;AACD,eAAK0Q,gBAAL,GAAwB,EAAE,GAAG,KAAKA,gBAAV;AAA4B,eAAG1Q;AAA/B,WAAxB;AACH;AACJ;AACJ;AACD,SAAKoR,GAAL,KAAa,KAAKA,GAAL,GAAWjB,UAAU,CAAC5K,GAAD,CAAlC;AACA,QAAIoC,cAAJ;AACA,QAAI4F,eAAJ;AACA,QAAI8D,SAAJ;;AACA,QAAI,KAAKX,gBAAT,EAA2B;AACvBnD,MAAAA,eAAe,GAAGxM,OAAO,CAACiB,MAAR,CAAeyB,QAAQ,CAACoL,IAAI,CAACyC,SAAL,CAAe,KAAKZ,gBAApB,CAAD,CAAvB,CAAlB;AACH,KAFD,MAGK;AACDnD,MAAAA,eAAe,GAAGxM,OAAO,CAACiB,MAAR,CAAe,EAAf,CAAlB;AACH;;AACD,QAAI,KAAKgP,IAAT,EAAe;AACXK,MAAAA,SAAS,GAAG5N,QAAQ,CAAC,KAAKuN,IAAN,CAApB;AACArJ,MAAAA,cAAc,GAAGvG,MAAM,CAACmM,eAAD,EAAkBxM,OAAO,CAACiB,MAAR,CAAe,GAAf,CAAlB,EAAuCjB,OAAO,CAACiB,MAAR,CAAeqP,SAAf,CAAvC,CAAvB;AACH,KAHD,MAIK;AACD1J,MAAAA,cAAc,GAAG4F,eAAjB;AACH;;AACD,QAAI7G,UAAJ;AACA,QAAIC,GAAJ;;AACA,QAAIkG,UAAU,CAACiC,GAAX,KAAmB,KAAvB,EAA8B;AAC1B,YAAMyC,QAAQ,GAAG,MAAM,CAAC,CAAC/C,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACgD,UAA3D,KAA0ExJ,OAA3E,EAAoF,KAAKsI,UAAzF,CAAvB;AACA,OAAC;AAAE5J,QAAAA,UAAF;AAAcC,QAAAA;AAAd,UAAsB,MAAMuE,OAAO,CAAC3F,GAAD,EAAMgM,QAAN,EAAgB7L,GAAhB,EAAqB,KAAK0L,GAA1B,EAA+BzJ,cAA/B,CAApC;AACH,KAHD,MAIK;AACD,OAAC;AAAEjB,QAAAA,UAAF;AAAcC,QAAAA;AAAd,UAAsB,MAAMuE,OAAO,CAAC3F,GAAD,EAAM,KAAK+K,UAAX,EAAuB5K,GAAvB,EAA4B,KAAK0L,GAAjC,EAAsCzJ,cAAtC,CAApC;AACH;;AACD,UAAM4G,GAAG,GAAG;AACR7H,MAAAA,UAAU,EAAEjD,QAAQ,CAACiD,UAAD,CADZ;AAERlB,MAAAA,EAAE,EAAE/B,QAAQ,CAAC,KAAK2N,GAAN,CAFJ;AAGRzK,MAAAA,GAAG,EAAElD,QAAQ,CAACkD,GAAD;AAHL,KAAZ;;AAKA,QAAI+B,YAAJ,EAAkB;AACd6F,MAAAA,GAAG,CAACI,aAAJ,GAAoBlL,QAAQ,CAACiF,YAAD,CAA5B;AACH;;AACD,QAAI2I,SAAJ,EAAe;AACX9C,MAAAA,GAAG,CAAC3H,GAAJ,GAAUyK,SAAV;AACH;;AACD,QAAI,KAAKX,gBAAT,EAA2B;AACvBnC,MAAAA,GAAG,CAACE,SAAJ,GAAgBxN,OAAO,CAACuD,MAAR,CAAe+I,eAAf,CAAhB;AACH;;AACD,QAAI,KAAKqD,wBAAT,EAAmC;AAC/BrC,MAAAA,GAAG,CAACG,WAAJ,GAAkB,KAAKkC,wBAAvB;AACH;;AACD,QAAI,KAAKE,kBAAT,EAA6B;AACzBvC,MAAAA,GAAG,CAACxO,MAAJ,GAAa,KAAK+Q,kBAAlB;AACH;;AACD,WAAOvC,GAAP;AACH;;AArJkB;;AAwJvB,MAAMkD,cAAN,CAAqB;AACjBtT,EAAAA,WAAW,CAACoJ,SAAD,EAAY;AACnB,SAAKmK,UAAL,GAAkB,IAAIrB,gBAAJ,CAAqB9I,SAArB,CAAlB;AACH;;AACD0J,EAAAA,uBAAuB,CAACvL,GAAD,EAAM;AACzB,SAAKgM,UAAL,CAAgBT,uBAAhB,CAAwCvL,GAAxC;;AACA,WAAO,IAAP;AACH;;AACDyL,EAAAA,uBAAuB,CAAC3L,EAAD,EAAK;AACxB,SAAKkM,UAAL,CAAgBP,uBAAhB,CAAwC3L,EAAxC;;AACA,WAAO,IAAP;AACH;;AACDiL,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,SAAKmE,UAAL,CAAgBjB,kBAAhB,CAAmClD,eAAnC;;AACA,WAAO,IAAP;AACH;;AACDgD,EAAAA,0BAA0B,CAACvQ,UAAD,EAAa;AACnC,SAAK0R,UAAL,CAAgBnB,0BAAhB,CAA2CvQ,UAA3C;;AACA,WAAO,IAAP;AACH;;AACY,QAAPkL,OAAO,CAAC3E,GAAD,EAAMiI,OAAN,EAAe;AACxB,UAAMD,GAAG,GAAG,MAAM,KAAKmD,UAAL,CAAgBxG,OAAhB,CAAwB3E,GAAxB,EAA6BiI,OAA7B,CAAlB;AACA,WAAO,CAACD,GAAG,CAACE,SAAL,EAAgBF,GAAG,CAACI,aAApB,EAAmCJ,GAAG,CAAC/I,EAAvC,EAA2C+I,GAAG,CAAC7H,UAA/C,EAA2D6H,GAAG,CAAC5H,GAA/D,EAAoEvC,IAApE,CAAyE,GAAzE,CAAP;AACH;;AAvBgB;;AA0BrB,eAAeuN,cAAf,CAA8BpD,GAA9B,EAAmChI,GAAnC,EAAwCiI,OAAxC,EAAiD;AAC7C,MAAI,CAAChO,QAAQ,CAAC+N,GAAD,CAAb,EAAoB;AAChB,UAAM,IAAIxP,UAAJ,CAAe,+BAAf,CAAN;AACH;;AACD,MAAI,CAAC0O,KAAK,CAACC,OAAN,CAAca,GAAG,CAACqD,UAAlB,CAAD,IAAkC,CAACrD,GAAG,CAACqD,UAAJ,CAAeC,KAAf,CAAqBrR,QAArB,CAAvC,EAAuE;AACnE,UAAM,IAAIzB,UAAJ,CAAe,0CAAf,CAAN;AACH;;AACD,OAAK,MAAM+S,SAAX,IAAwBvD,GAAG,CAACqD,UAA5B,EAAwC;AACpC,QAAI;AACA,aAAO,MAAMtD,gBAAgB,CAAC;AAC1B1H,QAAAA,GAAG,EAAE2H,GAAG,CAAC3H,GADiB;AAE1BF,QAAAA,UAAU,EAAE6H,GAAG,CAAC7H,UAFU;AAG1BiI,QAAAA,aAAa,EAAEmD,SAAS,CAACnD,aAHC;AAI1B5O,QAAAA,MAAM,EAAE+R,SAAS,CAAC/R,MAJQ;AAK1ByF,QAAAA,EAAE,EAAE+I,GAAG,CAAC/I,EALkB;AAM1BiJ,QAAAA,SAAS,EAAEF,GAAG,CAACE,SANW;AAO1B9H,QAAAA,GAAG,EAAE4H,GAAG,CAAC5H,GAPiB;AAQ1B+H,QAAAA,WAAW,EAAEH,GAAG,CAACG;AARS,OAAD,EAS1BnI,GAT0B,EASrBiI,OATqB,CAA7B;AAUH,KAXD,CAYA,OAAO1J,EAAP,EAAW,CACV;AACJ;;AACD,QAAM,IAAIhG,mBAAJ,EAAN;AACH;;AAED,eAAeiT,WAAf,CAA2BxE,eAA3B,EAA4CyE,KAA5C,EAAmD;AAC/C,QAAMnF,UAAU,GAAG,EACf,GAAGU,eADY;AAEf,OAAGyE,KAAK,CAACjS;AAFM,GAAnB;;AAIA,MAAI,CAACS,QAAQ,CAACqM,UAAU,CAAChB,GAAZ,CAAb,EAA+B;AAC3B,UAAM,IAAI7M,UAAJ,CAAe,6DAAf,CAAN;AACH;;AACD,QAAMuH,GAAG,GAAG,MAAMiG,QAAQ,CAACK,UAAU,CAAChB,GAAZ,EAAiBgB,UAAU,CAAC/K,GAA5B,EAAiC,IAAjC,CAA1B;;AACA,MAAIyE,GAAG,CAAC0L,IAAJ,KAAa,QAAjB,EAA2B;AACvB,UAAM,IAAIjT,UAAJ,CAAe,4DAAf,CAAN;AACH;;AACD,SAAOuH,GAAP;AACH;;AAED,MAAM2L,KAAK,GAAG,CAAClU,KAAD,EAAQmU,WAAR,KAAwB;AAClC,MAAI,OAAOnU,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAlC,EAAyC;AACrC,UAAM,IAAIkB,UAAJ,CAAgB,GAAEiT,WAAY,qBAA9B,CAAN;AACH;AACJ,CAJD;;AAKA,eAAeC,mBAAf,CAAmCvG,GAAnC,EAAwCwG,eAAe,GAAG,QAA1D,EAAoE;AAChE,MAAI,CAAC7R,QAAQ,CAACqL,GAAD,CAAb,EAAoB;AAChB,UAAM,IAAI9G,SAAJ,CAAc,uBAAd,CAAN;AACH;;AACD,MAAIuN,UAAJ;;AACA,UAAQzG,GAAG,CAACE,GAAZ;AACI,SAAK,IAAL;AACImG,MAAAA,KAAK,CAACrG,GAAG,CAACI,GAAL,EAAU,yBAAV,CAAL;AACAiG,MAAAA,KAAK,CAACrG,GAAG,CAACoE,CAAL,EAAQ,8BAAR,CAAL;AACAiC,MAAAA,KAAK,CAACrG,GAAG,CAACqE,CAAL,EAAQ,8BAAR,CAAL;AACAoC,MAAAA,UAAU,GAAG;AAAErG,QAAAA,GAAG,EAAEJ,GAAG,CAACI,GAAX;AAAgBF,QAAAA,GAAG,EAAEF,GAAG,CAACE,GAAzB;AAA8BkE,QAAAA,CAAC,EAAEpE,GAAG,CAACoE,CAArC;AAAwCC,QAAAA,CAAC,EAAErE,GAAG,CAACqE;AAA/C,OAAb;AACA;;AACJ,SAAK,KAAL;AACIgC,MAAAA,KAAK,CAACrG,GAAG,CAACI,GAAL,EAAU,uCAAV,CAAL;AACAiG,MAAAA,KAAK,CAACrG,GAAG,CAACoE,CAAL,EAAQ,4BAAR,CAAL;AACAqC,MAAAA,UAAU,GAAG;AAAErG,QAAAA,GAAG,EAAEJ,GAAG,CAACI,GAAX;AAAgBF,QAAAA,GAAG,EAAEF,GAAG,CAACE,GAAzB;AAA8BkE,QAAAA,CAAC,EAAEpE,GAAG,CAACoE;AAArC,OAAb;AACA;;AACJ,SAAK,KAAL;AACIiC,MAAAA,KAAK,CAACrG,GAAG,CAAC0G,CAAL,EAAQ,0BAAR,CAAL;AACAL,MAAAA,KAAK,CAACrG,GAAG,CAAC2G,CAAL,EAAQ,yBAAR,CAAL;AACAF,MAAAA,UAAU,GAAG;AAAEC,QAAAA,CAAC,EAAE1G,GAAG,CAAC0G,CAAT;AAAYxG,QAAAA,GAAG,EAAEF,GAAG,CAACE,GAArB;AAA0ByG,QAAAA,CAAC,EAAE3G,GAAG,CAAC2G;AAAjC,OAAb;AACA;;AACJ,SAAK,KAAL;AACIN,MAAAA,KAAK,CAACrG,GAAG,CAACQ,CAAL,EAAQ,2BAAR,CAAL;AACAiG,MAAAA,UAAU,GAAG;AAAEjG,QAAAA,CAAC,EAAER,GAAG,CAACQ,CAAT;AAAYN,QAAAA,GAAG,EAAEF,GAAG,CAACE;AAArB,OAAb;AACA;;AACJ;AACI,YAAM,IAAIlN,gBAAJ,CAAqB,mDAArB,CAAN;AAtBR;;AAwBA,QAAMgK,IAAI,GAAG9H,OAAO,CAACiB,MAAR,CAAe6M,IAAI,CAACyC,SAAL,CAAegB,UAAf,CAAf,CAAb;AACA,SAAO7O,QAAQ,CAAC,MAAMb,MAAM,CAACyP,eAAD,EAAkBxJ,IAAlB,CAAb,CAAf;AACH;;AAED,MAAM4J,SAAS,GAAG,OAAOC,GAAP,EAAYC,OAAZ,KAAwB;AACtC,MAAIC,UAAJ;;AACA,MAAI,OAAOC,eAAP,KAA2B,UAA/B,EAA2C;AACvCD,IAAAA,UAAU,GAAG,IAAIC,eAAJ,EAAb;AACAC,IAAAA,UAAU,CAAC,MAAMF,UAAU,CAACG,KAAX,EAAP,EAA2BJ,OAA3B,CAAV;AACH;;AACD,QAAMK,QAAQ,GAAG,MAAMxP,YAAY,CAACyP,KAAb,CAAmBP,GAAG,CAACQ,IAAvB,EAA6B;AAChDC,IAAAA,MAAM,EAAEP,UAAU,GAAGA,UAAU,CAACO,MAAd,GAAuBpN,SADO;AAEhDqN,IAAAA,QAAQ,EAAE,QAFsC;AAGhDC,IAAAA,cAAc,EAAE,aAHgC;AAIhDC,IAAAA,WAAW,EAAE,MAJmC;AAKhDC,IAAAA,IAAI,EAAE,MAL0C;AAMhDC,IAAAA,MAAM,EAAE;AANwC,GAA7B,CAAvB;;AAQA,MAAIR,QAAQ,CAACS,MAAT,KAAoB,GAAxB,EAA6B;AACzB,UAAM,IAAIxV,SAAJ,CAAc,yDAAd,CAAN;AACH;;AACD,MAAI;AACA,WAAO,MAAM+U,QAAQ,CAACU,IAAT,EAAb;AACH,GAFD,CAGA,OAAO7L,GAAP,EAAY;AACR,UAAM,IAAI5J,SAAJ,CAAc,4DAAd,CAAN;AACH;AACJ,CAvBD;;AAyBA,SAAS0V,aAAT,CAAuB7R,GAAvB,EAA4B;AACxB,UAAQA,GAAG,CAAC+D,MAAJ,CAAW,CAAX,EAAc,CAAd,CAAR;AACI,SAAK,IAAL;AACA,SAAK,IAAL;AACI,aAAO,KAAP;;AACJ,SAAK,IAAL;AACI,aAAO,IAAP;;AACJ,SAAK,IAAL;AACI,aAAO,KAAP;;AACJ;AACI,YAAM,IAAIhH,gBAAJ,CAAqB,gDAArB,CAAN;AATR;AAWH;;AACD,SAAS+U,SAAT,CAAmBrN,GAAnB,EAAwB;AACpB,SAAO/F,QAAQ,CAAC+F,GAAD,CAAf;AACH;;AACD,MAAMsN,YAAN,CAAmB;AACf1V,EAAAA,WAAW,CAACuU,GAAD,EAAMlE,OAAN,EAAe;AACtB,SAAKsF,OAAL,GAAe,IAAIC,OAAJ,EAAf;;AACA,QAAI,EAAErB,GAAG,YAAYsB,GAAjB,CAAJ,EAA2B;AACvB,YAAM,IAAIjP,SAAJ,CAAc,gCAAd,CAAN;AACH;;AACD,SAAKkP,IAAL,GAAY,IAAID,GAAJ,CAAQtB,GAAG,CAACQ,IAAZ,CAAZ;AACA,SAAKgB,QAAL,GAAgB;AAAEC,MAAAA,KAAK,EAAE3F,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC2F;AAAnE,KAAhB;AACA,SAAKC,gBAAL,GACI,QAAQ5F,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC6F,eAAlE,MAAuF,QAAvF,GAAkG7F,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC6F,eAA5J,GAA8K,IADlL;AAEA,SAAKC,iBAAL,GACI,QAAQ9F,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC+F,gBAAlE,MAAwF,QAAxF,GAAmG/F,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC+F,gBAA7J,GAAgL,KADpL;AAEH;;AACDC,EAAAA,WAAW,GAAG;AACV,QAAI,OAAO,KAAKC,gBAAZ,KAAiC,WAArC,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,WAAOC,IAAI,CAACC,GAAL,KAAa,KAAKF,gBAAL,GAAwB,KAAKH,iBAAjD;AACH;;AACW,QAANM,MAAM,CAACrH,eAAD,EAAkB;AAC1B,QAAI,CAAC,KAAKsH,KAAV,EAAiB;AACb,YAAM,KAAKC,MAAL,EAAN;AACH;;AACD,UAAMC,UAAU,GAAG,KAAKF,KAAL,CAAW5U,IAAX,CAAgBN,MAAhB,CAAwBkM,GAAD,IAAS;AAC/C,UAAImJ,SAAS,GAAGnJ,GAAG,CAACE,GAAJ,KAAY4H,aAAa,CAACpG,eAAe,CAACzL,GAAjB,CAAzC;;AACA,UAAIkT,SAAS,IAAI,OAAOzH,eAAe,CAAC0H,GAAvB,KAA+B,QAAhD,EAA0D;AACtDD,QAAAA,SAAS,GAAGzH,eAAe,CAAC0H,GAAhB,KAAwBpJ,GAAG,CAACoJ,GAAxC;AACH;;AACD,UAAID,SAAS,IAAI,OAAOnJ,GAAG,CAAC/J,GAAX,KAAmB,QAApC,EAA8C;AAC1CkT,QAAAA,SAAS,GAAGzH,eAAe,CAACzL,GAAhB,KAAwB+J,GAAG,CAAC/J,GAAxC;AACH;;AACD,UAAIkT,SAAS,IAAI,OAAOnJ,GAAG,CAAC6D,GAAX,KAAmB,QAApC,EAA8C;AAC1CsF,QAAAA,SAAS,GAAGnJ,GAAG,CAAC6D,GAAJ,KAAY,KAAxB;AACH;;AACD,UAAIsF,SAAS,IAAIvH,KAAK,CAACC,OAAN,CAAc7B,GAAG,CAACU,OAAlB,CAAjB,EAA6C;AACzCyI,QAAAA,SAAS,GAAGnJ,GAAG,CAACU,OAAJ,CAAYjD,QAAZ,CAAqB,QAArB,CAAZ;AACH;;AACD,UAAI0L,SAAS,IAAIzH,eAAe,CAACzL,GAAhB,KAAwB,OAAzC,EAAkD;AAC9CkT,QAAAA,SAAS,GAAG,CAAC,SAAD,EAAY,OAAZ,EAAqB1L,QAArB,CAA8BuC,GAAG,CAACI,GAAlC,CAAZ;AACH;;AACD,UAAI+I,SAAJ,EAAe;AACX,gBAAQzH,eAAe,CAACzL,GAAxB;AACI,eAAK,OAAL;AACIkT,YAAAA,SAAS,GAAGnJ,GAAG,CAACI,GAAJ,KAAY,OAAxB;AACA;;AACJ,eAAK,QAAL;AACI+I,YAAAA,SAAS,GAAGnJ,GAAG,CAACI,GAAJ,KAAY,WAAxB;AACA;;AACJ,eAAK,OAAL;AACI+I,YAAAA,SAAS,GAAGnJ,GAAG,CAACI,GAAJ,KAAY,OAAxB;AACA;;AACJ,eAAK,OAAL;AACI+I,YAAAA,SAAS,GAAGnJ,GAAG,CAACI,GAAJ,KAAY,OAAxB;AACA;AAZR;AAcH;;AACD,aAAO+I,SAAP;AACH,KAlCkB,CAAnB;;AAmCA,UAAM;AAAE,SAAGnJ,GAAL;AAAUhM,MAAAA;AAAV,QAAqBkV,UAA3B;;AACA,QAAIlV,MAAM,KAAK,CAAf,EAAkB;AACd,UAAI,KAAK2U,WAAL,OAAuB,KAA3B,EAAkC;AAC9B,cAAM,KAAKM,MAAL,EAAN;AACA,eAAO,KAAKF,MAAL,CAAYrH,eAAZ,CAAP;AACH;;AACD,YAAM,IAAInO,iBAAJ,EAAN;AACH,KAND,MAOK,IAAIS,MAAM,KAAK,CAAf,EAAkB;AACnB,YAAM,IAAIR,wBAAJ,EAAN;AACH;;AACD,QAAI,CAAC,KAAKyU,OAAL,CAAazT,GAAb,CAAiBwL,GAAjB,CAAL,EAA4B;AACxB,WAAKiI,OAAL,CAAalS,GAAb,CAAiBiK,GAAjB,EAAsB,EAAtB;AACH;;AACD,UAAMqJ,MAAM,GAAG,KAAKpB,OAAL,CAAazO,GAAb,CAAiBwG,GAAjB,CAAf;;AACA,QAAIqJ,MAAM,CAAC3H,eAAe,CAACzL,GAAjB,CAAN,KAAgCiE,SAApC,EAA+C;AAC3C,YAAMoP,SAAS,GAAI,MAAM3I,QAAQ,CAAC,EAAE,GAAGX,GAAL;AAAU/J,QAAAA,GAAG,EAAEyL,eAAe,CAACzL;AAA/B,OAAD,CAAjC;;AACA,UAAIqT,SAAS,CAAClD,IAAV,KAAmB,QAAvB,EAAiC;AAC7B,cAAM,IAAI9S,WAAJ,CAAgB,8CAAhB,CAAN;AACH;;AACD+V,MAAAA,MAAM,CAAC3H,eAAe,CAACzL,GAAjB,CAAN,GAA8BqT,SAA9B;AACH;;AACD,WAAOD,MAAM,CAAC3H,eAAe,CAACzL,GAAjB,CAAb;AACH;;AACW,QAANgT,MAAM,GAAG;AACX,QAAI,CAAC,KAAKM,aAAV,EAAyB;AACrB,WAAKA,aAAL,GAAqB3C,SAAS,CAAC,KAAKwB,IAAN,EAAY,KAAKG,gBAAjB,EAAmC,KAAKF,QAAxC,CAAT,CAChBmB,IADgB,CACV3B,IAAD,IAAU;AAChB,YAAI,OAAOA,IAAP,KAAgB,QAAhB,IACA,CAACA,IADD,IAEA,CAACjG,KAAK,CAACC,OAAN,CAAcgG,IAAI,CAACzT,IAAnB,CAFD,IAGA,CAACyT,IAAI,CAACzT,IAAL,CAAU4R,KAAV,CAAgB+B,SAAhB,CAHL,EAGiC;AAC7B,gBAAM,IAAIzU,WAAJ,CAAgB,4BAAhB,CAAN;AACH;;AACD,aAAK0V,KAAL,GAAa;AAAE5U,UAAAA,IAAI,EAAEyT,IAAI,CAACzT;AAAb,SAAb;AACA,aAAKwU,gBAAL,GAAwBC,IAAI,CAACC,GAAL,EAAxB;AACA,aAAKS,aAAL,GAAqBrP,SAArB;AACH,OAXoB,EAYhBuP,KAZgB,CAYTzN,GAAD,IAAS;AAChB,aAAKuN,aAAL,GAAqBrP,SAArB;AACA,cAAM8B,GAAN;AACH,OAfoB,CAArB;AAgBH;;AACD,UAAM,KAAKuN,aAAX;AACH;;AAtGc;;AAwGnB,SAASG,kBAAT,CAA4B7C,GAA5B,EAAiClE,OAAjC,EAA0C;AACtC,QAAM5M,GAAG,GAAG,IAAIiS,YAAJ,CAAiBnB,GAAjB,EAAsBlE,OAAtB,CAAZ;AACA,SAAO5M,GAAG,CAACgT,MAAJ,CAAW5K,IAAX,CAAgBpI,GAAhB,CAAP;AACH;;AAED,SAAS4T,SAAT,CAAmB1T,GAAnB,EAAwB;AACpB,UAAQA,GAAR;AACI,SAAK,OAAL;AACI,aAAO;AAAEoF,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE;AAAnC,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAE4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE;AAAnC,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAE4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE;AAAnC,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AACH4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SADH;AAEHA,QAAAA,IAAI,EAAE,SAFH;AAGHmX,QAAAA,UAAU,EAAE,OAAO;AAHhB,OAAP;;AAKJ,SAAK,OAAL;AACI,aAAO;AACHvO,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SADH;AAEHA,QAAAA,IAAI,EAAE,SAFH;AAGHmX,QAAAA,UAAU,EAAE,OAAO;AAHhB,OAAP;;AAKJ,SAAK,OAAL;AACI,aAAO;AACHvO,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SADH;AAEHA,QAAAA,IAAI,EAAE,SAFH;AAGHmX,QAAAA,UAAU,EAAE,OAAO;AAHhB,OAAP;;AAKJ,SAAK,OAAL;AACI,aAAO;AAAEvO,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE;AAAnC,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAE4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE;AAAnC,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAE4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE;AAAnC,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAE4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE,OAAnC;AAA4CoL,QAAAA,UAAU,EAAE;AAAxD,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAExC,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE,OAAnC;AAA4CoL,QAAAA,UAAU,EAAE;AAAxD,OAAP;;AACJ,SAAK,OAAL;AACI,aAAO;AAAExC,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAE;AAAR,SAAR;AAA6BA,QAAAA,IAAI,EAAE,OAAnC;AAA4CoL,QAAAA,UAAU,EAAE;AAAxD,OAAP;;AACJ;AACI,YAAM,IAAI7K,gBAAJ,CAAsB,OAAMiD,GAAI,6DAAhC,CAAN;AAtCR;AAwCH;;AAED,SAAS4T,YAAT,CAAsB5T,GAAtB,EAA2ByE,GAA3B,EAAgC6B,KAAhC,EAAuC;AACnC,MAAI9B,WAAW,CAACC,GAAD,CAAf,EAAsB;AAClB,WAAOA,GAAP;AACH;;AACD,MAAIA,GAAG,YAAY/E,UAAnB,EAA+B;AAC3B,QAAI,CAACM,GAAG,CAACgJ,UAAJ,CAAe,IAAf,CAAL,EAA2B;AACvB,YAAM,IAAI/F,SAAJ,CAAc,8DAAd,CAAN;AACH;;AACD,WAAOsB,MAAM,CAACU,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BT,GAA/B,EAAoC;AAAEW,MAAAA,IAAI,EAAE;AAAE5I,QAAAA,IAAI,EAAG,OAAMwD,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAe;AAA9B,OAAR;AAA2CvH,MAAAA,IAAI,EAAE;AAAjD,KAApC,EAA+F,KAA/F,EAAsG,CAAC8J,KAAD,CAAtG,CAAP;AACH;;AACD,QAAM,IAAIrD,SAAJ,CAAc,mBAAd,CAAN;AACH;;AAED,MAAMsC,IAAI,GAAG,OAAOvF,GAAP,EAAYyE,GAAZ,EAAiBsC,IAAjB,KAA0B;AACnC,QAAMP,SAAS,GAAG,MAAMoN,YAAY,CAAC5T,GAAD,EAAMyE,GAAN,EAAW,MAAX,CAApC;AACAsE,EAAAA,cAAc,CAAC/I,GAAD,EAAMwG,SAAN,CAAd;AACA,QAAMqN,SAAS,GAAG,MAAMtP,MAAM,CAACU,MAAP,CAAcM,IAAd,CAAmBmO,SAAS,CAAC1T,GAAD,CAA5B,EAAmCwG,SAAnC,EAA8CO,IAA9C,CAAxB;AACA,SAAO,IAAIrH,UAAJ,CAAemU,SAAf,CAAP;AACH,CALD;;AAOA,MAAMC,YAAY,GAAG,CAAC9T,GAAD,EAAMyE,GAAN,KAAc;AAC/B,MAAIzE,GAAG,CAACgJ,UAAJ,CAAe,IAAf,KACAhJ,GAAG,KAAK,KADR,IAEAA,GAAG,CAACgJ,UAAJ,CAAe,OAAf,CAFA,IAGAhJ,GAAG,CAAC+T,KAAJ,CAAU,mBAAV,CAHJ,EAGoC;AAChC,QAAItP,GAAG,YAAY/E,UAAf,IAA6B+E,GAAG,CAAC0L,IAAJ,KAAa,QAA9C,EAAwD;AACpD;AACH;;AACD,UAAM,IAAIlN,SAAJ,CAAc,oFAAd,CAAN;AACH;;AACD,MAAIwB,GAAG,YAAY/E,UAAnB,EAA+B;AAC3B,UAAM,IAAIuD,SAAJ,CAAc,yEAAd,CAAN;AACH;;AACD,MAAIwB,GAAG,CAAC0L,IAAJ,KAAa,QAAjB,EAA2B;AACvB,UAAM,IAAIlN,SAAJ,CAAc,yFAAd,CAAN;AACH;AACJ,CAhBD;;AAkBA,MAAM+Q,iBAAiB,GAAG3I,YAAY,CAACnD,IAAb,CAAkBjE,SAAlB,EAA6B/G,UAA7B,EAAyC,IAAIiG,GAAJ,CAAQ,CAAC,CAAC,KAAD,EAAQ,IAAR,CAAD,CAAR,CAAzC,CAA1B;;AACA,MAAM8Q,aAAN,CAAoB;AAChB5X,EAAAA,WAAW,CAAC6X,OAAD,EAAU;AACjB,SAAKC,QAAL,GAAgBD,OAAhB;AACH;;AACDvF,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,QAAI,KAAKmD,gBAAT,EAA2B;AACvB,YAAM,IAAI3L,SAAJ,CAAc,4CAAd,CAAN;AACH;;AACD,SAAK2L,gBAAL,GAAwBnD,eAAxB;AACA,WAAO,IAAP;AACH;;AACDsD,EAAAA,oBAAoB,CAACxB,iBAAD,EAAoB;AACpC,QAAI,KAAKyB,kBAAT,EAA6B;AACzB,YAAM,IAAI/L,SAAJ,CAAc,8CAAd,CAAN;AACH;;AACD,SAAK+L,kBAAL,GAA0BzB,iBAA1B;AACA,WAAO,IAAP;AACH;;AACS,QAAJhI,IAAI,CAACd,GAAD,EAAMiI,OAAN,EAAe;AACrB,QAAI,CAAC,KAAKkC,gBAAN,IAA0B,CAAC,KAAKI,kBAApC,EAAwD;AACpD,YAAM,IAAI9R,UAAJ,CAAe,iFAAf,CAAN;AACH;;AACD,QAAI,CAACQ,UAAU,CAAC,KAAKkR,gBAAN,EAAwB,KAAKI,kBAA7B,CAAf,EAAiE;AAC7D,YAAM,IAAI9R,UAAJ,CAAe,2EAAf,CAAN;AACH;;AACD,UAAM6N,UAAU,GAAG,EACf,GAAG,KAAK6D,gBADO;AAEf,SAAG,KAAKI;AAFO,KAAnB;AAIA,UAAMoF,UAAU,GAAGJ,iBAAiB,CAACtH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAChB,IAA3D,EAAiE,KAAKkD,gBAAtE,EAAwF7D,UAAxF,CAApC;AACA,QAAIsJ,GAAG,GAAG,IAAV;;AACA,QAAID,UAAU,CAAC7V,GAAX,CAAe,KAAf,CAAJ,EAA2B;AACvB8V,MAAAA,GAAG,GAAG,KAAKzF,gBAAL,CAAsByF,GAA5B;;AACA,UAAI,OAAOA,GAAP,KAAe,SAAnB,EAA8B;AAC1B,cAAM,IAAInX,UAAJ,CAAe,yEAAf,CAAN;AACH;AACJ;;AACD,UAAM;AAAE8C,MAAAA;AAAF,QAAU+K,UAAhB;;AACA,QAAI,OAAO/K,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,YAAM,IAAI9C,UAAJ,CAAe,2DAAf,CAAN;AACH;;AACD4W,IAAAA,YAAY,CAAC9T,GAAD,EAAMyE,GAAN,CAAZ;AACA,QAAIyP,OAAO,GAAG,KAAKC,QAAnB;;AACA,QAAIE,GAAJ,EAAS;AACLH,MAAAA,OAAO,GAAGjV,OAAO,CAACiB,MAAR,CAAeyB,QAAQ,CAACuS,OAAD,CAAvB,CAAV;AACH;;AACD,QAAIzI,eAAJ;;AACA,QAAI,KAAKmD,gBAAT,EAA2B;AACvBnD,MAAAA,eAAe,GAAGxM,OAAO,CAACiB,MAAR,CAAeyB,QAAQ,CAACoL,IAAI,CAACyC,SAAL,CAAe,KAAKZ,gBAApB,CAAD,CAAvB,CAAlB;AACH,KAFD,MAGK;AACDnD,MAAAA,eAAe,GAAGxM,OAAO,CAACiB,MAAR,CAAe,EAAf,CAAlB;AACH;;AACD,UAAM6G,IAAI,GAAGzH,MAAM,CAACmM,eAAD,EAAkBxM,OAAO,CAACiB,MAAR,CAAe,GAAf,CAAlB,EAAuCgU,OAAvC,CAAnB;AACA,UAAML,SAAS,GAAG,MAAMtO,IAAI,CAACvF,GAAD,EAAMyE,GAAN,EAAWsC,IAAX,CAA5B;AACA,UAAMuN,GAAG,GAAG;AACRT,MAAAA,SAAS,EAAElS,QAAQ,CAACkS,SAAD;AADX,KAAZ;;AAGA,QAAIQ,GAAJ,EAAS;AACLC,MAAAA,GAAG,CAACJ,OAAJ,GAAc/U,OAAO,CAACuD,MAAR,CAAewR,OAAf,CAAd;AACH;;AACD,QAAI,KAAKlF,kBAAT,EAA6B;AACzBsF,MAAAA,GAAG,CAACrW,MAAJ,GAAa,KAAK+Q,kBAAlB;AACH;;AACD,QAAI,KAAKJ,gBAAT,EAA2B;AACvB0F,MAAAA,GAAG,CAAC3H,SAAJ,GAAgBxN,OAAO,CAACuD,MAAR,CAAe+I,eAAf,CAAhB;AACH;;AACD,WAAO6I,GAAP;AACH;;AApEe;;AAuEpB,MAAMC,WAAN,CAAkB;AACdlY,EAAAA,WAAW,CAAC6X,OAAD,EAAU;AACjB,SAAKtE,UAAL,GAAkB,IAAIqE,aAAJ,CAAkBC,OAAlB,CAAlB;AACH;;AACDvF,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,SAAKmE,UAAL,CAAgBjB,kBAAhB,CAAmClD,eAAnC;;AACA,WAAO,IAAP;AACH;;AACS,QAAJlG,IAAI,CAACd,GAAD,EAAMiI,OAAN,EAAe;AACrB,UAAM4H,GAAG,GAAG,MAAM,KAAK1E,UAAL,CAAgBrK,IAAhB,CAAqBd,GAArB,EAA0BiI,OAA1B,CAAlB;;AACA,QAAI4H,GAAG,CAACJ,OAAJ,KAAgBjQ,SAApB,EAA+B;AAC3B,YAAM,IAAIhB,SAAJ,CAAc,2DAAd,CAAN;AACH;;AACD,WAAQ,GAAEqR,GAAG,CAAC3H,SAAU,IAAG2H,GAAG,CAACJ,OAAQ,IAAGI,GAAG,CAACT,SAAU,EAAxD;AACH;;AAda;;AAiBlB,MAAMW,MAAM,GAAG,OAAOxU,GAAP,EAAYyE,GAAZ,EAAiBoP,SAAjB,EAA4B9M,IAA5B,KAAqC;AAChD,QAAMP,SAAS,GAAG,MAAMoN,YAAY,CAAC5T,GAAD,EAAMyE,GAAN,EAAW,QAAX,CAApC;AACAsE,EAAAA,cAAc,CAAC/I,GAAD,EAAMwG,SAAN,CAAd;AACA,QAAMxC,SAAS,GAAG0P,SAAS,CAAC1T,GAAD,CAA3B;;AACA,MAAI;AACA,WAAO,MAAMuE,MAAM,CAACU,MAAP,CAAcuP,MAAd,CAAqBxQ,SAArB,EAAgCwC,SAAhC,EAA2CqN,SAA3C,EAAsD9M,IAAtD,CAAb;AACH,GAFD,CAGA,OAAO/D,EAAP,EAAW;AACP,WAAO,KAAP;AACH;AACJ,CAVD;;AAYA,MAAMyR,eAAe,GAAGpJ,YAAY,CAACnD,IAAb,CAAkBjE,SAAlB,EAA6B/G,UAA7B,EAAyC,IAAIiG,GAAJ,CAAQ,CAAC,CAAC,KAAD,EAAQ,IAAR,CAAD,CAAR,CAAzC,CAAxB;AACA,MAAMuR,cAAc,GAAG1I,kBAAkB,CAAC9D,IAAnB,CAAwBjE,SAAxB,EAAmC,YAAnC,CAAvB;;AACA,eAAe0Q,eAAf,CAA+BL,GAA/B,EAAoC7P,GAApC,EAAyCiI,OAAzC,EAAkD;AAC9C,MAAI1J,EAAJ;;AACA,MAAI,CAACtE,QAAQ,CAAC4V,GAAD,CAAb,EAAoB;AAChB,UAAM,IAAIpX,UAAJ,CAAe,iCAAf,CAAN;AACH;;AACD,MAAIoX,GAAG,CAAC3H,SAAJ,KAAkB1I,SAAlB,IAA+BqQ,GAAG,CAACrW,MAAJ,KAAegG,SAAlD,EAA6D;AACzD,UAAM,IAAI/G,UAAJ,CAAe,uEAAf,CAAN;AACH;;AACD,MAAIoX,GAAG,CAAC3H,SAAJ,KAAkB1I,SAAlB,IAA+B,OAAOqQ,GAAG,CAAC3H,SAAX,KAAyB,QAA5D,EAAsE;AAClE,UAAM,IAAIzP,UAAJ,CAAe,qCAAf,CAAN;AACH;;AACD,MAAIoX,GAAG,CAACJ,OAAJ,KAAgBjQ,SAApB,EAA+B;AAC3B,UAAM,IAAI/G,UAAJ,CAAe,qBAAf,CAAN;AACH;;AACD,MAAI,OAAOoX,GAAG,CAACT,SAAX,KAAyB,QAA7B,EAAuC;AACnC,UAAM,IAAI3W,UAAJ,CAAe,yCAAf,CAAN;AACH;;AACD,MAAIoX,GAAG,CAACrW,MAAJ,KAAegG,SAAf,IAA4B,CAACvF,QAAQ,CAAC4V,GAAG,CAACrW,MAAL,CAAzC,EAAuD;AACnD,UAAM,IAAIf,UAAJ,CAAe,uCAAf,CAAN;AACH;;AACD,MAAI4P,UAAU,GAAG,EAAjB;;AACA,MAAIwH,GAAG,CAAC3H,SAAR,EAAmB;AACf,UAAMlB,eAAe,GAAGjJ,QAAQ,CAAC8R,GAAG,CAAC3H,SAAL,CAAhC;AACAG,IAAAA,UAAU,GAAGC,IAAI,CAAC3C,KAAL,CAAWjL,OAAO,CAACuD,MAAR,CAAe+I,eAAf,CAAX,CAAb;AACH;;AACD,MAAI,CAAC/N,UAAU,CAACoP,UAAD,EAAawH,GAAG,CAACrW,MAAjB,CAAf,EAAyC;AACrC,UAAM,IAAIf,UAAJ,CAAe,2EAAf,CAAN;AACH;;AACD,QAAM6N,UAAU,GAAG,EACf,GAAG+B,UADY;AAEf,OAAGwH,GAAG,CAACrW;AAFQ,GAAnB;AAIA,QAAMmW,UAAU,GAAGK,eAAe,CAAC/H,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAChB,IAA3D,EAAiEoB,UAAjE,EAA6E/B,UAA7E,CAAlC;AACA,MAAIsJ,GAAG,GAAG,IAAV;;AACA,MAAID,UAAU,CAAC7V,GAAX,CAAe,KAAf,CAAJ,EAA2B;AACvB8V,IAAAA,GAAG,GAAGvH,UAAU,CAACuH,GAAjB;;AACA,QAAI,OAAOA,GAAP,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAInX,UAAJ,CAAe,yEAAf,CAAN;AACH;AACJ;;AACD,QAAM;AAAE8C,IAAAA;AAAF,MAAU+K,UAAhB;;AACA,MAAI,OAAO/K,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACjC,UAAM,IAAI9C,UAAJ,CAAe,2DAAf,CAAN;AACH;;AACD,QAAMgP,UAAU,GAAGQ,OAAO,IAAIgI,cAAc,CAAChI,OAAO,CAACR,UAAT,CAA5C;;AACA,MAAIA,UAAU,IAAI,CAACA,UAAU,CAAC3N,GAAX,CAAeyB,GAAf,CAAnB,EAAwC;AACpC,UAAM,IAAInD,iBAAJ,CAAsB,gDAAtB,CAAN;AACH;;AACD,MAAIwX,GAAJ,EAAS;AACL,QAAI,OAAOC,GAAG,CAACJ,OAAX,KAAuB,QAA3B,EAAqC;AACjC,YAAM,IAAIhX,UAAJ,CAAe,8BAAf,CAAN;AACH;AACJ,GAJD,MAKK,IAAI,OAAOoX,GAAG,CAACJ,OAAX,KAAuB,QAAvB,IAAmC,EAAEI,GAAG,CAACJ,OAAJ,YAAuBxU,UAAzB,CAAvC,EAA6E;AAC9E,UAAM,IAAIxC,UAAJ,CAAe,wDAAf,CAAN;AACH;;AACD,MAAI,OAAOuH,GAAP,KAAe,UAAnB,EAA+B;AAC3BA,IAAAA,GAAG,GAAG,MAAMA,GAAG,CAACqI,UAAD,EAAawH,GAAb,CAAf;AACH;;AACDR,EAAAA,YAAY,CAAC9T,GAAD,EAAMyE,GAAN,CAAZ;AACA,QAAMsC,IAAI,GAAGzH,MAAM,CAACL,OAAO,CAACiB,MAAR,CAAe,CAAC8C,EAAE,GAAGsR,GAAG,CAAC3H,SAAV,MAAyB,IAAzB,IAAiC3J,EAAE,KAAK,KAAK,CAA7C,GAAiDA,EAAjD,GAAsD,EAArE,CAAD,EAA2E/D,OAAO,CAACiB,MAAR,CAAe,GAAf,CAA3E,EAAgG,OAAOoU,GAAG,CAACJ,OAAX,KAAuB,QAAvB,GAAkCjV,OAAO,CAACiB,MAAR,CAAeoU,GAAG,CAACJ,OAAnB,CAAlC,GAAgEI,GAAG,CAACJ,OAApK,CAAnB;AACA,QAAML,SAAS,GAAGrR,QAAQ,CAAC8R,GAAG,CAACT,SAAL,CAA1B;AACA,QAAMe,QAAQ,GAAG,MAAMJ,MAAM,CAACxU,GAAD,EAAMyE,GAAN,EAAWoP,SAAX,EAAsB9M,IAAtB,CAA7B;;AACA,MAAI,CAAC6N,QAAL,EAAe;AACX,UAAM,IAAIpX,8BAAJ,EAAN;AACH;;AACD,MAAI0W,OAAJ;;AACA,MAAIG,GAAJ,EAAS;AACLH,IAAAA,OAAO,GAAG1R,QAAQ,CAAC8R,GAAG,CAACJ,OAAL,CAAlB;AACH,GAFD,MAGK,IAAI,OAAOI,GAAG,CAACJ,OAAX,KAAuB,QAA3B,EAAqC;AACtCA,IAAAA,OAAO,GAAGjV,OAAO,CAACiB,MAAR,CAAeoU,GAAG,CAACJ,OAAnB,CAAV;AACH,GAFI,MAGA;AACDA,IAAAA,OAAO,GAAGI,GAAG,CAACJ,OAAd;AACH;;AACD,QAAM9G,MAAM,GAAG;AAAE8G,IAAAA;AAAF,GAAf;;AACA,MAAII,GAAG,CAAC3H,SAAJ,KAAkB1I,SAAtB,EAAiC;AAC7BmJ,IAAAA,MAAM,CAAC3B,eAAP,GAAyBqB,UAAzB;AACH;;AACD,MAAIwH,GAAG,CAACrW,MAAJ,KAAegG,SAAnB,EAA8B;AAC1BmJ,IAAAA,MAAM,CAACG,iBAAP,GAA2B+G,GAAG,CAACrW,MAA/B;AACH;;AACD,SAAOmP,MAAP;AACH;;AAED,eAAeyH,aAAf,CAA6BP,GAA7B,EAAkC7P,GAAlC,EAAuCiI,OAAvC,EAAgD;AAC5C,MAAI4H,GAAG,YAAY5U,UAAnB,EAA+B;AAC3B4U,IAAAA,GAAG,GAAGnV,OAAO,CAACuD,MAAR,CAAe4R,GAAf,CAAN;AACH;;AACD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzB,UAAM,IAAIpX,UAAJ,CAAe,4CAAf,CAAN;AACH;;AACD,QAAM;AAAE,OAAGuO,eAAL;AAAsB,OAAGyI,OAAzB;AAAkC,OAAGL,SAArC;AAAgD9V,IAAAA;AAAhD,MAA2DuW,GAAG,CAAC1R,KAAJ,CAAU,GAAV,CAAjE;;AACA,MAAI7E,MAAM,KAAK,CAAf,EAAkB;AACd,UAAM,IAAIb,UAAJ,CAAe,qBAAf,CAAN;AACH;;AACD,QAAM0X,QAAQ,GAAG,MAAMD,eAAe,CAAC;AACnCT,IAAAA,OAAO,EAAGA,OAAO,IAAIjQ,SADc;AAEnC0I,IAAAA,SAAS,EAAElB,eAAe,IAAIxH,SAFK;AAGnC4P,IAAAA,SAAS,EAAGA,SAAS,IAAI5P;AAHU,GAAD,EAInCQ,GAJmC,EAI9BiI,OAJ8B,CAAtC;AAKA,SAAO;AAAEwH,IAAAA,OAAO,EAAEU,QAAQ,CAACV,OAApB;AAA6BzI,IAAAA,eAAe,EAAEmJ,QAAQ,CAACnJ;AAAvD,GAAP;AACH;;AAED,MAAMqJ,YAAY,GAAG,IAAI7C,OAAJ,EAArB;;AACA,MAAM8C,mBAAN,CAA0B;AACtBpG,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,QAAI,KAAKmD,gBAAT,EAA2B;AACvB,YAAM,IAAI3L,SAAJ,CAAc,4CAAd,CAAN;AACH;;AACD,SAAK2L,gBAAL,GAAwBnD,eAAxB;AACA,WAAO,IAAP;AACH;;AACDsD,EAAAA,oBAAoB,CAACxB,iBAAD,EAAoB;AACpC,QAAI,KAAKyB,kBAAT,EAA6B;AACzB,YAAM,IAAI/L,SAAJ,CAAc,8CAAd,CAAN;AACH;;AACD,SAAK+L,kBAAL,GAA0BzB,iBAA1B;AACA,WAAO,IAAP;AACH;;AACmB,MAAhBqB,gBAAgB,CAAC1S,KAAD,EAAQ;AACxB4Y,IAAAA,YAAY,CAACvR,GAAb,CAAiB,IAAjB,EAAuBkI,eAAvB,GAAyCvP,KAAzC;AACH;;AACmB,MAAhB0S,gBAAgB,GAAG;AACnB,WAAOkG,YAAY,CAACvR,GAAb,CAAiB,IAAjB,EAAuBkI,eAA9B;AACH;;AACqB,MAAlBuD,kBAAkB,CAAC9S,KAAD,EAAQ;AAC1B4Y,IAAAA,YAAY,CAACvR,GAAb,CAAiB,IAAjB,EAAuBgK,iBAAvB,GAA2CrR,KAA3C;AACH;;AACqB,MAAlB8S,kBAAkB,GAAG;AACrB,WAAO8F,YAAY,CAACvR,GAAb,CAAiB,IAAjB,EAAuBgK,iBAA9B;AACH;;AA1BqB;;AA4B1B,MAAMyH,WAAN,CAAkB;AACd3Y,EAAAA,WAAW,CAAC6X,OAAD,EAAU;AACjB,SAAKe,WAAL,GAAmB,EAAnB;AACA,SAAKd,QAAL,GAAgBD,OAAhB;AACH;;AACDgB,EAAAA,YAAY,CAACzQ,GAAD,EAAMiI,OAAN,EAAe;AACvB,UAAMmH,SAAS,GAAG,IAAIkB,mBAAJ,EAAlB;AACAD,IAAAA,YAAY,CAAChV,GAAb,CAAiB+T,SAAjB,EAA4B;AAAEpP,MAAAA,GAAF;AAAOiI,MAAAA;AAAP,KAA5B;;AACA,SAAKuI,WAAL,CAAiBlT,IAAjB,CAAsB8R,SAAtB;;AACA,WAAOA,SAAP;AACH;;AACS,QAAJtO,IAAI,GAAG;AACT,QAAI,CAAC,KAAK0P,WAAL,CAAiBlX,MAAtB,EAA8B;AAC1B,YAAM,IAAIb,UAAJ,CAAe,sCAAf,CAAN;AACH;;AACD,UAAMoX,GAAG,GAAG;AACRa,MAAAA,UAAU,EAAE;AADJ,KAAZ;AAGA,UAAMC,OAAO,CAACC,GAAR,CAAY,KAAKJ,WAAL,CAAiBpS,GAAjB,CAAqB,OAAOyS,GAAP,EAAY3V,CAAZ,KAAkB;AACrD,YAAM;AAAE8L,QAAAA,eAAF;AAAmB8B,QAAAA,iBAAnB;AAAsCb,QAAAA,OAAtC;AAA+CjI,QAAAA;AAA/C,UAAuDqQ,YAAY,CAACvR,GAAb,CAAiB+R,GAAjB,CAA7D;AACA,YAAMC,SAAS,GAAG,IAAItB,aAAJ,CAAkB,KAAKE,QAAvB,CAAlB;;AACA,UAAI1I,eAAJ,EAAqB;AACjB8J,QAAAA,SAAS,CAAC5G,kBAAV,CAA6BlD,eAA7B;AACH;;AACD,UAAI8B,iBAAJ,EAAuB;AACnBgI,QAAAA,SAAS,CAACxG,oBAAV,CAA+BxB,iBAA/B;AACH;;AACD,YAAM;AAAE2G,QAAAA,OAAF;AAAW,WAAGsB;AAAd,UAAuB,MAAMD,SAAS,CAAChQ,IAAV,CAAed,GAAf,EAAoBiI,OAApB,CAAnC;;AACA,UAAI,aAAa4H,GAAb,IAAoBA,GAAG,CAACJ,OAAJ,KAAgBA,OAAxC,EAAiD;AAC7C,cAAM,IAAIhX,UAAJ,CAAgB,SAAQyC,CAAE,yCAA1B,CAAN;AACH,OAFD,MAGK;AACD2U,QAAAA,GAAG,CAACJ,OAAJ,GAAcA,OAAd;AACH;;AACDI,MAAAA,GAAG,CAACa,UAAJ,CAAepT,IAAf,CAAoByT,IAApB;AACH,KAjBiB,CAAZ,CAAN;;AAkBA,QAAI,aAAalB,GAAb,IAAoBA,GAAG,CAACJ,OAAJ,KAAgBjQ,SAAxC,EAAmD;AAC/C,aAAOqQ,GAAG,CAACJ,OAAX;AACH;;AACD,WAAOI,GAAP;AACH;;AAxCa;;AA2ClB,eAAemB,aAAf,CAA6BnB,GAA7B,EAAkC7P,GAAlC,EAAuCiI,OAAvC,EAAgD;AAC5C,MAAI,CAAChO,QAAQ,CAAC4V,GAAD,CAAb,EAAoB;AAChB,UAAM,IAAIpX,UAAJ,CAAe,+BAAf,CAAN;AACH;;AACD,MAAI,CAACyO,KAAK,CAACC,OAAN,CAAc0I,GAAG,CAACa,UAAlB,CAAD,IAAkC,CAACb,GAAG,CAACa,UAAJ,CAAepF,KAAf,CAAqBrR,QAArB,CAAvC,EAAuE;AACnE,UAAM,IAAIxB,UAAJ,CAAe,0CAAf,CAAN;AACH;;AACD,OAAK,MAAM2W,SAAX,IAAwBS,GAAG,CAACa,UAA5B,EAAwC;AACpC,QAAI;AACA,aAAO,MAAMR,eAAe,CAAC;AACzB1W,QAAAA,MAAM,EAAE4V,SAAS,CAAC5V,MADO;AAEzBiW,QAAAA,OAAO,EAAEI,GAAG,CAACJ,OAFY;AAGzBvH,QAAAA,SAAS,EAAEkH,SAAS,CAAClH,SAHI;AAIzBkH,QAAAA,SAAS,EAAEA,SAAS,CAACA;AAJI,OAAD,EAKzBpP,GALyB,EAKpBiI,OALoB,CAA5B;AAMH,KAPD,CAQA,OAAO1J,EAAP,EAAW,CACV;AACJ;;AACD,QAAM,IAAIxF,8BAAJ,EAAN;AACH;;AAED,IAAIkY,KAAK,GAAIC,IAAD,IAAUnV,IAAI,CAACC,KAAL,CAAWkV,IAAI,CAACC,OAAL,KAAiB,IAA5B,CAAtB;;AAEA,MAAMC,MAAM,GAAG,EAAf;AACA,MAAMC,IAAI,GAAGD,MAAM,GAAG,EAAtB;AACA,MAAME,GAAG,GAAGD,IAAI,GAAG,EAAnB;AACA,MAAME,IAAI,GAAGD,GAAG,GAAG,CAAnB;AACA,MAAME,IAAI,GAAGF,GAAG,GAAG,MAAnB;AACA,MAAMG,KAAK,GAAG,qGAAd;;AACA,IAAIC,IAAI,GAAIC,GAAD,IAAS;AAChB,QAAMC,OAAO,GAAGH,KAAK,CAACI,IAAN,CAAWF,GAAX,CAAhB;;AACA,MAAI,CAACC,OAAL,EAAc;AACV,UAAM,IAAIpT,SAAJ,CAAc,4BAAd,CAAN;AACH;;AACD,QAAM/G,KAAK,GAAGqa,UAAU,CAACF,OAAO,CAAC,CAAD,CAAR,CAAxB;AACA,QAAMG,IAAI,GAAGH,OAAO,CAAC,CAAD,CAAP,CAAWI,WAAX,EAAb;;AACA,UAAQD,IAAR;AACI,SAAK,KAAL;AACA,SAAK,MAAL;AACA,SAAK,QAAL;AACA,SAAK,SAAL;AACA,SAAK,GAAL;AACI,aAAOhW,IAAI,CAACkW,KAAL,CAAWxa,KAAX,CAAP;;AACJ,SAAK,QAAL;AACA,SAAK,SAAL;AACA,SAAK,KAAL;AACA,SAAK,MAAL;AACA,SAAK,GAAL;AACI,aAAOsE,IAAI,CAACkW,KAAL,CAAWxa,KAAK,GAAG2Z,MAAnB,CAAP;;AACJ,SAAK,MAAL;AACA,SAAK,OAAL;AACA,SAAK,IAAL;AACA,SAAK,KAAL;AACA,SAAK,GAAL;AACI,aAAOrV,IAAI,CAACkW,KAAL,CAAWxa,KAAK,GAAG4Z,IAAnB,CAAP;;AACJ,SAAK,KAAL;AACA,SAAK,MAAL;AACA,SAAK,GAAL;AACI,aAAOtV,IAAI,CAACkW,KAAL,CAAWxa,KAAK,GAAG6Z,GAAnB,CAAP;;AACJ,SAAK,MAAL;AACA,SAAK,OAAL;AACA,SAAK,GAAL;AACI,aAAOvV,IAAI,CAACkW,KAAL,CAAWxa,KAAK,GAAG8Z,IAAnB,CAAP;;AACJ;AACI,aAAOxV,IAAI,CAACkW,KAAL,CAAWxa,KAAK,GAAG+Z,IAAnB,CAAP;AA5BR;AA8BH,CArCD;;AAuCA,MAAMU,YAAY,GAAIza,KAAD,IAAWA,KAAK,CAACua,WAAN,GAAoBlU,OAApB,CAA4B,gBAA5B,EAA8C,EAA9C,CAAhC;;AACA,MAAMqU,qBAAqB,GAAG,CAACC,UAAD,EAAaC,SAAb,KAA2B;AACrD,MAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AAChC,WAAOC,SAAS,CAACtP,QAAV,CAAmBqP,UAAnB,CAAP;AACH;;AACD,MAAIlL,KAAK,CAACC,OAAN,CAAciL,UAAd,CAAJ,EAA+B;AAC3B,WAAOC,SAAS,CAACjL,IAAV,CAAexN,GAAG,CAACO,SAAJ,CAAcL,GAAd,CAAkB2J,IAAlB,CAAuB,IAAI7J,GAAJ,CAAQwY,UAAR,CAAvB,CAAf,CAAP;AACH;;AACD,SAAO,KAAP;AACH,CARD;;AASA,IAAIE,UAAU,GAAG,CAACtL,eAAD,EAAkBuL,cAAlB,EAAkCtK,OAAO,GAAG,EAA5C,KAAmD;AAChE,QAAM;AAAEuK,IAAAA;AAAF,MAAUvK,OAAhB;;AACA,MAAIuK,GAAG,KACF,OAAOxL,eAAe,CAACwL,GAAvB,KAA+B,QAA/B,IACGN,YAAY,CAAClL,eAAe,CAACwL,GAAjB,CAAZ,KAAsCN,YAAY,CAACM,GAAD,CAFnD,CAAP,EAEkE;AAC9D,UAAM,IAAIva,wBAAJ,CAA6B,mCAA7B,EAAkE,KAAlE,EAAyE,cAAzE,CAAN;AACH;;AACD,MAAIwX,OAAJ;;AACA,MAAI;AACAA,IAAAA,OAAO,GAAGnH,IAAI,CAAC3C,KAAL,CAAWjL,OAAO,CAACuD,MAAR,CAAesU,cAAf,CAAX,CAAV;AACH,GAFD,CAGA,OAAOhU,EAAP,EAAW,CACV;;AACD,MAAI,CAACtE,QAAQ,CAACwV,OAAD,CAAb,EAAwB;AACpB,UAAM,IAAI/W,UAAJ,CAAe,gDAAf,CAAN;AACH;;AACD,QAAM;AAAE+Z,IAAAA;AAAF,MAAaxK,OAAnB;;AACA,MAAIwK,MAAM,IAAI,CAAC,CAACvL,KAAK,CAACC,OAAN,CAAcsL,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAAlC,EAA4C1P,QAA5C,CAAqD0M,OAAO,CAACiD,GAA7D,CAAf,EAAkF;AAC9E,UAAM,IAAIza,wBAAJ,CAA6B,8BAA7B,EAA6D,KAA7D,EAAoE,cAApE,CAAN;AACH;;AACD,QAAM;AAAE0a,IAAAA;AAAF,MAAc1K,OAApB;;AACA,MAAI0K,OAAO,IAAIlD,OAAO,CAACmD,GAAR,KAAgBD,OAA/B,EAAwC;AACpC,UAAM,IAAI1a,wBAAJ,CAA6B,8BAA7B,EAA6D,KAA7D,EAAoE,cAApE,CAAN;AACH;;AACD,QAAM;AAAE4a,IAAAA;AAAF,MAAe5K,OAArB;;AACA,MAAI4K,QAAQ,IACR,CAACV,qBAAqB,CAAC1C,OAAO,CAACqD,GAAT,EAAc,OAAOD,QAAP,KAAoB,QAApB,GAA+B,CAACA,QAAD,CAA/B,GAA4CA,QAA1D,CAD1B,EAC+F;AAC3F,UAAM,IAAI5a,wBAAJ,CAA6B,8BAA7B,EAA6D,KAA7D,EAAoE,cAApE,CAAN;AACH;;AACD,MAAI8a,SAAJ;;AACA,UAAQ,OAAO9K,OAAO,CAAC+K,cAAvB;AACI,SAAK,QAAL;AACID,MAAAA,SAAS,GAAGrB,IAAI,CAACzJ,OAAO,CAAC+K,cAAT,CAAhB;AACA;;AACJ,SAAK,QAAL;AACID,MAAAA,SAAS,GAAG9K,OAAO,CAAC+K,cAApB;AACA;;AACJ,SAAK,WAAL;AACID,MAAAA,SAAS,GAAG,CAAZ;AACA;;AACJ;AACI,YAAM,IAAIvU,SAAJ,CAAc,oCAAd,CAAN;AAXR;;AAaA,QAAM;AAAEyU,IAAAA;AAAF,MAAkBhL,OAAxB;AACA,QAAMmG,GAAG,GAAG6C,KAAK,CAACgC,WAAW,IAAI,IAAI9E,IAAJ,EAAhB,CAAjB;;AACA,MAAIsB,OAAO,CAACyD,GAAR,KAAgB1T,SAAhB,IAA6ByI,OAAO,CAACkL,WAAzC,EAAsD;AAClD,QAAI,OAAO1D,OAAO,CAACyD,GAAf,KAAuB,QAA3B,EAAqC;AACjC,YAAM,IAAIjb,wBAAJ,CAA6B,8BAA7B,EAA6D,KAA7D,EAAoE,SAApE,CAAN;AACH;;AACD,QAAIwX,OAAO,CAAC2D,GAAR,KAAgB5T,SAAhB,IAA6BiQ,OAAO,CAACyD,GAAR,GAAc9E,GAAG,GAAG2E,SAArD,EAAgE;AAC5D,YAAM,IAAI9a,wBAAJ,CAA6B,+DAA7B,EAA8F,KAA9F,EAAqG,cAArG,CAAN;AACH;AACJ;;AACD,MAAIwX,OAAO,CAAC4D,GAAR,KAAgB7T,SAApB,EAA+B;AAC3B,QAAI,OAAOiQ,OAAO,CAAC4D,GAAf,KAAuB,QAA3B,EAAqC;AACjC,YAAM,IAAIpb,wBAAJ,CAA6B,8BAA7B,EAA6D,KAA7D,EAAoE,SAApE,CAAN;AACH;;AACD,QAAIwX,OAAO,CAAC4D,GAAR,GAAcjF,GAAG,GAAG2E,SAAxB,EAAmC;AAC/B,YAAM,IAAI9a,wBAAJ,CAA6B,oCAA7B,EAAmE,KAAnE,EAA0E,cAA1E,CAAN;AACH;AACJ;;AACD,MAAIwX,OAAO,CAAC2D,GAAR,KAAgB5T,SAApB,EAA+B;AAC3B,QAAI,OAAOiQ,OAAO,CAAC2D,GAAf,KAAuB,QAA3B,EAAqC;AACjC,YAAM,IAAInb,wBAAJ,CAA6B,8BAA7B,EAA6D,KAA7D,EAAoE,SAApE,CAAN;AACH;;AACD,QAAIwX,OAAO,CAAC2D,GAAR,IAAehF,GAAG,GAAG2E,SAAzB,EAAoC;AAChC,YAAM,IAAI/Z,UAAJ,CAAe,oCAAf,EAAqD,KAArD,EAA4D,cAA5D,CAAN;AACH;AACJ;;AACD,MAAIiP,OAAO,CAACkL,WAAZ,EAAyB;AACrB,UAAMG,GAAG,GAAGlF,GAAG,GAAGqB,OAAO,CAACyD,GAA1B;AACA,UAAMK,GAAG,GAAG,OAAOtL,OAAO,CAACkL,WAAf,KAA+B,QAA/B,GAA0ClL,OAAO,CAACkL,WAAlD,GAAgEzB,IAAI,CAACzJ,OAAO,CAACkL,WAAT,CAAhF;;AACA,QAAIG,GAAG,GAAGP,SAAN,GAAkBQ,GAAtB,EAA2B;AACvB,YAAM,IAAIva,UAAJ,CAAe,0DAAf,EAA2E,KAA3E,EAAkF,cAAlF,CAAN;AACH;;AACD,QAAIsa,GAAG,GAAG,IAAIP,SAAd,EAAyB;AACrB,YAAM,IAAI9a,wBAAJ,CAA6B,+DAA7B,EAA8F,KAA9F,EAAqG,cAArG,CAAN;AACH;AACJ;;AACD,SAAOwX,OAAP;AACH,CAhFD;;AAkFA,eAAe+D,UAAf,CAA0BC,GAA1B,EAA+BzT,GAA/B,EAAoCiI,OAApC,EAA6C;AACzC,QAAMe,SAAS,GAAG,MAAMD,cAAc,CAAC0K,GAAD,EAAMzT,GAAN,EAAWiI,OAAX,CAAtC;AACA,QAAMwH,OAAO,GAAG6C,UAAU,CAACtJ,SAAS,CAAChC,eAAX,EAA4BgC,SAAS,CAAChI,SAAtC,EAAiDiH,OAAjD,CAA1B;AACA,QAAM;AAAEjB,IAAAA;AAAF,MAAsBgC,SAA5B;;AACA,MAAIhC,eAAe,CAAC0L,GAAhB,KAAwBlT,SAAxB,IAAqCwH,eAAe,CAAC0L,GAAhB,KAAwBjD,OAAO,CAACiD,GAAzE,EAA8E;AAC1E,UAAM,IAAIza,wBAAJ,CAA6B,kDAA7B,EAAiF,KAAjF,EAAwF,UAAxF,CAAN;AACH;;AACD,MAAI+O,eAAe,CAAC4L,GAAhB,KAAwBpT,SAAxB,IAAqCwH,eAAe,CAAC4L,GAAhB,KAAwBnD,OAAO,CAACmD,GAAzE,EAA8E;AAC1E,UAAM,IAAI3a,wBAAJ,CAA6B,kDAA7B,EAAiF,KAAjF,EAAwF,UAAxF,CAAN;AACH;;AACD,MAAI+O,eAAe,CAAC8L,GAAhB,KAAwBtT,SAAxB,IACA8I,IAAI,CAACyC,SAAL,CAAe/D,eAAe,CAAC8L,GAA/B,MAAwCxK,IAAI,CAACyC,SAAL,CAAe0E,OAAO,CAACqD,GAAvB,CAD5C,EACyE;AACrE,UAAM,IAAI7a,wBAAJ,CAA6B,kDAA7B,EAAiF,KAAjF,EAAwF,UAAxF,CAAN;AACH;;AACD,SAAO;AAAEwX,IAAAA,OAAF;AAAWzI,IAAAA;AAAX,GAAP;AACH;;AAED,MAAM0M,UAAN,CAAiB;AACb9b,EAAAA,WAAW,CAAC6X,OAAD,EAAU;AACjB,QAAI,CAACxV,QAAQ,CAACwV,OAAD,CAAb,EAAwB;AACpB,YAAM,IAAIjR,SAAJ,CAAc,kCAAd,CAAN;AACH;;AACD,SAAKkR,QAAL,GAAgBD,OAAhB;AACH;;AACDkE,EAAAA,SAAS,CAAClB,MAAD,EAAS;AACd,SAAK/C,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoBgD,MAAAA,GAAG,EAAED;AAAzB,KAAhB;AACA,WAAO,IAAP;AACH;;AACDmB,EAAAA,UAAU,CAACjB,OAAD,EAAU;AAChB,SAAKjD,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoBkD,MAAAA,GAAG,EAAED;AAAzB,KAAhB;AACA,WAAO,IAAP;AACH;;AACDkB,EAAAA,WAAW,CAAChB,QAAD,EAAW;AAClB,SAAKnD,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoBoD,MAAAA,GAAG,EAAED;AAAzB,KAAhB;AACA,WAAO,IAAP;AACH;;AACDiB,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,SAAKrE,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoBsE,MAAAA,GAAG,EAAED;AAAzB,KAAhB;AACA,WAAO,IAAP;AACH;;AACDE,EAAAA,YAAY,CAAC/Z,KAAD,EAAQ;AAChB,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAKwV,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoB2D,QAAAA,GAAG,EAAEnZ;AAAzB,OAAhB;AACH,KAFD,MAGK;AACD,WAAKwV,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoB2D,QAAAA,GAAG,EAAEpC,KAAK,CAAC,IAAI9C,IAAJ,EAAD,CAAL,GAAoBuD,IAAI,CAACxX,KAAD;AAAjD,OAAhB;AACH;;AACD,WAAO,IAAP;AACH;;AACDga,EAAAA,iBAAiB,CAACha,KAAD,EAAQ;AACrB,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAKwV,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoB0D,QAAAA,GAAG,EAAElZ;AAAzB,OAAhB;AACH,KAFD,MAGK;AACD,WAAKwV,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoB0D,QAAAA,GAAG,EAAEnC,KAAK,CAAC,IAAI9C,IAAJ,EAAD,CAAL,GAAoBuD,IAAI,CAACxX,KAAD;AAAjD,OAAhB;AACH;;AACD,WAAO,IAAP;AACH;;AACDia,EAAAA,WAAW,CAACja,KAAD,EAAQ;AACf,QAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC;AAC9B,WAAKwV,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoBwD,QAAAA,GAAG,EAAEjC,KAAK,CAAC,IAAI9C,IAAJ,EAAD;AAA9B,OAAhB;AACH,KAFD,MAGK;AACD,WAAKuB,QAAL,GAAgB,EAAE,GAAG,KAAKA,QAAV;AAAoBwD,QAAAA,GAAG,EAAEhZ;AAAzB,OAAhB;AACH;;AACD,WAAO,IAAP;AACH;;AAjDY;;AAoDjB,MAAMka,UAAN,SAAyBV,UAAzB,CAAoC;AAChCxJ,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,QAAI,KAAKmD,gBAAT,EAA2B;AACvB,YAAM,IAAI3L,SAAJ,CAAc,4CAAd,CAAN;AACH;;AACD,SAAK2L,gBAAL,GAAwBnD,eAAxB;AACA,WAAO,IAAP;AACH;;AACDgD,EAAAA,0BAA0B,CAACvQ,UAAD,EAAa;AACnC,QAAI,KAAKwQ,wBAAT,EAAmC;AAC/B,YAAM,IAAIzL,SAAJ,CAAc,oDAAd,CAAN;AACH;;AACD,SAAKyL,wBAAL,GAAgCxQ,UAAhC;AACA,WAAO,IAAP;AACH;;AACDiR,EAAAA,uBAAuB,CAACvL,GAAD,EAAM;AACzB,QAAI,KAAKwL,IAAT,EAAe;AACX,YAAM,IAAInM,SAAJ,CAAc,iDAAd,CAAN;AACH;;AACD,SAAKmM,IAAL,GAAYxL,GAAZ;AACA,WAAO,IAAP;AACH;;AACDyL,EAAAA,uBAAuB,CAAC3L,EAAD,EAAK;AACxB,QAAI,KAAK4L,GAAT,EAAc;AACV,YAAM,IAAIrM,SAAJ,CAAc,iDAAd,CAAN;AACH;;AACD,SAAKqM,GAAL,GAAW5L,EAAX;AACA,WAAO,IAAP;AACH;;AACDoV,EAAAA,uBAAuB,GAAG;AACtB,SAAKC,wBAAL,GAAgC,IAAhC;AACA,WAAO,IAAP;AACH;;AACDC,EAAAA,wBAAwB,GAAG;AACvB,SAAKC,yBAAL,GAAiC,IAAjC;AACA,WAAO,IAAP;AACH;;AACDC,EAAAA,yBAAyB,GAAG;AACxB,SAAKC,0BAAL,GAAkC,IAAlC;AACA,WAAO,IAAP;AACH;;AACY,QAAP/P,OAAO,CAAC3E,GAAD,EAAMiI,OAAN,EAAe;AACxB,UAAMjJ,GAAG,GAAG,IAAIkM,cAAJ,CAAmB1Q,OAAO,CAACiB,MAAR,CAAe6M,IAAI,CAACyC,SAAL,CAAe,KAAK2E,QAApB,CAAf,CAAnB,CAAZ;;AACA,QAAI,KAAK4E,wBAAT,EAAmC;AAC/B,WAAKnK,gBAAL,GAAwB,EAAE,GAAG,KAAKA,gBAAV;AAA4BuI,QAAAA,GAAG,EAAE,KAAKhD,QAAL,CAAcgD;AAA/C,OAAxB;AACH;;AACD,QAAI,KAAK8B,yBAAT,EAAoC;AAChC,WAAKrK,gBAAL,GAAwB,EAAE,GAAG,KAAKA,gBAAV;AAA4ByI,QAAAA,GAAG,EAAE,KAAKlD,QAAL,CAAckD;AAA/C,OAAxB;AACH;;AACD,QAAI,KAAK8B,0BAAT,EAAqC;AACjC,WAAKvK,gBAAL,GAAwB,EAAE,GAAG,KAAKA,gBAAV;AAA4B2I,QAAAA,GAAG,EAAE,KAAKpD,QAAL,CAAcoD;AAA/C,OAAxB;AACH;;AACD9T,IAAAA,GAAG,CAACkL,kBAAJ,CAAuB,KAAKC,gBAA5B;;AACA,QAAI,KAAKU,GAAT,EAAc;AACV7L,MAAAA,GAAG,CAAC4L,uBAAJ,CAA4B,KAAKC,GAAjC;AACH;;AACD,QAAI,KAAKF,IAAT,EAAe;AACX3L,MAAAA,GAAG,CAAC0L,uBAAJ,CAA4B,KAAKC,IAAjC;AACH;;AACD,QAAI,KAAKV,wBAAT,EAAmC;AAC/BjL,MAAAA,GAAG,CAACgL,0BAAJ,CAA+B,KAAKC,wBAApC;AACH;;AACD,WAAOjL,GAAG,CAAC2F,OAAJ,CAAY3E,GAAZ,EAAiBiI,OAAjB,CAAP;AACH;;AA/D+B;;AAkEpC,MAAM0M,OAAN,SAAsBjB,UAAtB,CAAiC;AAC7BxJ,EAAAA,kBAAkB,CAAClD,eAAD,EAAkB;AAChC,SAAKmD,gBAAL,GAAwBnD,eAAxB;AACA,WAAO,IAAP;AACH;;AACS,QAAJlG,IAAI,CAACd,GAAD,EAAMiI,OAAN,EAAe;AACrB,QAAI1J,EAAJ;;AACA,UAAMsS,GAAG,GAAG,IAAIf,WAAJ,CAAgBtV,OAAO,CAACiB,MAAR,CAAe6M,IAAI,CAACyC,SAAL,CAAe,KAAK2E,QAApB,CAAf,CAAhB,CAAZ;AACAmB,IAAAA,GAAG,CAAC3G,kBAAJ,CAAuB,KAAKC,gBAA5B;;AACA,QAAI,CAAC,CAAC5L,EAAE,GAAG,KAAK4L,gBAAL,CAAsBlD,IAA5B,MAAsC,IAAtC,IAA8C1I,EAAE,KAAK,KAAK,CAA1D,GAA8D,KAAK,CAAnE,GAAuEA,EAAE,CAACwE,QAAH,CAAY,KAAZ,CAAxE,KAA+F,KAAKoH,gBAAL,CAAsByF,GAAtB,KAA8B,KAAjI,EAAwI;AACpI,YAAM,IAAIlX,UAAJ,CAAe,qCAAf,CAAN;AACH;;AACD,WAAOmY,GAAG,CAAC/P,IAAJ,CAASd,GAAT,EAAciI,OAAd,CAAP;AACH;;AAb4B;;AAgBjC,MAAM2M,YAAN,SAA2BlB,UAA3B,CAAsC;AAClCjY,EAAAA,MAAM,GAAG;AACL,UAAMjC,MAAM,GAAG0D,QAAQ,CAACoL,IAAI,CAACyC,SAAL,CAAe;AAAExP,MAAAA,GAAG,EAAE;AAAP,KAAf,CAAD,CAAvB;AACA,UAAMkU,OAAO,GAAGvS,QAAQ,CAACoL,IAAI,CAACyC,SAAL,CAAe,KAAK2E,QAApB,CAAD,CAAxB;AACA,WAAQ,GAAElW,MAAO,IAAGiW,OAAQ,GAA5B;AACH;;AACY,SAANxR,MAAM,CAACwV,GAAD,EAAMxL,OAAN,EAAe;AACxB,QAAI,OAAOwL,GAAP,KAAe,QAAnB,EAA6B;AACzB,YAAM,IAAI/a,UAAJ,CAAe,gCAAf,CAAN;AACH;;AACD,UAAM;AAAE,SAAGmc,aAAL;AAAoB,SAAGtC,cAAvB;AAAuC,SAAGnD,SAA1C;AAAqD9V,MAAAA;AAArD,QAAgEma,GAAG,CAACtV,KAAJ,CAAU,GAAV,CAAtE;;AACA,QAAI7E,MAAM,KAAK,CAAX,IAAgB8V,SAAS,KAAK,EAAlC,EAAsC;AAClC,YAAM,IAAI1W,UAAJ,CAAe,uBAAf,CAAN;AACH;;AACD,QAAIc,MAAJ;;AACA,QAAI;AACAA,MAAAA,MAAM,GAAG8O,IAAI,CAAC3C,KAAL,CAAWjL,OAAO,CAACuD,MAAR,CAAeF,QAAQ,CAAC8W,aAAD,CAAvB,CAAX,CAAT;AACA,UAAIrb,MAAM,CAAC+B,GAAP,KAAe,MAAnB,EACI,MAAM,IAAI5D,KAAJ,EAAN;AACP,KAJD,CAKA,OAAO4G,EAAP,EAAW;AACP,YAAM,IAAI7F,UAAJ,CAAe,uBAAf,CAAN;AACH;;AACD,UAAM+W,OAAO,GAAG6C,UAAU,CAAC9Y,MAAD,EAASuE,QAAQ,CAACwU,cAAD,CAAjB,EAAmCtK,OAAnC,CAA1B;AACA,WAAO;AAAEwH,MAAAA,OAAF;AAAWjW,MAAAA;AAAX,KAAP;AACH;;AAzBiC;;AA4BtC,eAAesb,SAAf,CAAyBrB,GAAzB,EAA8BzT,GAA9B,EAAmCiI,OAAnC,EAA4C;AACxC,MAAI1J,EAAJ;;AACA,QAAM4R,QAAQ,GAAG,MAAMC,aAAa,CAACqD,GAAD,EAAMzT,GAAN,EAAWiI,OAAX,CAApC;;AACA,MAAI,CAAC,CAAC1J,EAAE,GAAG4R,QAAQ,CAACnJ,eAAT,CAAyBC,IAA/B,MAAyC,IAAzC,IAAiD1I,EAAE,KAAK,KAAK,CAA7D,GAAiE,KAAK,CAAtE,GAA0EA,EAAE,CAACwE,QAAH,CAAY,KAAZ,CAA3E,KAAkGoN,QAAQ,CAACnJ,eAAT,CAAyB4I,GAAzB,KAAiC,KAAvI,EAA8I;AAC1I,UAAM,IAAIlX,UAAJ,CAAe,qCAAf,CAAN;AACH;;AACD,QAAM+W,OAAO,GAAG6C,UAAU,CAACnC,QAAQ,CAACnJ,eAAV,EAA2BmJ,QAAQ,CAACV,OAApC,EAA6CxH,OAA7C,CAA1B;AACA,SAAO;AAAEwH,IAAAA,OAAF;AAAWzI,IAAAA,eAAe,EAAEmJ,QAAQ,CAACnJ;AAArC,GAAP;AACH;;AAED,MAAMvL,MAAM,GAAGyB,QAAf;AACA,MAAMe,MAAM,GAAGF,QAAf;;AAEA,SAASgX,qBAAT,CAA+BtJ,KAA/B,EAAsC;AAClC,MAAIuJ,aAAJ;;AACA,MAAI,OAAOvJ,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAMwJ,KAAK,GAAGxJ,KAAK,CAACtN,KAAN,CAAY,GAAZ,CAAd;;AACA,QAAI8W,KAAK,CAAC3b,MAAN,KAAiB,CAAjB,IAAsB2b,KAAK,CAAC3b,MAAN,KAAiB,CAA3C,EAA8C;AAC1C,OAAC0b,aAAD,IAAkBC,KAAlB;AACH;AACJ,GALD,MAMK,IAAI,OAAOxJ,KAAP,KAAiB,QAAjB,IAA6BA,KAAjC,EAAwC;AACzC,QAAI,eAAeA,KAAnB,EAA0B;AACtBuJ,MAAAA,aAAa,GAAGvJ,KAAK,CAACvD,SAAtB;AACH,KAFD,MAGK;AACD,YAAM,IAAI1J,SAAJ,CAAc,2CAAd,CAAN;AACH;AACJ;;AACD,MAAI;AACA,QAAI,OAAOwW,aAAP,KAAyB,QAAzB,IAAqC,CAACA,aAA1C,EAAyD;AACrD,YAAM,IAAIrd,KAAJ,EAAN;AACH;;AACD,UAAMgR,MAAM,GAAGL,IAAI,CAAC3C,KAAL,CAAWjL,OAAO,CAACuD,MAAR,CAAeA,MAAM,CAAC+W,aAAD,CAArB,CAAX,CAAf;;AACA,QAAI,CAAC/a,QAAQ,CAAC0O,MAAD,CAAb,EAAuB;AACnB,YAAM,IAAIhR,KAAJ,EAAN;AACH;;AACD,WAAOgR,MAAP;AACH,GATD,CAUA,OAAOrH,GAAP,EAAY;AACR,UAAM,IAAI9C,SAAJ,CAAc,8CAAd,CAAN;AACH;AACJ;;AAED,eAAe0W,gBAAf,CAAgC3Z,GAAhC,EAAqC0M,OAArC,EAA8C;AAC1C,MAAI1J,EAAJ;;AACA,MAAIjF,MAAJ;AACA,MAAIiG,SAAJ;AACA,MAAIgG,SAAJ;;AACA,UAAQhK,GAAR;AACI,SAAK,OAAL;AACA,SAAK,OAAL;AACA,SAAK,OAAL;AACIjC,MAAAA,MAAM,GAAG+F,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB,EAAjB,CAAjB;AACAC,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,MAAR;AAAgB4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAG,OAAMwD,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAe;AAA9B,SAAtB;AAAyDhG,QAAAA;AAAzD,OAAZ;AACAiM,MAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,SAAK,eAAL;AACA,SAAK,eAAL;AACA,SAAK,eAAL;AACIjM,MAAAA,MAAM,GAAG+F,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB,EAAjB,CAAjB;AACA,aAAOiE,QAAQ,CAAC,IAAItI,UAAJ,CAAe3B,MAAM,IAAI,CAAzB,CAAD,CAAf;;AACJ,SAAK,QAAL;AACA,SAAK,QAAL;AACA,SAAK,QAAL;AACIA,MAAAA,MAAM,GAAG+F,QAAQ,CAAC9D,GAAG,CAAC4Z,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAD,EAAsB,EAAtB,CAAjB;AACA5V,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,QAAR;AAAkBuB,QAAAA;AAAlB,OAAZ;AACAiM,MAAAA,SAAS,GAAG,CAAC,SAAD,EAAY,WAAZ,CAAZ;AACA;;AACJ,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACIjM,MAAAA,MAAM,GAAG+F,QAAQ,CAAC9D,GAAG,CAAC4Z,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAD,EAAsB,EAAtB,CAAjB;AACA5V,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,SAAR;AAAmBuB,QAAAA;AAAnB,OAAZ;AACAiM,MAAAA,SAAS,GAAG,CAAC,SAAD,EAAY,SAAZ,CAAZ;AACA;;AACJ;AACI,YAAM,IAAIjN,gBAAJ,CAAqB,8DAArB,CAAN;AA/BR;;AAiCA,SAAQwH,MAAM,CAACU,MAAP,CAAc6C,WAAd,CAA0B9D,SAA1B,EAAqC,CAAChB,EAAE,GAAG0J,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACiB,WAAhE,MAAiF,IAAjF,IAAyF3K,EAAE,KAAK,KAAK,CAArG,GAAyGA,EAAzG,GAA8G,KAAnJ,EAA0JgH,SAA1J,CAAR;AACH;;AACD,SAAS6P,sBAAT,CAAgCnN,OAAhC,EAAyC;AACrC,MAAI1J,EAAJ;;AACA,QAAMkG,aAAa,GAAG,CAAClG,EAAE,GAAG0J,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACxD,aAAhE,MAAmF,IAAnF,IAA2FlG,EAAE,KAAK,KAAK,CAAvG,GAA2GA,EAA3G,GAAgH,IAAtI;;AACA,MAAI,OAAOkG,aAAP,KAAyB,QAAzB,IAAqCA,aAAa,GAAG,IAAzD,EAA+D;AAC3D,UAAM,IAAInM,gBAAJ,CAAqB,6FAArB,CAAN;AACH;;AACD,SAAOmM,aAAP;AACH;;AACD,eAAe4Q,iBAAf,CAAiC9Z,GAAjC,EAAsC0M,OAAtC,EAA+C;AAC3C,MAAI1J,EAAJ,EAAQ2C,EAAR;;AACA,MAAI3B,SAAJ;AACA,MAAIgG,SAAJ;;AACA,UAAQhK,GAAR;AACI,SAAK,OAAL;AACA,SAAK,OAAL;AACA,SAAK,OAAL;AACIgE,MAAAA,SAAS,GAAG;AACRxH,QAAAA,IAAI,EAAE,SADE;AAER4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAG,OAAMwD,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAe;AAA9B,SAFE;AAGRgW,QAAAA,cAAc,EAAE,IAAIra,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAHR;AAIRwJ,QAAAA,aAAa,EAAE2Q,sBAAsB,CAACnN,OAAD;AAJ7B,OAAZ;AAMA1C,MAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,SAAK,OAAL;AACA,SAAK,OAAL;AACA,SAAK,OAAL;AACIhG,MAAAA,SAAS,GAAG;AACRxH,QAAAA,IAAI,EAAE,mBADE;AAER4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAG,OAAMwD,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAe;AAA9B,SAFE;AAGRgW,QAAAA,cAAc,EAAE,IAAIra,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAHR;AAIRwJ,QAAAA,aAAa,EAAE2Q,sBAAsB,CAACnN,OAAD;AAJ7B,OAAZ;AAMA1C,MAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,SAAK,UAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AACA,SAAK,cAAL;AACIhG,MAAAA,SAAS,GAAG;AACRxH,QAAAA,IAAI,EAAE,UADE;AAER4I,QAAAA,IAAI,EAAE;AAAE5I,UAAAA,IAAI,EAAG,OAAMsH,QAAQ,CAAC9D,GAAG,CAAC+D,MAAJ,CAAW,CAAC,CAAZ,CAAD,EAAiB,EAAjB,CAAR,IAAgC,CAAE;AAAjD,SAFE;AAGRgW,QAAAA,cAAc,EAAE,IAAIra,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAHR;AAIRwJ,QAAAA,aAAa,EAAE2Q,sBAAsB,CAACnN,OAAD;AAJ7B,OAAZ;AAMA1C,MAAAA,SAAS,GAAG,CAAC,SAAD,EAAY,WAAZ,EAAyB,SAAzB,EAAoC,SAApC,CAAZ;AACA;;AACJ,SAAK,OAAL;AACIhG,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,OAAR;AAAiBoL,QAAAA,UAAU,EAAE;AAA7B,OAAZ;AACAoC,MAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,SAAK,OAAL;AACIhG,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,OAAR;AAAiBoL,QAAAA,UAAU,EAAE;AAA7B,OAAZ;AACAoC,MAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,SAAK,OAAL;AACIhG,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,OAAR;AAAiBoL,QAAAA,UAAU,EAAE;AAA7B,OAAZ;AACAoC,MAAAA,SAAS,GAAG,CAAC,MAAD,EAAS,QAAT,CAAZ;AACA;;AACJ,SAAK,SAAL;AACA,SAAK,gBAAL;AACA,SAAK,gBAAL;AACA,SAAK,gBAAL;AACIhG,MAAAA,SAAS,GAAG;AAAExH,QAAAA,IAAI,EAAE,MAAR;AAAgBoL,QAAAA,UAAU,EAAE,CAAC5E,EAAE,GAAG0J,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACvC,GAAhE,MAAyE,IAAzE,IAAiFnH,EAAE,KAAK,KAAK,CAA7F,GAAiGA,EAAjG,GAAsG;AAAlI,OAAZ;AACAgH,MAAAA,SAAS,GAAG,CAAC,WAAD,EAAc,YAAd,CAAZ;AACA;;AACJ;AACI,YAAM,IAAIjN,gBAAJ,CAAqB,8DAArB,CAAN;AAvDR;;AAyDA,SAAQwH,MAAM,CAACU,MAAP,CAAc6C,WAAd,CAA0B9D,SAA1B,EAAqC,CAAC2B,EAAE,GAAG+G,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACiB,WAAhE,MAAiF,IAAjF,IAAyFhI,EAAE,KAAK,KAAK,CAArG,GAAyGA,EAAzG,GAA8G,KAAnJ,EAA0JqE,SAA1J,CAAR;AACH;;AAED,eAAegQ,eAAf,CAA+Bha,GAA/B,EAAoC0M,OAApC,EAA6C;AACzC,SAAOoN,iBAAiB,CAAC9Z,GAAD,EAAM0M,OAAN,CAAxB;AACH;;AAED,eAAeuN,cAAf,CAA8Bja,GAA9B,EAAmC0M,OAAnC,EAA4C;AACxC,SAAOiN,gBAAgB,CAAC3Z,GAAD,EAAM0M,OAAN,CAAvB;AACH;;AAED,MAAMrJ,MAAM,GAAG2E,QAAf;AAEA/L,OAAO,CAAC0T,cAAR,GAAyBA,cAAzB;AACA1T,OAAO,CAACsY,WAAR,GAAsBA,WAAtB;AACAtY,OAAO,CAACgU,WAAR,GAAsBA,WAAtB;AACAhU,OAAO,CAAC4c,UAAR,GAAqBA,UAArB;AACA5c,OAAO,CAACsS,gBAAR,GAA2BA,gBAA3B;AACAtS,OAAO,CAACgY,aAAR,GAAwBA,aAAxB;AACAhY,OAAO,CAAC+Y,WAAR,GAAsBA,WAAtB;AACA/Y,OAAO,CAACY,iBAAR,GAA4BA,iBAA5B;AACAZ,OAAO,CAACE,SAAR,GAAoBA,SAApB;AACAF,OAAO,CAACc,gBAAR,GAA2BA,gBAA3B;AACAd,OAAO,CAACe,mBAAR,GAA8BA,mBAA9B;AACAf,OAAO,CAACgB,UAAR,GAAqBA,UAArB;AACAhB,OAAO,CAACmB,UAAR,GAAqBA,UAArB;AACAnB,OAAO,CAACoB,WAAR,GAAsBA,WAAtB;AACApB,OAAO,CAACsB,wBAAR,GAAmCA,wBAAnC;AACAtB,OAAO,CAACqB,iBAAR,GAA4BA,iBAA5B;AACArB,OAAO,CAACiB,UAAR,GAAqBA,UAArB;AACAjB,OAAO,CAACuB,8BAAR,GAAyCA,8BAAzC;AACAvB,OAAO,CAACS,wBAAR,GAAmCA,wBAAnC;AACAT,OAAO,CAACwB,UAAR,GAAqBA,UAArB;AACAxB,OAAO,CAACkB,UAAR,GAAqBA,UAArB;AACAlB,OAAO,CAACmd,OAAR,GAAkBA,OAAlB;AACAnd,OAAO,CAACod,YAAR,GAAuBA,YAAvB;AACApd,OAAO,CAACie,eAAR,GAA0BxX,MAA1B;AACAzG,OAAO,CAACke,eAAR,GAA0Bja,MAA1B;AACAjE,OAAO,CAACqU,mBAAR,GAA8BA,mBAA9B;AACArU,OAAO,CAACuR,cAAR,GAAyBA,cAAzB;AACAvR,OAAO,CAAC4Y,aAAR,GAAwBA,aAAxB;AACA5Y,OAAO,CAACwX,kBAAR,GAA6BA,kBAA7B;AACAxX,OAAO,CAACud,qBAAR,GAAgCA,qBAAhC;AACAvd,OAAO,CAACuQ,gBAAR,GAA2BA,gBAA3B;AACAvQ,OAAO,CAAC0Y,eAAR,GAA0BA,eAA1B;AACA1Y,OAAO,CAAC4R,WAAR,GAAsBA,WAAtB;AACA5R,OAAO,CAAC4T,cAAR,GAAyBA,cAAzB;AACA5T,OAAO,CAACwZ,aAAR,GAAwBA,aAAxB;AACAxZ,OAAO,CAAC+d,eAAR,GAA0BA,eAA1B;AACA/d,OAAO,CAACge,cAAR,GAAyBA,cAAzB;AACAhe,OAAO,CAACgc,UAAR,GAAqBA,UAArB;AACAhc,OAAO,CAACsd,SAAR,GAAoBA,SAApB;AACAtd,OAAO,CAACyO,QAAR,GAAmBA,QAAnB;AACAzO,OAAO,CAACoH,MAAR,GAAiBA,MAAjB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass JOSEError extends Error {\n    constructor(message) {\n        super(message);\n        this.code = JOSEError.code;\n        this.name = this.constructor.name;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nJOSEError.code = 'ERR_JOSE_GENERIC';\nclass JWTClaimValidationFailed extends JOSEError {\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = JWTClaimValidationFailed.code;\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nJWTClaimValidationFailed.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\nclass JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JOSEAlgNotAllowed.code;\n    }\n}\nJOSEAlgNotAllowed.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\nclass JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JOSENotSupported.code;\n    }\n}\nJOSENotSupported.code = 'ERR_JOSE_NOT_SUPPORTED';\nclass JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWEDecryptionFailed.code;\n        this.message = 'decryption operation failed';\n    }\n}\nJWEDecryptionFailed.code = 'ERR_JWE_DECRYPTION_FAILED';\nclass JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWEInvalid.code;\n    }\n}\nJWEInvalid.code = 'ERR_JWE_INVALID';\nclass JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWSInvalid.code;\n    }\n}\nJWSInvalid.code = 'ERR_JWS_INVALID';\nclass JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWTInvalid.code;\n    }\n}\nJWTInvalid.code = 'ERR_JWT_INVALID';\nclass JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWKInvalid.code;\n    }\n}\nJWKInvalid.code = 'ERR_JWK_INVALID';\nclass JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWKSInvalid.code;\n    }\n}\nJWKSInvalid.code = 'ERR_JWKS_INVALID';\nclass JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWKSNoMatchingKey.code;\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n}\nJWKSNoMatchingKey.code = 'ERR_JWKS_NO_MATCHING_KEY';\nclass JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWKSMultipleMatchingKeys.code;\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n}\nJWKSMultipleMatchingKeys.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\nclass JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = JWSSignatureVerificationFailed.code;\n        this.message = 'signature verification failed';\n    }\n}\nJWSSignatureVerificationFailed.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\nclass JWTExpired extends JWTClaimValidationFailed {\n    constructor() {\n        super(...arguments);\n        this.code = JWTExpired.code;\n    }\n}\nJWTExpired.code = 'ERR_JWT_EXPIRED';\n\nconst isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n\nfunction isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nfunction isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nfunction concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nfunction p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nfunction uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nfunction uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nfunction lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nasync function concatKdf(digest, secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    let res;\n    for (let iter = 1; iter <= iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        if (!res) {\n            res = await digest('sha256', buf);\n        }\n        else {\n            res = concat(res, await digest('sha256', buf));\n        }\n    }\n    res = res.slice(0, bits >> 3);\n    return res;\n}\n\nfunction getGlobal() {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    throw new Error('unable to locate global object');\n}\nvar globalThis$1 = getGlobal();\n\nconst encode$1 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    const base64string = globalThis$1.btoa(arr.join(''));\n    return base64string.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nconst decode$1 = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return new Uint8Array(globalThis$1\n            .atob(encoded)\n            .split('')\n            .map((c) => c.charCodeAt(0)));\n    }\n    catch (_a) {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n\nconst bitLengths$1 = new Map([\n    ['A128CBC-HS256', 128],\n    ['A128GCM', 96],\n    ['A128GCMKW', 96],\n    ['A192CBC-HS384', 128],\n    ['A192GCM', 96],\n    ['A192GCMKW', 96],\n    ['A256CBC-HS512', 128],\n    ['A256GCM', 96],\n    ['A256GCMKW', 96],\n]);\nconst factory$1 = (random) => (alg) => {\n    const bitLength = bitLengths$1.get(alg);\n    if (!bitLength) {\n        throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n    return random(new Uint8Array(bitLength >> 3));\n};\n\nconst checkIvLength = (enc, iv) => {\n    if (iv.length << 3 !== bitLengths$1.get(enc)) {\n        throw new JWEInvalid('Invalid Initialization Vector length');\n    }\n};\n\nconst checkCekLength = (enc, cek) => {\n    let expected;\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            expected = parseInt(enc.substr(-3), 10);\n            if (!(cek instanceof Uint8Array)) {\n                throw new TypeError(`${enc} content encryption requires Uint8Array as key input`);\n            }\n            break;\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            expected = parseInt(enc.substr(1, 3), 10);\n            break;\n        default:\n            throw new JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);\n    }\n    if (cek instanceof Uint8Array) {\n        if (cek.length << 3 !== expected) {\n            throw new JWEInvalid('Invalid Content Encryption Key length');\n        }\n        return;\n    }\n    if (cek.algorithm !== undefined) {\n        const { length } = cek.algorithm;\n        if (length !== expected) {\n            throw new JWEInvalid('Invalid Content Encryption Key length');\n        }\n        return;\n    }\n    throw new TypeError('Invalid Content Encryption Key type');\n};\n\nconst timingSafeEqual = (a, b) => {\n    if (!(a instanceof Uint8Array)) {\n        throw new TypeError('First argument must be a buffer');\n    }\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('Second argument must be a buffer');\n    }\n    if (a.length !== b.length) {\n        throw new TypeError('Input buffers must have the same length');\n    }\n    const len = a.length;\n    let out = 0;\n    let i = -1;\n    while (++i < len) {\n        out |= a[i] ^ b[i];\n    }\n    return out === 0;\n};\n\nvar crypto = globalThis$1.crypto;\nfunction isCryptoKey(key) {\n    if (typeof globalThis$1.CryptoKey === 'undefined') {\n        return false;\n    }\n    return key != null && key instanceof globalThis$1.CryptoKey;\n}\n\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    const keySize = parseInt(enc.substr(1, 3), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: { name: `SHA-${keySize << 1}` },\n        name: 'HMAC',\n    }, false, ['sign']);\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    let macCheckPassed;\n    try {\n        macCheckPassed = timingSafeEqual(tag, expectedTag);\n    }\n    catch (_a) {\n    }\n    if (!macCheckPassed) {\n        throw new JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        plaintext = new Uint8Array(await crypto.subtle.decrypt({ iv, name: 'AES-CBC' }, encKey, ciphertext));\n    }\n    catch (_b) {\n    }\n    if (!plaintext) {\n        throw new JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nasync function gcmDecrypt(cek, ciphertext, iv, tag, aad) {\n    const encKey = cek instanceof Uint8Array\n        ? await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt'])\n        : cek;\n    try {\n        return new Uint8Array(await crypto.subtle.decrypt({\n            additionalData: aad,\n            iv,\n            name: 'AES-GCM',\n            tagLength: 128,\n        }, encKey, concat(ciphertext, tag)));\n    }\n    catch (err) {\n        throw new JWEDecryptionFailed();\n    }\n}\nconst decrypt$2 = async (enc, cek, ciphertext, iv, tag, aad) => {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError('invalid key input');\n    }\n    checkCekLength(enc, cek);\n    checkIvLength(enc, iv);\n    if (enc.substr(4, 3) === 'CBC') {\n        return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n    }\n    return gcmDecrypt(cek, ciphertext, iv, tag, aad);\n};\n\nconst inflate = async () => {\n    throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation, e.g. using the \"pako\" module.');\n};\nconst deflate = async () => {\n    throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime.');\n};\n\nconst bogusWebCrypto = [\n    { hash: { name: 'SHA-256' }, name: 'HMAC' },\n    true,\n    ['sign'],\n];\n\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.substr(1, 3), 10)) {\n        throw new TypeError(`invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey$2(key, usage) {\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    throw new TypeError('invalid key input');\n}\nconst wrap$1 = async (alg, key, cek) => {\n    const cryptoKey = await getCryptoKey$2(key, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\nconst unwrap$1 = async (alg, key, encryptedKey) => {\n    const cryptoKey = await getCryptoKey$2(key, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n};\n\nconst digest = async (algorithm, data) => {\n    const subtleDigest = `SHA-${algorithm.substr(-3)}`;\n    return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));\n};\n\nconst deriveKey = async (publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) => {\n    if (!isCryptoKey(publicKey)) {\n        throw new TypeError('invalid key input');\n    }\n    if (!isCryptoKey(privateKey)) {\n        throw new TypeError('invalid key input');\n    }\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    if (!privateKey.usages.includes('deriveBits')) {\n        throw new TypeError('ECDH-ES private key \"usages\" must include \"deriveBits\"');\n    }\n    const sharedSecret = new Uint8Array(await crypto.subtle.deriveBits({\n        name: 'ECDH',\n        public: publicKey,\n    }, privateKey, Math.ceil(parseInt(privateKey.algorithm.namedCurve.substr(-3), 10) / 8) <<\n        3));\n    return concatKdf(digest, sharedSecret, keyLength, value);\n};\nconst generateEpk = async (key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError('invalid key input');\n    }\n    return (await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: key.algorithm.namedCurve }, true, ['deriveBits'])).privateKey;\n};\nconst ecdhAllowed = (key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError('invalid key input');\n    }\n    return ['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve);\n};\n\nconst random$1 = crypto.getRandomValues.bind(crypto);\n\nfunction checkP2s(p2s) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n}\n\nfunction getCryptoKey$1(key) {\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    throw new TypeError('invalid key input');\n}\nconst encrypt$2 = async (alg, key, cek, p2c = Math.floor(Math.random() * 2049) + 2048, p2s$1 = random$1(new Uint8Array(16))) => {\n    checkP2s(p2s$1);\n    const salt = p2s(alg, p2s$1);\n    const keylen = parseInt(alg.substr(13, 3), 10);\n    const subtleAlg = {\n        hash: { name: `SHA-${alg.substr(8, 3)}` },\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const wrapAlg = {\n        length: keylen,\n        name: 'AES-KW',\n    };\n    const cryptoKey = await getCryptoKey$1(key);\n    let derived;\n    if (cryptoKey.usages.includes('deriveBits')) {\n        derived = new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n    }\n    else if (cryptoKey.usages.includes('deriveKey')) {\n        derived = await crypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey']);\n    }\n    else {\n        throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n    }\n    const encryptedKey = await wrap$1(alg.substr(-6), derived, cek);\n    return { encryptedKey, p2c, p2s: encode$1(p2s$1) };\n};\nconst decrypt$1 = async (alg, key, encryptedKey, p2c, p2s$1) => {\n    checkP2s(p2s$1);\n    const salt = p2s(alg, p2s$1);\n    const keylen = parseInt(alg.substr(13, 3), 10);\n    const subtleAlg = {\n        hash: { name: `SHA-${alg.substr(8, 3)}` },\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const wrapAlg = {\n        length: keylen,\n        name: 'AES-KW',\n    };\n    const cryptoKey = await getCryptoKey$1(key);\n    let derived;\n    if (cryptoKey.usages.includes('deriveBits')) {\n        derived = new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n    }\n    else if (cryptoKey.usages.includes('deriveKey')) {\n        derived = await crypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['unwrapKey']);\n    }\n    else {\n        throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n    }\n    return unwrap$1(alg.substr(-6), derived, encryptedKey);\n};\n\nfunction subtleRsaEs(alg) {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return 'RSA-OAEP';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n\nvar checkKeyLength = (alg, key) => {\n    if (alg.startsWith('HS')) {\n        const bitlen = parseInt(alg.substr(-3), 10);\n        const { length } = key.algorithm;\n        if (typeof length !== 'number' || length < bitlen) {\n            throw new TypeError(`${alg} requires symmetric keys to be ${bitlen} bits or larger`);\n        }\n    }\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n\nconst encrypt$1 = async (alg, key, cek) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError('invalid key input');\n    }\n    checkKeyLength(alg, key);\n    if (key.usages.includes('encrypt')) {\n        return new Uint8Array(await crypto.subtle.encrypt(subtleRsaEs(alg), key, cek));\n    }\n    if (key.usages.includes('wrapKey')) {\n        const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n        return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, key, subtleRsaEs(alg)));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n};\nconst decrypt = async (alg, key, encryptedKey) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError('invalid key input');\n    }\n    checkKeyLength(alg, key);\n    if (key.usages.includes('decrypt')) {\n        return new Uint8Array(await crypto.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));\n    }\n    if (key.usages.includes('unwrapKey')) {\n        const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, key, subtleRsaEs(alg), ...bogusWebCrypto);\n        return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n};\n\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    const keySize = parseInt(enc.substr(1, 3), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: { name: `SHA-${keySize << 1}` },\n        name: 'HMAC',\n    }, false, ['sign']);\n    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({\n        iv,\n        name: 'AES-CBC',\n    }, encKey, plaintext));\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const tag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    return { ciphertext, tag };\n}\nasync function gcmEncrypt(plaintext, cek, iv, aad) {\n    const encKey = cek instanceof Uint8Array\n        ? await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt'])\n        : cek;\n    const encrypted = new Uint8Array(await crypto.subtle.encrypt({\n        additionalData: aad,\n        iv,\n        name: 'AES-GCM',\n        tagLength: 128,\n    }, encKey, plaintext));\n    const tag = encrypted.slice(-16);\n    const ciphertext = encrypted.slice(0, -16);\n    return { ciphertext, tag };\n}\nconst encrypt = async (enc, plaintext, cek, iv, aad) => {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError('invalid key input');\n    }\n    checkCekLength(enc, cek);\n    checkIvLength(enc, iv);\n    if (enc.substr(4, 3) === 'CBC') {\n        return cbcEncrypt(enc, plaintext, cek, iv, aad);\n    }\n    return gcmEncrypt(plaintext, cek, iv, aad);\n};\n\nconst generateIv$1 = factory$1(random$1);\nconst wrap = async (alg, key, cek, iv) => {\n    const jweAlgorithm = alg.substr(0, 7);\n    iv || (iv = generateIv$1(jweAlgorithm));\n    const { ciphertext: encryptedKey, tag } = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n    return { encryptedKey, iv: encode$1(iv), tag: encode$1(tag) };\n};\nconst unwrap = async (alg, key, encryptedKey, iv, tag) => {\n    const jweAlgorithm = alg.substr(0, 7);\n    return decrypt$2(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n};\n\nconst bitLengths = new Map([\n    ['A128CBC-HS256', 256],\n    ['A128GCM', 128],\n    ['A192CBC-HS384', 384],\n    ['A192GCM', 192],\n    ['A256CBC-HS512', 512],\n    ['A256GCM', 256],\n]);\nconst factory = (random) => (alg) => {\n    const bitLength = bitLengths.get(alg);\n    if (!bitLength) {\n        throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n    return random(new Uint8Array(bitLength >> 3));\n};\n\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'oct': {\n            switch (jwk.alg) {\n                case 'HS256':\n                case 'HS384':\n                case 'HS512':\n                    algorithm = { name: 'HMAC', hash: { name: `SHA-${jwk.alg.substr(-3)}` } };\n                    keyUsages = ['sign', 'verify'];\n                    break;\n                case 'A128CBC-HS256':\n                case 'A192CBC-HS384':\n                case 'A256CBC-HS512':\n                    throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);\n                case 'A128GCM':\n                case 'A192GCM':\n                case 'A256GCM':\n                case 'A128GCMKW':\n                case 'A192GCMKW':\n                case 'A256GCMKW':\n                    algorithm = { name: 'AES-GCM' };\n                    keyUsages = ['encrypt', 'decrypt'];\n                    break;\n                case 'A128KW':\n                case 'A192KW':\n                case 'A256KW':\n                    algorithm = { name: 'AES-KW' };\n                    keyUsages = ['wrapKey', 'unwrapKey'];\n                    break;\n                case 'PBES2-HS256+A128KW':\n                case 'PBES2-HS384+A192KW':\n                case 'PBES2-HS512+A256KW':\n                    algorithm = { name: 'PBKDF2' };\n                    keyUsages = ['deriveBits'];\n                    break;\n                default:\n                    throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: { name: `SHA-${jwk.alg.substr(-3)}` } };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: { name: `SHA-${jwk.alg.substr(-3)}` } };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: { name: `SHA-${parseInt(jwk.alg.substr(-3), 10) || 1}` },\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                case 'ES384':\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('unsupported or invalid JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nconst parse = async (jwk) => {\n    var _a, _b;\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    let format = 'jwk';\n    let keyData = { ...jwk };\n    delete keyData.alg;\n    if (algorithm.name === 'PBKDF2') {\n        format = 'raw';\n        keyData = decode$1(jwk.k);\n    }\n    return crypto.subtle.importKey(format, keyData, algorithm, (_a = jwk.ext) !== null && _a !== void 0 ? _a : false, (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages);\n};\n\nasync function parseJwk(jwk, alg, octAsKeyObject) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    if (typeof alg !== 'string' || !alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return parse({ ...jwk, alg, ext: false });\n            }\n            return decode$1(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return parse({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n\nfunction assertEnryptedKey(encryptedKey) {\n    if (!encryptedKey) {\n        throw new JWEInvalid('JWE Encrypted Key missing');\n    }\n}\nfunction assertHeaderParameter(joseHeader, parameter, name) {\n    if (joseHeader[parameter] === undefined) {\n        throw new JWEInvalid(`JOSE Header ${name} (${parameter}) missing`);\n    }\n}\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader) {\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined) {\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            }\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined) {\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            }\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            assertHeaderParameter(joseHeader, 'epk', 'Ephemeral Public Key');\n            if (!ecdhAllowed(key)) {\n                throw new JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const epk = await parseJwk(joseHeader.epk, alg);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined)\n                partyUInfo = decode$1(joseHeader.apu);\n            if (joseHeader.apv !== undefined)\n                partyVInfo = decode$1(joseHeader.apv);\n            const sharedSecret = await deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, parseInt(alg.substr(-5, 3), 10) || bitLengths.get(joseHeader.enc), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES') {\n                return sharedSecret;\n            }\n            assertEnryptedKey(encryptedKey);\n            const kwAlg = alg.substr(-6);\n            return unwrap$1(kwAlg, sharedSecret, encryptedKey);\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            assertEnryptedKey(encryptedKey);\n            return decrypt(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            assertEnryptedKey(encryptedKey);\n            assertHeaderParameter(joseHeader, 'p2c', 'PBES2 Count');\n            assertHeaderParameter(joseHeader, 'p2s', 'PBES2 Salt');\n            const { p2c } = joseHeader;\n            const p2s = decode$1(joseHeader.p2s);\n            return decrypt$1(alg, key, encryptedKey, p2c, p2s);\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            assertEnryptedKey(encryptedKey);\n            return unwrap$1(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            assertEnryptedKey(encryptedKey);\n            assertHeaderParameter(joseHeader, 'iv', 'Initialization Vector');\n            assertHeaderParameter(joseHeader, 'tag', 'Authentication Tag');\n            const iv = decode$1(joseHeader.iv);\n            const tag = decode$1(joseHeader.tag);\n            return unwrap(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new JOSENotSupported('unsupported or invalid \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\n\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\n\nconst validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\n\nconst generateCek$1 = factory(random$1);\nconst checkExtensions$3 = validateCrit.bind(undefined, JWEInvalid, new Map());\nconst checkAlgOption$1 = validateAlgorithms.bind(undefined, 'keyManagementAlgorithms');\nconst checkEncOption = validateAlgorithms.bind(undefined, 'contentEncryptionAlgorithms');\nasync function flattenedDecrypt(jwe, key, options) {\n    var _a;\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new JWEInvalid('JOSE Header missing');\n    }\n    if (typeof jwe.iv !== 'string') {\n        throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (typeof jwe.tag !== 'string') {\n        throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !isObject(jwe.header)) {\n        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        const protectedHeader = decode$1(jwe.protected);\n        parsedProt = JSON.parse(decoder.decode(protectedHeader));\n    }\n    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    checkExtensions$3(options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        if (!parsedProt || !parsedProt.zip) {\n            throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n        }\n        if (joseHeader.zip !== 'DEF') {\n            throw new JOSENotSupported('unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n        }\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && checkAlgOption$1(options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options && checkEncOption(options.contentEncryptionAlgorithms);\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        encryptedKey = decode$1(jwe.encrypted_key);\n    }\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n    }\n    let cek;\n    try {\n        cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader);\n    }\n    catch (err) {\n        if (err instanceof TypeError) {\n            throw err;\n        }\n        cek = generateCek$1(enc);\n    }\n    const iv = decode$1(jwe.iv);\n    const tag = decode$1(jwe.tag);\n    const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let plaintext = await decrypt$2(enc, cek, decode$1(jwe.ciphertext), iv, tag, additionalData);\n    if (joseHeader.zip === 'DEF') {\n        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);\n    }\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        result.additionalAuthenticatedData = decode$1(jwe.aad);\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    return result;\n}\n\nasync function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await flattenedDecrypt({\n        ciphertext: (ciphertext || undefined),\n        iv: (iv || undefined),\n        protected: protectedHeader || undefined,\n        tag: (tag || undefined),\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    return { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n}\n\nconst keyToJWK = async (key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError('invalid key input');\n    }\n    if (!key.extractable) {\n        throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n    }\n    const { ext, key_ops, alg, use, ...jwk } = await crypto.subtle.exportKey('jwk', key);\n    return jwk;\n};\n\nasync function fromKeyLike(key) {\n    if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: encode$1(key),\n        };\n    }\n    return keyToJWK(key);\n}\n\nconst generateCek = factory(random$1);\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!ecdhAllowed(key)) {\n                throw new JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let { epk: ephemeralKey } = providedParameters;\n            ephemeralKey || (ephemeralKey = await generateEpk(key));\n            const { x, y, crv, kty } = await fromKeyLike(ephemeralKey);\n            const sharedSecret = await deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, parseInt(alg.substr(-5, 3), 10) || bitLengths.get(enc), apu, apv);\n            parameters = { epk: { x, y, crv, kty } };\n            if (apu)\n                parameters.apu = encode$1(apu);\n            if (apv)\n                parameters.apv = encode$1(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || generateCek(enc);\n            const kwAlg = alg.substr(-6);\n            encryptedKey = await wrap$1(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await encrypt$1(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || generateCek(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await encrypt$2(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await wrap$1(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || generateCek(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await wrap(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new JOSENotSupported('unsupported or invalid \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\n\nconst generateIv = factory$1(random$1);\nconst checkExtensions$2 = validateCrit.bind(undefined, JWEInvalid, new Map());\nclass FlattenedEncrypt {\n    constructor(plaintext) {\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        checkExtensions$2(options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (!this._protectedHeader) {\n                    this.setProtectedHeader(parameters);\n                }\n                else {\n                    this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(encode$1(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = encode$1(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: encode$1(ciphertext),\n            iv: encode$1(this._iv),\n            tag: encode$1(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = encode$1(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n\nclass CompactEncrypt {\n    constructor(plaintext) {\n        this._flattened = new FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this._flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this._flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this._flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this._flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n\nasync function generalDecrypt(jwe, key, options) {\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('General JWE must be an object');\n    }\n    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {\n        throw new JWEInvalid('JWE Recipients missing or incorrect type');\n    }\n    for (const recipient of jwe.recipients) {\n        try {\n            return await flattenedDecrypt({\n                aad: jwe.aad,\n                ciphertext: jwe.ciphertext,\n                encrypted_key: recipient.encrypted_key,\n                header: recipient.header,\n                iv: jwe.iv,\n                protected: jwe.protected,\n                tag: jwe.tag,\n                unprotected: jwe.unprotected,\n            }, key, options);\n        }\n        catch (_a) {\n        }\n    }\n    throw new JWEDecryptionFailed();\n}\n\nasync function EmbeddedJWK(protectedHeader, token) {\n    const joseHeader = {\n        ...protectedHeader,\n        ...token.header,\n    };\n    if (!isObject(joseHeader.jwk)) {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n    }\n    const key = await parseJwk(joseHeader.jwk, joseHeader.alg, true);\n    if (key.type !== 'public') {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n    }\n    return key;\n}\n\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new JWKInvalid(`${description} missing or invalid`);\n    }\n};\nasync function calculateThumbprint(jwk, digestAlgorithm = 'sha256') {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = encoder.encode(JSON.stringify(components));\n    return encode$1(await digest(digestAlgorithm, data));\n}\n\nconst fetchJwks = async (url, timeout) => {\n    let controller;\n    if (typeof AbortController === 'function') {\n        controller = new AbortController();\n        setTimeout(() => controller.abort(), timeout);\n    }\n    const response = await globalThis$1.fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: 'manual',\n        referrerPolicy: 'no-referrer',\n        credentials: 'omit',\n        mode: 'cors',\n        method: 'GET',\n    });\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch (err) {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\n\nfunction getKtyFromAlg(alg) {\n    switch (alg.substr(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nclass RemoteJWKSet {\n    constructor(url, options) {\n        this._cached = new WeakMap();\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent };\n        this._timeoutDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;\n    }\n    coolingDown() {\n        if (typeof this._cooldownStarted === 'undefined') {\n            return false;\n        }\n        return Date.now() < this._cooldownStarted + this._cooldownDuration;\n    }\n    async getKey(protectedHeader) {\n        if (!this._jwks) {\n            await this.reload();\n        }\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = jwk.kty === getKtyFromAlg(protectedHeader.alg);\n            if (candidate && typeof protectedHeader.kid === 'string') {\n                candidate = protectedHeader.kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = protectedHeader.alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate && protectedHeader.alg === 'EdDSA') {\n                candidate = ['Ed25519', 'Ed448'].includes(jwk.crv);\n            }\n            if (candidate) {\n                switch (protectedHeader.alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            if (this.coolingDown() === false) {\n                await this.reload();\n                return this.getKey(protectedHeader);\n            }\n            throw new JWKSNoMatchingKey();\n        }\n        else if (length !== 1) {\n            throw new JWKSMultipleMatchingKeys();\n        }\n        if (!this._cached.has(jwk)) {\n            this._cached.set(jwk, {});\n        }\n        const cached = this._cached.get(jwk);\n        if (cached[protectedHeader.alg] === undefined) {\n            const keyObject = (await parseJwk({ ...jwk, alg: protectedHeader.alg }));\n            if (keyObject.type !== 'public') {\n                throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n            }\n            cached[protectedHeader.alg] = keyObject;\n        }\n        return cached[protectedHeader.alg];\n    }\n    async reload() {\n        if (!this._pendingFetch) {\n            this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options)\n                .then((json) => {\n                if (typeof json !== 'object' ||\n                    !json ||\n                    !Array.isArray(json.keys) ||\n                    !json.keys.every(isJWKLike)) {\n                    throw new JWKSInvalid('JSON Web Key Set malformed');\n                }\n                this._jwks = { keys: json.keys };\n                this._cooldownStarted = Date.now();\n                this._pendingFetch = undefined;\n            })\n                .catch((err) => {\n                this._pendingFetch = undefined;\n                throw err;\n            });\n        }\n        await this._pendingFetch;\n    }\n}\nfunction createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    return set.getKey.bind(set);\n}\n\nfunction subtleDsa(alg) {\n    switch (alg) {\n        case 'HS256':\n            return { hash: { name: 'SHA-256' }, name: 'HMAC' };\n        case 'HS384':\n            return { hash: { name: 'SHA-384' }, name: 'HMAC' };\n        case 'HS512':\n            return { hash: { name: 'SHA-512' }, name: 'HMAC' };\n        case 'PS256':\n            return {\n                hash: { name: 'SHA-256' },\n                name: 'RSA-PSS',\n                saltLength: 256 >> 3,\n            };\n        case 'PS384':\n            return {\n                hash: { name: 'SHA-384' },\n                name: 'RSA-PSS',\n                saltLength: 384 >> 3,\n            };\n        case 'PS512':\n            return {\n                hash: { name: 'SHA-512' },\n                name: 'RSA-PSS',\n                saltLength: 512 >> 3,\n            };\n        case 'RS256':\n            return { hash: { name: 'SHA-256' }, name: 'RSASSA-PKCS1-v1_5' };\n        case 'RS384':\n            return { hash: { name: 'SHA-384' }, name: 'RSASSA-PKCS1-v1_5' };\n        case 'RS512':\n            return { hash: { name: 'SHA-512' }, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n            return { hash: { name: 'SHA-256' }, name: 'ECDSA', namedCurve: 'P-256' };\n        case 'ES384':\n            return { hash: { name: 'SHA-384' }, name: 'ECDSA', namedCurve: 'P-384' };\n        case 'ES512':\n            return { hash: { name: 'SHA-512' }, name: 'ECDSA', namedCurve: 'P-521' };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n\nfunction getCryptoKey(alg, key, usage) {\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError('symmetric keys are only applicable for HMAC-based algorithms');\n        }\n        return crypto.subtle.importKey('raw', key, { hash: { name: `SHA-${alg.substr(-3)}` }, name: 'HMAC' }, false, [usage]);\n    }\n    throw new TypeError('invalid key input');\n}\n\nconst sign = async (alg, key, data) => {\n    const cryptoKey = await getCryptoKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleDsa(alg), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n\nconst checkKeyType = (alg, key) => {\n    if (alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        alg.match(/^A\\d{3}(?:GCM)KW$/)) {\n        if (key instanceof Uint8Array || key.type === 'secret') {\n            return;\n        }\n        throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type \"secret\"');\n    }\n    if (key instanceof Uint8Array) {\n        throw new TypeError('CryptoKey or KeyObject instances must be used for asymmetric algorithms');\n    }\n    if (key.type === 'secret') {\n        throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type \"secret\"');\n    }\n};\n\nconst checkExtensions$1 = validateCrit.bind(undefined, JWSInvalid, new Map([['b64', true]]));\nclass FlattenedSign {\n    constructor(payload) {\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = checkExtensions$1(options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key);\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(encode$1(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(encode$1(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: encode$1(signature),\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n\nclass CompactSign {\n    constructor(payload) {\n        this._flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n\nconst verify = async (alg, key, signature, data) => {\n    const cryptoKey = await getCryptoKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleDsa(alg);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch (_a) {\n        return false;\n    }\n};\n\nconst checkExtensions = validateCrit.bind(undefined, JWSInvalid, new Map([['b64', true]]));\nconst checkAlgOption = validateAlgorithms.bind(undefined, 'algorithms');\nasync function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        const protectedHeader = decode$1(jws.protected);\n        parsedProt = JSON.parse(decoder.decode(protectedHeader));\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = checkExtensions(options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && checkAlgOption(options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n    }\n    checkKeyType(alg, key);\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = decode$1(jws.signature);\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = decode$1(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    return result;\n}\n\nasync function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({\n        payload: (payload || undefined),\n        protected: protectedHeader || undefined,\n        signature: (signature || undefined),\n    }, key, options);\n    return { payload: verified.payload, protectedHeader: verified.protectedHeader };\n}\n\nconst signatureRef = new WeakMap();\nclass IndividualSignature {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    set _protectedHeader(value) {\n        signatureRef.get(this).protectedHeader = value;\n    }\n    get _protectedHeader() {\n        return signatureRef.get(this).protectedHeader;\n    }\n    set _unprotectedHeader(value) {\n        signatureRef.get(this).unprotectedHeader = value;\n    }\n    get _unprotectedHeader() {\n        return signatureRef.get(this).unprotectedHeader;\n    }\n}\nclass GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature();\n        signatureRef.set(signature, { key, options });\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n        };\n        await Promise.all(this._signatures.map(async (sig, i) => {\n            const { protectedHeader, unprotectedHeader, options, key } = signatureRef.get(sig);\n            const flattened = new FlattenedSign(this._payload);\n            if (protectedHeader) {\n                flattened.setProtectedHeader(protectedHeader);\n            }\n            if (unprotectedHeader) {\n                flattened.setUnprotectedHeader(unprotectedHeader);\n            }\n            const { payload, ...rest } = await flattened.sign(key, options);\n            if ('payload' in jws && jws.payload !== payload) {\n                throw new JWSInvalid(`index ${i} signature produced a different payload`);\n            }\n            else {\n                jws.payload = payload;\n            }\n            jws.signatures.push(rest);\n        }));\n        if ('payload' in jws && jws.payload === undefined) {\n            delete jws.payload;\n        }\n        return jws;\n    }\n}\n\nasync function generalVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('General JWS must be an object');\n    }\n    if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {\n        throw new JWSInvalid('JWS Signatures missing or incorrect type');\n    }\n    for (const signature of jws.signatures) {\n        try {\n            return await flattenedVerify({\n                header: signature.header,\n                payload: jws.payload,\n                protected: signature.protected,\n                signature: signature.signature,\n            }, key, options);\n        }\n        catch (_a) {\n        }\n    }\n    throw new JWSSignatureVerificationFailed();\n}\n\nvar epoch = (date) => Math.floor(date.getTime() / 1000);\n\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\nvar secs = (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n};\n\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nvar jwtPayload = (protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch (_a) {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { issuer } = options;\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    const { subject } = options;\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    const { audience } = options;\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if (payload.iat !== undefined || options.maxTokenAge) {\n        if (typeof payload.iat !== 'number') {\n            throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n        }\n        if (payload.exp === undefined && payload.iat > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (options.maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : secs(options.maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n\nasync function jwtDecrypt(jwt, key, options) {\n    const decrypted = await compactDecrypt(jwt, key, options);\n    const payload = jwtPayload(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', 'aud', 'mismatch');\n    }\n    return { payload, protectedHeader };\n}\n\nclass ProduceJWT {\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: input };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: input };\n        }\n        else {\n            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: epoch(new Date()) };\n        }\n        else {\n            this._payload = { ...this._payload, iat: input };\n        }\n        return this;\n    }\n}\n\nclass EncryptJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this._replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this._replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this._replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));\n        if (this._replicateIssuerAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };\n        }\n        if (this._replicateSubjectAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };\n        }\n        if (this._replicateAudienceAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };\n        }\n        enc.setProtectedHeader(this._protectedHeader);\n        if (this._iv) {\n            enc.setInitializationVector(this._iv);\n        }\n        if (this._cek) {\n            enc.setContentEncryptionKey(this._cek);\n        }\n        if (this._keyManagementParameters) {\n            enc.setKeyManagementParameters(this._keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n\nclass SignJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        var _a;\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (((_a = this._protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n\nclass UnsecuredJWT extends ProduceJWT {\n    encode() {\n        const header = encode$1(JSON.stringify({ alg: 'none' }));\n        const payload = encode$1(JSON.stringify(this._payload));\n        return `${header}.${payload}.`;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(decoder.decode(decode$1(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch (_a) {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = jwtPayload(header, decode$1(encodedPayload), options);\n        return { payload, header };\n    }\n}\n\nasync function jwtVerify(jwt, key, options) {\n    var _a;\n    const verified = await compactVerify(jwt, key, options);\n    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    return { payload, protectedHeader: verified.protectedHeader };\n}\n\nconst encode = encode$1;\nconst decode = decode$1;\n\nfunction decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(decode(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch (err) {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n\nasync function generateSecret$1(alg, options) {\n    var _a;\n    let length;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            length = parseInt(alg.substr(-3), 10);\n            algorithm = { name: 'HMAC', hash: { name: `SHA-${alg.substr(-3)}` }, length };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.substr(-3), 10);\n            return random$1(new Uint8Array(length >> 3));\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n            length = parseInt(alg.substring(1, 4), 10);\n            algorithm = { name: 'AES-KW', length };\n            keyUsages = ['wrapKey', 'unwrapKey'];\n            break;\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.substring(1, 4), 10);\n            algorithm = { name: 'AES-GCM', length };\n            keyUsages = ['encrypt', 'decrypt'];\n            break;\n        default:\n            throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return (crypto.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages));\n}\nfunction getModulusLengthOption(options) {\n    var _a;\n    const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new JOSENotSupported('invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n    }\n    return modulusLength;\n}\nasync function generateKeyPair$1(alg, options) {\n    var _a, _b;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = {\n                name: 'RSA-PSS',\n                hash: { name: `SHA-${alg.substr(-3)}` },\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: { name: `SHA-${alg.substr(-3)}` },\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: { name: `SHA-${parseInt(alg.substr(-3), 10) || 1}` },\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW':\n            algorithm = { name: 'ECDH', namedCurve: (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : 'P-256' };\n            keyUsages = ['deriveKey', 'deriveBits'];\n            break;\n        default:\n            throw new JOSENotSupported('unsupported or invalid JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return (crypto.subtle.generateKey(algorithm, (_b = options === null || options === void 0 ? void 0 : options.extractable) !== null && _b !== void 0 ? _b : false, keyUsages));\n}\n\nasync function generateKeyPair(alg, options) {\n    return generateKeyPair$1(alg, options);\n}\n\nasync function generateSecret(alg, options) {\n    return generateSecret$1(alg, options);\n}\n\nconst random = random$1;\n\nexports.CompactEncrypt = CompactEncrypt;\nexports.CompactSign = CompactSign;\nexports.EmbeddedJWK = EmbeddedJWK;\nexports.EncryptJWT = EncryptJWT;\nexports.FlattenedEncrypt = FlattenedEncrypt;\nexports.FlattenedSign = FlattenedSign;\nexports.GeneralSign = GeneralSign;\nexports.JOSEAlgNotAllowed = JOSEAlgNotAllowed;\nexports.JOSEError = JOSEError;\nexports.JOSENotSupported = JOSENotSupported;\nexports.JWEDecryptionFailed = JWEDecryptionFailed;\nexports.JWEInvalid = JWEInvalid;\nexports.JWKInvalid = JWKInvalid;\nexports.JWKSInvalid = JWKSInvalid;\nexports.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;\nexports.JWKSNoMatchingKey = JWKSNoMatchingKey;\nexports.JWSInvalid = JWSInvalid;\nexports.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;\nexports.JWTClaimValidationFailed = JWTClaimValidationFailed;\nexports.JWTExpired = JWTExpired;\nexports.JWTInvalid = JWTInvalid;\nexports.SignJWT = SignJWT;\nexports.UnsecuredJWT = UnsecuredJWT;\nexports.base64UrlDecode = decode;\nexports.base64UrlEncode = encode;\nexports.calculateThumbprint = calculateThumbprint;\nexports.compactDecrypt = compactDecrypt;\nexports.compactVerify = compactVerify;\nexports.createRemoteJWKSet = createRemoteJWKSet;\nexports.decodeProtectedHeader = decodeProtectedHeader;\nexports.flattenedDecrypt = flattenedDecrypt;\nexports.flattenedVerify = flattenedVerify;\nexports.fromKeyLike = fromKeyLike;\nexports.generalDecrypt = generalDecrypt;\nexports.generalVerify = generalVerify;\nexports.generateKeyPair = generateKeyPair;\nexports.generateSecret = generateSecret;\nexports.jwtDecrypt = jwtDecrypt;\nexports.jwtVerify = jwtVerify;\nexports.parseJwk = parseJwk;\nexports.random = random;\n"]},"metadata":{},"sourceType":"script"}